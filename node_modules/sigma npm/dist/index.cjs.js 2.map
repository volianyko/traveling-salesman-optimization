{"version":3,"file":"index.cjs.js","sources":["../../../node_modules/graphology-utils/is-graph.js","../src/utils/matrices.ts","../src/utils/data.ts","../src/utils/index.ts","../src/utils/easings.ts","../src/utils/animate.ts","../../../node_modules/events/events.js","../src/types.ts","../src/core/camera.ts","../src/core/captors/captor.ts","../src/core/captors/mouse.ts","../src/core/labels.ts","../src/rendering/utils.ts","../src/rendering/program.ts","../src/rendering/node.ts","../src/rendering/programs/node-point/vert.glsl","../src/rendering/programs/node-point/frag.glsl","../src/rendering/programs/node-point/index.ts","../src/rendering/edge.ts","../src/rendering/programs/edge-rectangle/vert.glsl","../src/rendering/programs/edge-rectangle/frag.glsl","../src/rendering/programs/edge-rectangle/index.ts","../src/rendering/programs/edge-arrow-head/vert.glsl","../src/rendering/programs/edge-arrow-head/frag.glsl","../src/rendering/programs/edge-arrow-head/index.ts","../src/rendering/programs/edge-clamped/vert.glsl","../src/rendering/programs/edge-clamped/index.ts","../src/rendering/programs/edge-arrow/index.ts","../src/rendering/edge-labels.ts","../src/rendering/node-labels.ts","../src/rendering/node-hover.ts","../src/settings.ts","../src/core/captors/touch.ts","../src/utils/array.ts","../src/utils/picking.ts","../src/sigma.ts"],"sourcesContent":["/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n","/**\n * Sigma.js WebGL Matrices Helpers\n * ================================\n *\n * Matrices-related helper functions used by sigma's WebGL renderer.\n * @module\n */\nimport { Coordinates } from \"../types\";\n\nexport function identity(): Float32Array {\n  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);\n}\n\n// TODO: optimize\nexport function scale(m: Float32Array, x: number, y?: number): Float32Array {\n  m[0] = x;\n  m[4] = typeof y === \"number\" ? y : x;\n\n  return m;\n}\n\nexport function rotate(m: Float32Array, r: number): Float32Array {\n  const s = Math.sin(r),\n    c = Math.cos(r);\n\n  m[0] = c;\n  m[1] = s;\n  m[3] = -s;\n  m[4] = c;\n\n  return m;\n}\n\nexport function translate(m: Float32Array, x: number, y: number): Float32Array {\n  m[6] = x;\n  m[7] = y;\n\n  return m;\n}\n\nexport function multiply<T extends number[] | Float32Array>(a: T, b: Float32Array | number[]): T {\n  const a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  const a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  const a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n\n  const b00 = b[0],\n    b01 = b[1],\n    b02 = b[2];\n  const b10 = b[3],\n    b11 = b[4],\n    b12 = b[5];\n  const b20 = b[6],\n    b21 = b[7],\n    b22 = b[8];\n\n  a[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  a[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  a[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n  a[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  a[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  a[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n  a[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  a[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  a[8] = b20 * a02 + b21 * a12 + b22 * a22;\n\n  return a;\n}\n\nexport function multiplyVec2(a: Float32Array | number[], b: Coordinates, z = 1): Coordinates {\n  const a00 = a[0];\n  const a01 = a[1];\n  const a10 = a[3];\n  const a11 = a[4];\n  const a20 = a[6];\n  const a21 = a[7];\n\n  const b0 = b.x;\n  const b1 = b.y;\n\n  return { x: b0 * a00 + b1 * a10 + a20 * z, y: b0 * a01 + b1 * a11 + a21 * z };\n}\n","export const HTML_COLORS: Record<string, string> = {\n  black: \"#000000\",\n  silver: \"#C0C0C0\",\n  gray: \"#808080\",\n  grey: \"#808080\",\n  white: \"#FFFFFF\",\n  maroon: \"#800000\",\n  red: \"#FF0000\",\n  purple: \"#800080\",\n  fuchsia: \"#FF00FF\",\n  green: \"#008000\",\n  lime: \"#00FF00\",\n  olive: \"#808000\",\n  yellow: \"#FFFF00\",\n  navy: \"#000080\",\n  blue: \"#0000FF\",\n  teal: \"#008080\",\n  aqua: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  mediumblue: \"#0000CD\",\n  darkgreen: \"#006400\",\n  darkcyan: \"#008B8B\",\n  deepskyblue: \"#00BFFF\",\n  darkturquoise: \"#00CED1\",\n  mediumspringgreen: \"#00FA9A\",\n  springgreen: \"#00FF7F\",\n  cyan: \"#00FFFF\",\n  midnightblue: \"#191970\",\n  dodgerblue: \"#1E90FF\",\n  lightseagreen: \"#20B2AA\",\n  forestgreen: \"#228B22\",\n  seagreen: \"#2E8B57\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  limegreen: \"#32CD32\",\n  mediumseagreen: \"#3CB371\",\n  turquoise: \"#40E0D0\",\n  royalblue: \"#4169E1\",\n  steelblue: \"#4682B4\",\n  darkslateblue: \"#483D8B\",\n  mediumturquoise: \"#48D1CC\",\n  indigo: \"#4B0082\",\n  darkolivegreen: \"#556B2F\",\n  cadetblue: \"#5F9EA0\",\n  cornflowerblue: \"#6495ED\",\n  rebeccapurple: \"#663399\",\n  mediumaquamarine: \"#66CDAA\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  slateblue: \"#6A5ACD\",\n  olivedrab: \"#6B8E23\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  mediumslateblue: \"#7B68EE\",\n  lawngreen: \"#7CFC00\",\n  chartreuse: \"#7FFF00\",\n  aquamarine: \"#7FFFD4\",\n  skyblue: \"#87CEEB\",\n  lightskyblue: \"#87CEFA\",\n  blueviolet: \"#8A2BE2\",\n  darkred: \"#8B0000\",\n  darkmagenta: \"#8B008B\",\n  saddlebrown: \"#8B4513\",\n  darkseagreen: \"#8FBC8F\",\n  lightgreen: \"#90EE90\",\n  mediumpurple: \"#9370DB\",\n  darkviolet: \"#9400D3\",\n  palegreen: \"#98FB98\",\n  darkorchid: \"#9932CC\",\n  yellowgreen: \"#9ACD32\",\n  sienna: \"#A0522D\",\n  brown: \"#A52A2A\",\n  darkgray: \"#A9A9A9\",\n  darkgrey: \"#A9A9A9\",\n  lightblue: \"#ADD8E6\",\n  greenyellow: \"#ADFF2F\",\n  paleturquoise: \"#AFEEEE\",\n  lightsteelblue: \"#B0C4DE\",\n  powderblue: \"#B0E0E6\",\n  firebrick: \"#B22222\",\n  darkgoldenrod: \"#B8860B\",\n  mediumorchid: \"#BA55D3\",\n  rosybrown: \"#BC8F8F\",\n  darkkhaki: \"#BDB76B\",\n  mediumvioletred: \"#C71585\",\n  indianred: \"#CD5C5C\",\n  peru: \"#CD853F\",\n  chocolate: \"#D2691E\",\n  tan: \"#D2B48C\",\n  lightgray: \"#D3D3D3\",\n  lightgrey: \"#D3D3D3\",\n  thistle: \"#D8BFD8\",\n  orchid: \"#DA70D6\",\n  goldenrod: \"#DAA520\",\n  palevioletred: \"#DB7093\",\n  crimson: \"#DC143C\",\n  gainsboro: \"#DCDCDC\",\n  plum: \"#DDA0DD\",\n  burlywood: \"#DEB887\",\n  lightcyan: \"#E0FFFF\",\n  lavender: \"#E6E6FA\",\n  darksalmon: \"#E9967A\",\n  violet: \"#EE82EE\",\n  palegoldenrod: \"#EEE8AA\",\n  lightcoral: \"#F08080\",\n  khaki: \"#F0E68C\",\n  aliceblue: \"#F0F8FF\",\n  honeydew: \"#F0FFF0\",\n  azure: \"#F0FFFF\",\n  sandybrown: \"#F4A460\",\n  wheat: \"#F5DEB3\",\n  beige: \"#F5F5DC\",\n  whitesmoke: \"#F5F5F5\",\n  mintcream: \"#F5FFFA\",\n  ghostwhite: \"#F8F8FF\",\n  salmon: \"#FA8072\",\n  antiquewhite: \"#FAEBD7\",\n  linen: \"#FAF0E6\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  oldlace: \"#FDF5E6\",\n  magenta: \"#FF00FF\",\n  deeppink: \"#FF1493\",\n  orangered: \"#FF4500\",\n  tomato: \"#FF6347\",\n  hotpink: \"#FF69B4\",\n  coral: \"#FF7F50\",\n  darkorange: \"#FF8C00\",\n  lightsalmon: \"#FFA07A\",\n  orange: \"#FFA500\",\n  lightpink: \"#FFB6C1\",\n  pink: \"#FFC0CB\",\n  gold: \"#FFD700\",\n  peachpuff: \"#FFDAB9\",\n  navajowhite: \"#FFDEAD\",\n  moccasin: \"#FFE4B5\",\n  bisque: \"#FFE4C4\",\n  mistyrose: \"#FFE4E1\",\n  blanchedalmond: \"#FFEBCD\",\n  papayawhip: \"#FFEFD5\",\n  lavenderblush: \"#FFF0F5\",\n  seashell: \"#FFF5EE\",\n  cornsilk: \"#FFF8DC\",\n  lemonchiffon: \"#FFFACD\",\n  floralwhite: \"#FFFAF0\",\n  snow: \"#FFFAFA\",\n  lightyellow: \"#FFFFE0\",\n  ivory: \"#FFFFF0\",\n};\n","/**\n * Sigma.js Utils\n * ===============\n *\n * Various helper functions & classes used throughout the library.\n * @module\n */\nimport Graph, { Attributes } from \"graphology-types\";\nimport isGraph from \"graphology-utils/is-graph\";\nimport { CameraState, Coordinates, Dimensions, Extent, PlainObject } from \"../types\";\nimport { multiply, identity, scale, rotate, translate, multiplyVec2 } from \"./matrices\";\nimport { HTML_COLORS } from \"./data\";\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nexport function isPlainObject(value: any): boolean {\n  return typeof value === \"object\" && value !== null && value.constructor === Object;\n}\n\n/**\n * Helper to use Object.assign with more than two objects.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexport function assign<T>(target: Partial<T> | undefined, ...objects: Array<Partial<T | undefined>>): T {\n  target = target || {};\n\n  for (let i = 0, l = objects.length; i < l; i++) {\n    const o = objects[i];\n\n    if (!o) continue;\n\n    Object.assign(target, o);\n  }\n\n  return target as T;\n}\n\n/**\n * Very simple recursive Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexport function assignDeep<T>(target: Partial<T> | undefined, ...objects: Array<Partial<T | undefined>>): T {\n  target = target || {};\n\n  for (let i = 0, l = objects.length; i < l; i++) {\n    const o = objects[i];\n\n    if (!o) continue;\n\n    for (const k in o) {\n      if (isPlainObject(o[k])) {\n        target[k] = assignDeep(target[k], o[k]);\n      } else {\n        target[k] = o[k];\n      }\n    }\n  }\n\n  return target as T;\n}\n\n/**\n * Just some dirty trick to make requestAnimationFrame and cancelAnimationFrame \"work\" in Node.js, for unit tests:\n */\nexport const requestFrame =\n  typeof requestAnimationFrame !== \"undefined\"\n    ? (callback: FrameRequestCallback) => requestAnimationFrame(callback)\n    : (callback: FrameRequestCallback) => setTimeout(callback, 0);\nexport const cancelFrame =\n  typeof cancelAnimationFrame !== \"undefined\"\n    ? (requestID: number) => cancelAnimationFrame(requestID)\n    : (requestID: number) => clearTimeout(requestID);\n\n/**\n * Function used to create DOM elements easily.\n *\n * @param  {string} tag        - Tag name of the element to create.\n * @param  {object} style      - Styles map.\n * @param  {object} attributes - Attributes map.\n * @return {HTMLElement}\n */\nexport function createElement<T extends HTMLElement>(\n  tag: string,\n  style?: Partial<CSSStyleDeclaration>,\n  attributes?: PlainObject<string>,\n): T {\n  const element: T = document.createElement(tag) as T;\n\n  if (style) {\n    for (const k in style) {\n      element.style[k] = style[k] as string;\n    }\n  }\n\n  if (attributes) {\n    for (const k in attributes) {\n      element.setAttribute(k, attributes[k]);\n    }\n  }\n\n  return element;\n}\n\n/**\n * Function returning the browser's pixel ratio.\n *\n * @return {number}\n */\nexport function getPixelRatio(): number {\n  if (typeof window.devicePixelRatio !== \"undefined\") return window.devicePixelRatio;\n\n  return 1;\n}\n\n/**\n * Function returning the graph's node extent in x & y.\n *\n * @param  {Graph}\n * @return {object}\n */\nexport function graphExtent(graph: Graph): { x: Extent; y: Extent } {\n  if (!graph.order) return { x: [0, 1], y: [0, 1] };\n\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let yMin = Infinity;\n  let yMax = -Infinity;\n\n  graph.forEachNode((_, attr) => {\n    const { x, y } = attr;\n\n    if (x < xMin) xMin = x;\n    if (x > xMax) xMax = x;\n\n    if (y < yMin) yMin = y;\n    if (y > yMax) yMax = y;\n  });\n\n  return { x: [xMin, xMax], y: [yMin, yMax] };\n}\n\n/**\n * Factory returning a function normalizing the given node's position & size.\n *\n * @param  {object}   extent  - Extent of the graph.\n * @return {function}\n */\nexport interface NormalizationFunction {\n  (data: Coordinates): Coordinates;\n  ratio: number;\n  inverse(data: Coordinates): Coordinates;\n  applyTo(data: Coordinates): void;\n}\nexport function createNormalizationFunction(extent: { x: Extent; y: Extent }): NormalizationFunction {\n  const {\n    x: [minX, maxX],\n    y: [minY, maxY],\n  } = extent;\n\n  let ratio = Math.max(maxX - minX, maxY - minY),\n    dX = (maxX + minX) / 2,\n    dY = (maxY + minY) / 2;\n\n  if (ratio === 0 || Math.abs(ratio) === Infinity || isNaN(ratio)) ratio = 1;\n  if (isNaN(dX)) dX = 0;\n  if (isNaN(dY)) dY = 0;\n\n  const fn = (data: Coordinates): Coordinates => {\n    return {\n      x: 0.5 + (data.x - dX) / ratio,\n      y: 0.5 + (data.y - dY) / ratio,\n    };\n  };\n\n  // TODO: possibility to apply this in batch over array of indices\n  fn.applyTo = (data: Coordinates): void => {\n    data.x = 0.5 + (data.x - dX) / ratio;\n    data.y = 0.5 + (data.y - dY) / ratio;\n  };\n\n  fn.inverse = (data: Coordinates): Coordinates => {\n    return {\n      x: dX + ratio * (data.x - 0.5),\n      y: dY + ratio * (data.y - 0.5),\n    };\n  };\n\n  fn.ratio = ratio;\n\n  return fn;\n}\n\n/**\n * Function ordering the given elements in reverse z-order so they drawn\n * the correct way.\n *\n * @param  {number}   extent   - [min, max] z values.\n * @param  {function} getter   - Z attribute getter function.\n * @param  {array}    elements - The array to sort.\n * @return {array} - The sorted array.\n */\nexport function zIndexOrdering<T>(_extent: Extent, getter: (e: T) => number, elements: Array<T>): Array<T> {\n  // If k is > n, we'll use a standard sort\n  return elements.sort(function (a, b) {\n    const zA = getter(a) || 0,\n      zB = getter(b) || 0;\n\n    if (zA < zB) return -1;\n    if (zA > zB) return 1;\n\n    return 0;\n  });\n\n  // TODO: counting sort optimization\n}\n\n/**\n * WebGL utils\n * ===========\n */\n\n/**\n * Memoized function returning a float-encoded color from various string\n * formats describing colors.\n */\nconst INT8 = new Int8Array(4);\nconst INT32 = new Int32Array(INT8.buffer, 0, 1);\nconst FLOAT32 = new Float32Array(INT8.buffer, 0, 1);\n\nconst RGBA_TEST_REGEX = /^\\s*rgba?\\s*\\(/;\nconst RGBA_EXTRACT_REGEX = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)(?:\\s*,\\s*(.*)?)?\\)\\s*$/;\n\ntype RGBAColor = { r: number; g: number; b: number; a: number };\n\nexport function parseColor(val: string): RGBAColor {\n  let r = 0; // byte\n  let g = 0; // byte\n  let b = 0; // byte\n  let a = 1; // float\n\n  // Handling hexadecimal notation\n  if (val[0] === \"#\") {\n    if (val.length === 4) {\n      r = parseInt(val.charAt(1) + val.charAt(1), 16);\n      g = parseInt(val.charAt(2) + val.charAt(2), 16);\n      b = parseInt(val.charAt(3) + val.charAt(3), 16);\n    } else {\n      r = parseInt(val.charAt(1) + val.charAt(2), 16);\n      g = parseInt(val.charAt(3) + val.charAt(4), 16);\n      b = parseInt(val.charAt(5) + val.charAt(6), 16);\n    }\n    if (val.length === 9) {\n      a = parseInt(val.charAt(7) + val.charAt(8), 16) / 255;\n    }\n  }\n\n  // Handling rgb notation\n  else if (RGBA_TEST_REGEX.test(val)) {\n    const match = val.match(RGBA_EXTRACT_REGEX);\n    if (match) {\n      r = +match[1];\n      g = +match[2];\n      b = +match[3];\n\n      if (match[4]) a = +match[4];\n    }\n  }\n\n  return { r, g, b, a };\n}\n\nconst FLOAT_COLOR_CACHE: { [key: string]: number } = {};\nfor (const htmlColor in HTML_COLORS) {\n  FLOAT_COLOR_CACHE[htmlColor] = floatColor(HTML_COLORS[htmlColor]);\n  // Replicating cache for hex values for free\n  FLOAT_COLOR_CACHE[HTML_COLORS[htmlColor]] = FLOAT_COLOR_CACHE[htmlColor];\n}\n\nexport function rgbaToFloat(r: number, g: number, b: number, a: number, masking?: boolean): number {\n  INT32[0] = (a << 24) | (b << 16) | (g << 8) | r;\n  if (masking) INT32[0] = INT32[0] & 0xfeffffff;\n  return FLOAT32[0];\n}\nexport function floatColor(val: string): number {\n  // The html color names are case-insensitive\n  val = val.toLowerCase();\n\n  // If the color is already computed, we yield it\n  if (typeof FLOAT_COLOR_CACHE[val] !== \"undefined\") return FLOAT_COLOR_CACHE[val];\n\n  const parsed = parseColor(val);\n  const { r, g, b } = parsed;\n  let { a } = parsed;\n  a = (a * 255) | 0;\n\n  const color = rgbaToFloat(r, g, b, a, true);\n\n  FLOAT_COLOR_CACHE[val] = color;\n\n  return color;\n}\n\nconst FLOAT_INDEX_CACHE: { [key: number]: number } = {};\n\nexport function indexToColor(index: number): number {\n  // If the index is already computed, we yield it\n  if (typeof FLOAT_INDEX_CACHE[index] !== \"undefined\") return FLOAT_INDEX_CACHE[index];\n\n  // To address issue #1397, one strategy is to keep encoding 4 bytes colors,\n  // but with alpha hard-set to 1.0 (or 255):\n  const r = (index & 0x00ff0000) >>> 16;\n  const g = (index & 0x0000ff00) >>> 8;\n  const b = index & 0x000000ff;\n  const a = 0x000000ff;\n\n  // The original 4 bytes color encoding was the following:\n  // const r = (index & 0xff000000) >>> 24;\n  // const g = (index & 0x00ff0000) >>> 16;\n  // const b = (index & 0x0000ff00) >>> 8;\n  // const a = index & 0x000000ff;\n\n  const color = rgbaToFloat(r, g, b, a, true);\n  FLOAT_INDEX_CACHE[index] = color;\n\n  return color;\n}\nexport function colorToIndex(r: number, g: number, b: number, _a: number): number {\n  // As for the function indexToColor, because of #1397 and the \"alpha is always\n  // 1.0\" strategy, we need to fix this function as well:\n  return b + (g << 8) + (r << 16);\n\n  // The original 4 bytes color decoding is the following:\n  // return a + (b << 8) + (g << 16) + (r << 24);\n}\n\n/**\n * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This\n * helps to deal with quadtree in particular.\n * But at some point, we need to rescale it so that it takes the best place in the screen, i.e. we always want to see two\n * nodes \"touching\" opposite sides of the graph, with the camera being at its default state.\n *\n * This function determines this ratio.\n */\nexport function getCorrectionRatio(\n  viewportDimensions: { width: number; height: number },\n  graphDimensions: { width: number; height: number },\n): number {\n  const viewportRatio = viewportDimensions.height / viewportDimensions.width;\n  const graphRatio = graphDimensions.height / graphDimensions.width;\n\n  // If the stage and the graphs are in different directions (such as the graph being wider that tall while the stage\n  // is taller than wide), we can stop here to have indeed nodes touching opposite sides:\n  if ((viewportRatio < 1 && graphRatio > 1) || (viewportRatio > 1 && graphRatio < 1)) {\n    return 1;\n  }\n\n  // Else, we need to fit the graph inside the stage:\n  // 1. If the graph is \"squarer\" (i.e. with a ratio closer to 1), we need to make the largest sides touch;\n  // 2. If the stage is \"squarer\", we need to make the smallest sides touch.\n  return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));\n}\n\n/**\n * Function returning a matrix from the current state of the camera.\n */\n\n// TODO: it's possible to optimize this drastically!\nexport function matrixFromCamera(\n  state: CameraState,\n  viewportDimensions: { width: number; height: number },\n  graphDimensions: { width: number; height: number },\n  padding: number,\n  inverse?: boolean,\n): Float32Array {\n  const { angle, ratio, x, y } = state;\n\n  const { width, height } = viewportDimensions;\n\n  const matrix = identity();\n\n  const smallestDimension = Math.min(width, height) - 2 * padding;\n\n  const correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);\n\n  if (!inverse) {\n    multiply(\n      matrix,\n      scale(\n        identity(),\n        2 * (smallestDimension / width) * correctionRatio,\n        2 * (smallestDimension / height) * correctionRatio,\n      ),\n    );\n    multiply(matrix, rotate(identity(), -angle));\n    multiply(matrix, scale(identity(), 1 / ratio));\n    multiply(matrix, translate(identity(), -x, -y));\n  } else {\n    multiply(matrix, translate(identity(), x, y));\n    multiply(matrix, scale(identity(), ratio));\n    multiply(matrix, rotate(identity(), angle));\n    multiply(\n      matrix,\n      scale(\n        identity(),\n        width / smallestDimension / 2 / correctionRatio,\n        height / smallestDimension / 2 / correctionRatio,\n      ),\n    );\n  }\n\n  return matrix;\n}\n\n/**\n * All these transformations we apply on the matrix to get it rescale the graph\n * as we want make it very hard to get pixel-perfect distances in WebGL. This\n * function returns a factor that properly cancels the matrix effect on lengths.\n *\n * [jacomyal]\n * To be fully honest, I can't really explain happens here... I notice that the\n * following ratio works (i.e. it correctly compensates the matrix impact on all\n * camera states I could try):\n * > `R = size(V) / size(M * V) / W`\n * as long as `M * V` is in the direction of W (ie. parallel to (Ox)). It works\n * as well with H and a vector that transforms into something parallel to (Oy).\n *\n * Also, note that we use `angle` and not `-angle` (that would seem logical,\n * since we want to anticipate the rotation), because the image is vertically\n * swapped in WebGL.\n */\nexport function getMatrixImpact(\n  matrix: Float32Array,\n  cameraState: CameraState,\n  viewportDimensions: Dimensions,\n): number {\n  const { x, y } = multiplyVec2(matrix, { x: Math.cos(cameraState.angle), y: Math.sin(cameraState.angle) }, 0);\n  return 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / viewportDimensions.width;\n}\n\n/**\n * Function extracting the color at the given pixel.\n */\nexport function extractPixel(gl: WebGLRenderingContext, x: number, y: number, array: Uint8Array): Uint8Array {\n  const data = array || new Uint8Array(4);\n\n  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n  return data;\n}\n\n/**\n * Check if the graph variable is a valid graph, and if sigma can render it.\n */\nexport function validateGraph(graph: Graph): void {\n  // check if it's a valid graphology instance\n  if (!isGraph(graph)) throw new Error(\"Sigma: invalid graph instance.\");\n\n  // check if nodes have x/y attributes\n  graph.forEachNode((key: string, attributes: Attributes) => {\n    if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {\n      throw new Error(\n        `Sigma: Coordinates of node ${key} are invalid. A node must have a numeric 'x' and 'y' attribute.`,\n      );\n    }\n  });\n}\n","/**\n * Sigma.js Easings\n * =================\n *\n * Handy collection of easing functions.\n * @module\n */\nexport const linear = (k: number): number => k;\n\nexport const quadraticIn = (k: number): number => k * k;\n\nexport const quadraticOut = (k: number): number => k * (2 - k);\n\nexport const quadraticInOut = (k: number): number => {\n  if ((k *= 2) < 1) return 0.5 * k * k;\n  return -0.5 * (--k * (k - 2) - 1);\n};\n\nexport const cubicIn = (k: number): number => k * k * k;\n\nexport const cubicOut = (k: number): number => --k * k * k + 1;\n\nexport const cubicInOut = (k: number): number => {\n  if ((k *= 2) < 1) return 0.5 * k * k * k;\n  return 0.5 * ((k -= 2) * k * k + 2);\n};\n\nconst easings: { [key: string]: (k: number) => number } = {\n  linear,\n  quadraticIn,\n  quadraticOut,\n  quadraticInOut,\n  cubicIn,\n  cubicOut,\n  cubicInOut,\n};\nexport default easings;\n","/**\n * Sigma.js Animation Helpers\n * ===========================\n *\n * Handy helper functions dealing with nodes & edges attributes animation.\n * @module\n */\nimport Graph from \"graphology-types\";\nimport { PlainObject } from \"../types\";\nimport { cancelFrame, requestFrame } from \"./index\";\nimport easings from \"./easings\";\n\n/**\n * Defaults.\n */\nexport type Easing = keyof typeof easings | ((k: number) => number);\n\nexport interface AnimateOptions {\n  easing: Easing;\n  duration: number;\n}\nexport const ANIMATE_DEFAULTS = {\n  easing: \"quadraticInOut\",\n  duration: 150,\n};\n\n/**\n * Function used to animate the nodes.\n */\nexport function animateNodes(\n  graph: Graph,\n  targets: PlainObject<PlainObject<number>>,\n  opts: Partial<AnimateOptions>,\n  callback?: () => void,\n): () => void {\n  const options: AnimateOptions = Object.assign({}, ANIMATE_DEFAULTS, opts);\n\n  const easing: (k: number) => number = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n  const start = Date.now();\n\n  const startPositions: PlainObject<PlainObject<number>> = {};\n\n  for (const node in targets) {\n    const attrs = targets[node];\n    startPositions[node] = {};\n\n    for (const k in attrs) startPositions[node][k] = graph.getNodeAttribute(node, k);\n  }\n\n  let frame: number | null = null;\n\n  const step = () => {\n    frame = null;\n\n    let p = (Date.now() - start) / options.duration;\n\n    if (p >= 1) {\n      // Animation is done\n      for (const node in targets) {\n        const attrs = targets[node];\n\n        // We use given values to avoid precision issues and for convenience\n        for (const k in attrs) graph.setNodeAttribute(node, k, attrs[k]);\n      }\n\n      if (typeof callback === \"function\") callback();\n\n      return;\n    }\n\n    p = easing(p);\n\n    for (const node in targets) {\n      const attrs = targets[node];\n      const s = startPositions[node];\n\n      for (const k in attrs) graph.setNodeAttribute(node, k, attrs[k] * p + s[k] * (1 - p));\n    }\n\n    frame = requestFrame(step);\n  };\n\n  step();\n\n  return () => {\n    if (frame) cancelFrame(frame);\n  };\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Sigma.js Types\n * ===============\n *\n * Various type declarations used throughout the library.\n * @module\n */\nimport { EventEmitter } from \"events\";\n\n/**\n * Util type to represent maps of typed elements, but implemented with\n * JavaScript objects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PlainObject<T = any> = { [k: string]: T };\n\n/**\n * Returns a type similar to T, but with the K set of properties of the type\n * T *required*, and the rest optional.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PartialButFor<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>> & { [others: string]: any };\n\nexport type NonEmptyArray<T> = [T, ...T[]];\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport interface CameraState extends Coordinates {\n  angle: number;\n  ratio: number;\n}\n\nexport type MouseInteraction = \"click\" | \"doubleClick\" | \"rightClick\" | \"wheel\" | \"down\";\n\nexport interface MouseCoords extends Coordinates {\n  sigmaDefaultPrevented: boolean;\n  preventSigmaDefault(): void;\n  original: MouseEvent;\n}\n\nexport interface WheelCoords extends MouseCoords {\n  delta: number; // This will store the delta actually used by sigma\n}\n\nexport interface TouchCoords {\n  touches: Coordinates[];\n  original: TouchEvent;\n}\n\nexport interface Dimensions {\n  width: number;\n  height: number;\n}\n\nexport type Extent = [number, number];\n\nexport interface DisplayData {\n  label: string | null;\n  size: number;\n  color: string;\n  hidden: boolean;\n  forceLabel: boolean;\n  zIndex: number;\n  type: string;\n}\n\nexport interface NodeDisplayData extends Coordinates, DisplayData {\n  highlighted: boolean;\n}\nexport interface EdgeDisplayData extends DisplayData {}\n\nexport type CoordinateConversionOverride = {\n  cameraState?: CameraState;\n  matrix?: Float32Array;\n  viewportDimensions?: Dimensions;\n  graphDimensions?: Dimensions;\n  padding?: number;\n};\n\nexport interface RenderParams {\n  width: number;\n  height: number;\n  sizeRatio: number;\n  zoomRatio: number;\n  pixelRatio: number;\n  correctionRatio: number;\n  matrix: Float32Array;\n  downSizingRatio: number;\n}\n\n/**\n * Custom event emitter types.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Listener = (...args: any[]) => void;\nexport type EventsMapping = Record<string, Listener>;\n\ninterface ITypedEventEmitter<Events extends EventsMapping> {\n  rawEmitter: EventEmitter;\n\n  eventNames<Event extends keyof Events>(): Array<Event>;\n  setMaxListeners(n: number): this;\n  getMaxListeners(): number;\n  emit<Event extends keyof Events>(type: Event, ...args: Parameters<Events[Event]>): boolean;\n  addListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  on<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  once<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  prependListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  prependOnceListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  removeListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  off<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  removeAllListeners<Event extends keyof Events>(type?: Event): this;\n  listeners<Event extends keyof Events>(type: Event): Events[Event][];\n  listenerCount<Event extends keyof Events>(type: Event): number;\n  rawListeners<Event extends keyof Events>(type: Event): Events[Event][];\n}\n\nexport class TypedEventEmitter<Events extends EventsMapping> extends (EventEmitter as unknown as {\n  new <T extends EventsMapping>(): ITypedEventEmitter<T>;\n})<Events> {\n  constructor() {\n    super();\n    this.rawEmitter = this as EventEmitter;\n  }\n}\n","/**\n * Sigma.js Camera Class\n * ======================\n *\n * Class designed to store camera information & used to update it.\n * @module\n */\nimport { ANIMATE_DEFAULTS, AnimateOptions } from \"../utils/animate\";\nimport easings from \"../utils/easings\";\nimport { cancelFrame, requestFrame } from \"../utils\";\nimport { CameraState, TypedEventEmitter } from \"../types\";\n\n/**\n * Defaults.\n */\nconst DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\nexport type CameraEvents = {\n  updated(state: CameraState): void;\n};\n\n/**\n * Camera class\n *\n * @constructor\n */\nexport default class Camera extends TypedEventEmitter<CameraEvents> implements CameraState {\n  x = 0.5;\n  y = 0.5;\n  angle = 0;\n  ratio = 1;\n\n  minRatio: number | null = null;\n  maxRatio: number | null = null;\n\n  private nextFrame: number | null = null;\n  private previousState: CameraState | null = null;\n  private enabled = true;\n\n  animationCallback?: () => void;\n\n  constructor() {\n    super();\n\n    // State\n    this.previousState = this.getState();\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   *\n   * @param state\n   * @return {Camera}\n   */\n  static from(state: CameraState): Camera {\n    const camera = new Camera();\n    return camera.setState(state);\n  }\n\n  /**\n   * Method used to enable the camera.\n   *\n   * @return {Camera}\n   */\n  enable(): this {\n    this.enabled = true;\n    return this;\n  }\n\n  /**\n   * Method used to disable the camera.\n   *\n   * @return {Camera}\n   */\n  disable(): this {\n    this.enabled = false;\n    return this;\n  }\n\n  /**\n   * Method used to retrieve the camera's current state.\n   *\n   * @return {object}\n   */\n  getState(): CameraState {\n    return {\n      x: this.x,\n      y: this.y,\n      angle: this.angle,\n      ratio: this.ratio,\n    };\n  }\n\n  /**\n   * Method used to check whether the camera has the given state.\n   *\n   * @return {object}\n   */\n  hasState(state: CameraState): boolean {\n    return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n  }\n\n  /**\n   * Method used to retrieve the camera's previous state.\n   *\n   * @return {object}\n   */\n  getPreviousState(): CameraState | null {\n    const state = this.previousState;\n\n    if (!state) return null;\n\n    return {\n      x: state.x,\n      y: state.y,\n      angle: state.angle,\n      ratio: state.ratio,\n    };\n  }\n\n  /**\n   * Method used to check minRatio and maxRatio values.\n   *\n   * @param ratio\n   * @return {number}\n   */\n  getBoundedRatio(ratio: number): number {\n    let r = ratio;\n    if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n    if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n    return r;\n  }\n\n  /**\n   * Method used to check various things to return a legit state candidate.\n   *\n   * @param state\n   * @return {object}\n   */\n  validateState(state: Partial<CameraState>): Partial<CameraState> {\n    const validatedState: Partial<CameraState> = {};\n    if (typeof state.x === \"number\") validatedState.x = state.x;\n    if (typeof state.y === \"number\") validatedState.y = state.y;\n    if (typeof state.angle === \"number\") validatedState.angle = state.angle;\n    if (typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n    return validatedState;\n  }\n\n  /**\n   * Method used to check whether the camera is currently being animated.\n   *\n   * @return {boolean}\n   */\n  isAnimated(): boolean {\n    return !!this.nextFrame;\n  }\n\n  /**\n   * Method used to set the camera's state.\n   *\n   * @param  {object} state - New state.\n   * @return {Camera}\n   */\n  setState(state: Partial<CameraState>): this {\n    if (!this.enabled) return this;\n\n    // TODO: update by function\n\n    // Keeping track of last state\n    this.previousState = this.getState();\n\n    const validState = this.validateState(state);\n    if (typeof validState.x === \"number\") this.x = validState.x;\n    if (typeof validState.y === \"number\") this.y = validState.y;\n    if (typeof validState.angle === \"number\") this.angle = validState.angle;\n    if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n\n    // Emitting\n    if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n\n    return this;\n  }\n\n  /**\n   * Method used to update the camera's state using a function.\n   *\n   * @param  {function} updater - Updated function taking current state and\n   *                              returning next state.\n   * @return {Camera}\n   */\n  updateState(updater: (state: CameraState) => Partial<CameraState>): this {\n    this.setState(updater(this.getState()));\n    return this;\n  }\n\n  /**\n   * Method used to animate the camera.\n   *\n   * @param  {object}                    state      - State to reach eventually.\n   * @param  {object}                    opts       - Options:\n   * @param  {number}                      duration - Duration of the animation.\n   * @param  {string | number => number}   easing   - Easing function or name of an existing one\n   * @param  {function}                  callback   - Callback\n   */\n  animate(state: Partial<CameraState>, opts?: Partial<AnimateOptions>, callback?: () => void): void {\n    if (!this.enabled) return;\n\n    const options: AnimateOptions = Object.assign({}, ANIMATE_DEFAULTS, opts);\n    const validState = this.validateState(state);\n\n    const easing: (k: number) => number =\n      typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n    // State\n    const start = Date.now(),\n      initialState = this.getState();\n\n    // Function performing the animation\n    const fn = () => {\n      const t = (Date.now() - start) / options.duration;\n\n      // The animation is over:\n      if (t >= 1) {\n        this.nextFrame = null;\n        this.setState(validState);\n\n        if (this.animationCallback) {\n          this.animationCallback.call(null);\n          this.animationCallback = undefined;\n        }\n\n        return;\n      }\n\n      const coefficient = easing(t);\n\n      const newState: Partial<CameraState> = {};\n\n      if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n      if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n      if (typeof validState.angle === \"number\")\n        newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n      if (typeof validState.ratio === \"number\")\n        newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n\n      this.setState(newState);\n\n      this.nextFrame = requestFrame(fn);\n    };\n\n    if (this.nextFrame) {\n      cancelFrame(this.nextFrame);\n      if (this.animationCallback) this.animationCallback.call(null);\n      this.nextFrame = requestFrame(fn);\n    } else {\n      fn();\n    }\n    this.animationCallback = callback;\n  }\n\n  /**\n   * Method used to zoom the camera.\n   *\n   * @param  {number|object} factorOrOptions - Factor or options.\n   * @return {function}\n   */\n  animatedZoom(factorOrOptions?: number | (Partial<AnimateOptions> & { factor?: number })): void {\n    if (!factorOrOptions) {\n      this.animate({ ratio: this.ratio / DEFAULT_ZOOMING_RATIO });\n    } else {\n      if (typeof factorOrOptions === \"number\") return this.animate({ ratio: this.ratio / factorOrOptions });\n      else\n        this.animate(\n          {\n            ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO),\n          },\n          factorOrOptions,\n        );\n    }\n  }\n\n  /**\n   * Method used to unzoom the camera.\n   *\n   * @param  {number|object} factorOrOptions - Factor or options.\n   */\n  animatedUnzoom(factorOrOptions?: number | (Partial<AnimateOptions> & { factor?: number })): void {\n    if (!factorOrOptions) {\n      this.animate({ ratio: this.ratio * DEFAULT_ZOOMING_RATIO });\n    } else {\n      if (typeof factorOrOptions === \"number\") return this.animate({ ratio: this.ratio * factorOrOptions });\n      else\n        this.animate(\n          {\n            ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO),\n          },\n          factorOrOptions,\n        );\n    }\n  }\n\n  /**\n   * Method used to reset the camera.\n   *\n   * @param  {object} options - Options.\n   */\n  animatedReset(options?: Partial<AnimateOptions>): void {\n    this.animate(\n      {\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0,\n      },\n      options,\n    );\n  }\n\n  /**\n   * Returns a new Camera instance, with the same state as the current camera.\n   *\n   * @return {Camera}\n   */\n  copy(): Camera {\n    return Camera.from(this.getState());\n  }\n}\n","/**\n * Sigma.js Captor Class\n * ======================\n * @module\n */\nimport { Coordinates, MouseCoords, TouchCoords, WheelCoords, TypedEventEmitter, EventsMapping } from \"../../types\";\nimport Sigma from \"../../sigma\";\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nexport function getPosition(e: MouseEvent | Touch, dom: HTMLElement): Coordinates {\n  const bbox = dom.getBoundingClientRect();\n\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top,\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nexport function getMouseCoords(e: MouseEvent, dom: HTMLElement): MouseCoords {\n  const res: MouseCoords = {\n    ...getPosition(e, dom),\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault(): void {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e,\n  };\n\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nexport function getWheelCoords(e: WheelEvent, dom: HTMLElement): WheelCoords {\n  return {\n    ...getMouseCoords(e, dom),\n    delta: getWheelDelta(e),\n  };\n}\n\nconst MAX_TOUCHES = 2;\nexport function getTouchesArray(touches: TouchList): Touch[] {\n  const arr: Touch[] = [];\n  for (let i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e   - A touch event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nexport function getTouchCoords(e: TouchEvent, dom: HTMLElement): TouchCoords {\n  return {\n    touches: getTouchesArray(e.touches).map((touch) => getPosition(touch, dom)),\n    original: e,\n  };\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nexport function getWheelDelta(e: WheelEvent): number {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return (e.deltaY * -3) / 360;\n\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nexport default abstract class Captor<Events extends EventsMapping> extends TypedEventEmitter<Events> {\n  container: HTMLElement;\n  renderer: Sigma;\n\n  constructor(container: HTMLElement, renderer: Sigma) {\n    super();\n\n    // Properties\n    this.container = container;\n    this.renderer = renderer;\n  }\n\n  abstract kill(): void;\n}\n","/**\n * Sigma.js Mouse Captor\n * ======================\n *\n * Sigma's captor dealing with the user's mouse.\n * @module\n */\nimport { CameraState, MouseCoords, WheelCoords } from \"../../types\";\nimport Sigma from \"../../sigma\";\nimport Captor, { getWheelDelta, getMouseCoords, getPosition, getWheelCoords } from \"./captor\";\n\n/**\n * Constants.\n */\nconst DRAG_TIMEOUT = 100;\nconst DRAGGED_EVENTS_TOLERANCE = 3;\nconst MOUSE_INERTIA_DURATION = 200;\nconst MOUSE_INERTIA_RATIO = 3;\nconst MOUSE_ZOOM_DURATION = 250;\nconst ZOOMING_RATIO = 1.7;\nconst DOUBLE_CLICK_TIMEOUT = 300;\nconst DOUBLE_CLICK_ZOOMING_RATIO = 2.2;\nconst DOUBLE_CLICK_ZOOMING_DURATION = 200;\n\n/**\n * Event types.\n */\nexport type MouseCaptorEvents = {\n  click(coordinates: MouseCoords): void;\n  rightClick(coordinates: MouseCoords): void;\n  doubleClick(coordinates: MouseCoords): void;\n  mouseup(coordinates: MouseCoords): void;\n  mousedown(coordinates: MouseCoords): void;\n  mousemove(coordinates: MouseCoords): void;\n  mousemovebody(coordinates: MouseCoords): void;\n  wheel(coordinates: WheelCoords): void;\n};\n\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nexport default class MouseCaptor extends Captor<MouseCaptorEvents> {\n  // State\n  enabled = true;\n  draggedEvents = 0;\n  downStartTime: number | null = null;\n  lastMouseX: number | null = null;\n  lastMouseY: number | null = null;\n  isMouseDown = false;\n  isMoving = false;\n  movingTimeout: number | null = null;\n  startCameraState: CameraState | null = null;\n  clicks = 0;\n  doubleClickTimeout: number | null = null;\n\n  currentWheelDirection: -1 | 0 | 1 = 0;\n  lastWheelTriggerTime?: number;\n\n  constructor(container: HTMLElement, renderer: Sigma) {\n    super(container, renderer);\n\n    // Binding methods\n    this.handleClick = this.handleClick.bind(this);\n    this.handleRightClick = this.handleRightClick.bind(this);\n    this.handleDown = this.handleDown.bind(this);\n    this.handleUp = this.handleUp.bind(this);\n    this.handleMove = this.handleMove.bind(this);\n    this.handleWheel = this.handleWheel.bind(this);\n    this.handleOut = this.handleOut.bind(this);\n\n    // Binding events\n    container.addEventListener(\"click\", this.handleClick, false);\n    container.addEventListener(\"contextmenu\", this.handleRightClick, false);\n    container.addEventListener(\"mousedown\", this.handleDown, false);\n    container.addEventListener(\"wheel\", this.handleWheel, false);\n    container.addEventListener(\"mouseout\", this.handleOut, false);\n\n    document.addEventListener(\"mousemove\", this.handleMove, false);\n    document.addEventListener(\"mouseup\", this.handleUp, false);\n  }\n\n  kill(): void {\n    const container = this.container;\n\n    container.removeEventListener(\"click\", this.handleClick);\n    container.removeEventListener(\"contextmenu\", this.handleRightClick);\n    container.removeEventListener(\"mousedown\", this.handleDown);\n    container.removeEventListener(\"wheel\", this.handleWheel);\n    container.removeEventListener(\"mouseout\", this.handleOut);\n\n    document.removeEventListener(\"mousemove\", this.handleMove);\n    document.removeEventListener(\"mouseup\", this.handleUp);\n  }\n\n  handleClick(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    this.clicks++;\n\n    if (this.clicks === 2) {\n      this.clicks = 0;\n      if (typeof this.doubleClickTimeout === \"number\") {\n        clearTimeout(this.doubleClickTimeout);\n        this.doubleClickTimeout = null;\n      }\n      return this.handleDoubleClick(e);\n    }\n\n    setTimeout(() => {\n      this.clicks = 0;\n      this.doubleClickTimeout = null;\n    }, DOUBLE_CLICK_TIMEOUT);\n\n    // NOTE: this is here to prevent click events on drag\n    if (this.draggedEvents < DRAGGED_EVENTS_TOLERANCE) this.emit(\"click\", getMouseCoords(e, this.container));\n  }\n\n  handleRightClick(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    this.emit(\"rightClick\", getMouseCoords(e, this.container));\n  }\n\n  handleDoubleClick(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    const mouseCoords = getMouseCoords(e, this.container);\n    this.emit(\"doubleClick\", mouseCoords);\n\n    if (mouseCoords.sigmaDefaultPrevented) return;\n\n    // default behavior\n    const camera = this.renderer.getCamera();\n    const newRatio = camera.getBoundedRatio(camera.getState().ratio / DOUBLE_CLICK_ZOOMING_RATIO);\n\n    camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n      easing: \"quadraticInOut\",\n      duration: DOUBLE_CLICK_ZOOMING_DURATION,\n    });\n  }\n\n  handleDown(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    // We only start dragging on left button\n    if (e.button === 0) {\n      this.startCameraState = this.renderer.getCamera().getState();\n\n      const { x, y } = getPosition(e, this.container);\n      this.lastMouseX = x;\n      this.lastMouseY = y;\n\n      this.draggedEvents = 0;\n\n      this.downStartTime = Date.now();\n      this.isMouseDown = true;\n    }\n\n    this.emit(\"mousedown\", getMouseCoords(e, this.container));\n  }\n\n  handleUp(e: MouseEvent): void {\n    if (!this.enabled || !this.isMouseDown) return;\n\n    const camera = this.renderer.getCamera();\n    this.isMouseDown = false;\n\n    if (typeof this.movingTimeout === \"number\") {\n      clearTimeout(this.movingTimeout);\n      this.movingTimeout = null;\n    }\n\n    const { x, y } = getPosition(e, this.container);\n\n    const cameraState = camera.getState(),\n      previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };\n\n    if (this.isMoving) {\n      camera.animate(\n        {\n          x: cameraState.x + MOUSE_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + MOUSE_INERTIA_RATIO * (cameraState.y - previousCameraState.y),\n        },\n        {\n          duration: MOUSE_INERTIA_DURATION,\n          easing: \"quadraticOut\",\n        },\n      );\n    } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n      camera.setState({\n        x: cameraState.x,\n        y: cameraState.y,\n      });\n    }\n\n    this.isMoving = false;\n    setTimeout(() => {\n      const shouldRefresh = this.draggedEvents > 0;\n      this.draggedEvents = 0;\n\n      // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n      // when someone releases camera pan drag after having stopped moving.\n      // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n      // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n      // It could be possible to render instead of scheduling a refresh but for\n      // now it seems good enough.\n      if (shouldRefresh) this.renderer.refresh();\n    }, 0);\n    this.emit(\"mouseup\", getMouseCoords(e, this.container));\n  }\n\n  handleMove(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    const mouseCoords = getMouseCoords(e, this.container);\n\n    // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n    // a drag-and-drop effect that works even when the mouse is out of the\n    // container:\n    this.emit(\"mousemovebody\", mouseCoords);\n\n    // Only trigger the \"mousemove\" event when the mouse is actually hovering\n    // the container, to avoid weirdly hovering nodes and/or edges when the\n    // mouse is not hover the container:\n    if (e.target === this.container) {\n      this.emit(\"mousemove\", mouseCoords);\n    }\n\n    if (mouseCoords.sigmaDefaultPrevented) return;\n\n    // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n    // stage while the mouse is not hover the container:\n    if (this.isMouseDown) {\n      this.isMoving = true;\n      this.draggedEvents++;\n\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n      }\n\n      this.movingTimeout = window.setTimeout(() => {\n        this.movingTimeout = null;\n        this.isMoving = false;\n      }, DRAG_TIMEOUT);\n\n      const camera = this.renderer.getCamera();\n\n      const { x: eX, y: eY } = getPosition(e, this.container);\n\n      const lastMouse = this.renderer.viewportToFramedGraph({\n        x: this.lastMouseX as number,\n        y: this.lastMouseY as number,\n      });\n\n      const mouse = this.renderer.viewportToFramedGraph({ x: eX, y: eY });\n\n      const offsetX = lastMouse.x - mouse.x,\n        offsetY = lastMouse.y - mouse.y;\n\n      const cameraState = camera.getState();\n\n      const x = cameraState.x + offsetX,\n        y = cameraState.y + offsetY;\n\n      camera.setState({ x, y });\n\n      this.lastMouseX = eX;\n      this.lastMouseY = eY;\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n\n  handleWheel(e: WheelEvent): void {\n    if (!this.enabled) return;\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    const delta = getWheelDelta(e);\n\n    if (!delta) return;\n\n    const wheelCoords = getWheelCoords(e, this.container);\n    this.emit(\"wheel\", wheelCoords);\n\n    if (wheelCoords.sigmaDefaultPrevented) return;\n\n    // Default behavior\n    const ratioDiff = delta > 0 ? 1 / ZOOMING_RATIO : ZOOMING_RATIO;\n    const camera = this.renderer.getCamera();\n    const newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);\n    const wheelDirection = delta > 0 ? 1 : -1;\n    const now = Date.now();\n\n    // Cancel events that are too close too each other and in the same direction:\n    if (\n      this.currentWheelDirection === wheelDirection &&\n      this.lastWheelTriggerTime &&\n      now - this.lastWheelTriggerTime < MOUSE_ZOOM_DURATION / 5\n    ) {\n      return;\n    }\n\n    camera.animate(\n      this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio),\n      {\n        easing: \"quadraticOut\",\n        duration: MOUSE_ZOOM_DURATION,\n      },\n      () => {\n        this.currentWheelDirection = 0;\n      },\n    );\n\n    this.currentWheelDirection = wheelDirection;\n    this.lastWheelTriggerTime = now;\n  }\n\n  handleOut(): void {\n    // TODO: dispatch event\n  }\n}\n","/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\nimport Graph from \"graphology-types\";\n\nimport { Dimensions, Coordinates } from \"../types\";\n\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nclass LabelCandidate {\n  key: string;\n  size: number;\n\n  constructor(key: string, size: number) {\n    this.key = key;\n    this.size = size;\n  }\n\n  static compare(first: LabelCandidate, second: LabelCandidate): number {\n    // First we compare by size\n    if (first.size > second.size) return -1;\n    if (first.size < second.size) return 1;\n\n    // Then since no two nodes can have the same key, we use it to\n    // deterministically tie-break by key\n    if (first.key > second.key) return 1;\n\n    // NOTE: this comparator cannot return 0\n    return -1;\n  }\n}\n\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nexport class LabelGrid {\n  width = 0;\n  height = 0;\n  cellSize = 0;\n  columns = 0;\n  rows = 0;\n  cells: Record<number, Array<LabelCandidate>> = {};\n\n  resizeAndClear(dimensions: Dimensions, cellSize: number): void {\n    this.width = dimensions.width;\n    this.height = dimensions.height;\n\n    this.cellSize = cellSize;\n\n    this.columns = Math.ceil(dimensions.width / cellSize);\n    this.rows = Math.ceil(dimensions.height / cellSize);\n\n    this.cells = {};\n  }\n\n  private getIndex(pos: Coordinates): number {\n    const xIndex = Math.floor(pos.x / this.cellSize);\n    const yIndex = Math.floor(pos.y / this.cellSize);\n\n    return yIndex * this.columns + xIndex;\n  }\n\n  add(key: string, size: number, pos: Coordinates): void {\n    const candidate = new LabelCandidate(key, size);\n\n    const index = this.getIndex(pos);\n    let cell = this.cells[index];\n\n    if (!cell) {\n      cell = [];\n      this.cells[index] = cell;\n    }\n\n    cell.push(candidate);\n  }\n\n  organize(): void {\n    for (const k in this.cells) {\n      const cell = this.cells[k];\n      cell.sort(LabelCandidate.compare);\n    }\n  }\n\n  getLabelsToDisplay(ratio: number, density: number): Array<string> {\n    // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n    // TODO: adjust threshold lower, but increase cells a bit?\n    // TODO: hunt for geom issue in disguise\n    // TODO: memoize while ratio does not move. method to force recompute\n    const cellArea = this.cellSize * this.cellSize;\n    const scaledCellArea = cellArea / ratio / ratio;\n    const scaledDensity = (scaledCellArea * density) / cellArea;\n\n    const labelsToDisplayPerCell = Math.ceil(scaledDensity);\n\n    const labels: string[] = [];\n\n    for (const k in this.cells) {\n      const cell = this.cells[k];\n\n      for (let i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n        labels.push(cell[i].key);\n      }\n    }\n\n    return labels;\n  }\n}\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nexport function edgeLabelsToDisplayFromNodes(params: {\n  displayedNodeLabels: Set<string>;\n  highlightedNodes: Set<string>;\n  graph: Graph;\n  hoveredNode: string | null;\n}): Array<string> {\n  const { graph, hoveredNode, highlightedNodes, displayedNodeLabels } = params;\n\n  const worthyEdges: Array<string> = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge((edge, _, source, target) => {\n    if (\n      source === hoveredNode ||\n      target === hoveredNode ||\n      highlightedNodes.has(source) ||\n      highlightedNodes.has(target) ||\n      (displayedNodeLabels.has(source) && displayedNodeLabels.has(target))\n    ) {\n      worthyEdges.push(edge);\n    }\n  });\n\n  return worthyEdges;\n}\n","/**\n * Sigma.js Shader Utils\n * ======================\n *\n * Code used to load sigma's shaders.\n * @module\n */\n\n/**\n * Function used to load a shader.\n */\nfunction loadShader(type: string, gl: WebGLRenderingContext, source: string): WebGLShader {\n  const glType = type === \"VERTEX\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;\n\n  // Creating the shader\n  const shader = gl.createShader(glType);\n  if (shader === null) {\n    throw new Error(`loadShader: error while creating the shader`);\n  }\n\n  // Loading source\n  gl.shaderSource(shader, source);\n\n  // Compiling the shader\n  gl.compileShader(shader);\n\n  // Retrieving compilation status\n  const successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  // Throwing if something went awry\n  if (!successfullyCompiled) {\n    const infoLog = gl.getShaderInfoLog(shader);\n\n    gl.deleteShader(shader);\n    throw new Error(`loadShader: error while compiling the shader:\\n${infoLog}\\n${source}`);\n  }\n\n  return shader;\n}\n\nexport function loadVertexShader(gl: WebGLRenderingContext, source: string): WebGLShader {\n  return loadShader(\"VERTEX\", gl, source);\n}\nexport function loadFragmentShader(gl: WebGLRenderingContext, source: string): WebGLShader {\n  return loadShader(\"FRAGMENT\", gl, source);\n}\n\n/**\n * Function used to load a program.\n */\nexport function loadProgram(gl: WebGLRenderingContext, shaders: Array<WebGLShader>): WebGLProgram {\n  const program = gl.createProgram();\n  if (program === null) {\n    throw new Error(\"loadProgram: error while creating the program.\");\n  }\n\n  let i, l;\n\n  // Attaching the shaders\n  for (i = 0, l = shaders.length; i < l; i++) gl.attachShader(program, shaders[i]);\n\n  gl.linkProgram(program);\n\n  // Checking status\n  const successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (!successfullyLinked) {\n    gl.deleteProgram(program);\n    throw new Error(\"loadProgram: error while linking the program.\");\n  }\n\n  return program;\n}\n","/**\n * Sigma.js WebGL Renderer Program\n * ================================\n *\n * Class representing a single WebGL program used by sigma's WebGL renderer.\n * @module\n */\nimport type Sigma from \"../sigma\";\nimport type { RenderParams } from \"../types\";\nimport { loadVertexShader, loadFragmentShader, loadProgram } from \"./utils\";\n\nconst PICKING_PREFIX = `#define PICKING_MODE\\n`;\n\nconst SIZE_FACTOR_PER_ATTRIBUTE_TYPE: Record<number, number> = {\n  [WebGL2RenderingContext.BOOL]: 1,\n  [WebGL2RenderingContext.BYTE]: 1,\n  [WebGL2RenderingContext.UNSIGNED_BYTE]: 1,\n  [WebGL2RenderingContext.SHORT]: 2,\n  [WebGL2RenderingContext.UNSIGNED_SHORT]: 2,\n  [WebGL2RenderingContext.INT]: 4,\n  [WebGL2RenderingContext.UNSIGNED_INT]: 4,\n  [WebGL2RenderingContext.FLOAT]: 4,\n};\n\nfunction getAttributeItemsCount(attr: ProgramAttributeSpecification): number {\n  return attr.normalized ? 1 : attr.size;\n}\nfunction getAttributesItemsCount(attrs: ProgramAttributeSpecification[]): number {\n  let res = 0;\n  attrs.forEach((attr) => (res += getAttributeItemsCount(attr)));\n  return res;\n}\n\nexport interface ProgramInfo<Uniform extends string = string> {\n  name: string;\n  isPicking: boolean;\n  program: WebGLProgram;\n  gl: WebGLRenderingContext | WebGL2RenderingContext;\n  frameBuffer: WebGLFramebuffer | null;\n  buffer: WebGLBuffer;\n  constantBuffer: WebGLBuffer;\n  uniformLocations: Record<Uniform, WebGLUniformLocation>;\n  attributeLocations: Record<string, GLint>;\n}\n\nexport interface ProgramAttributeSpecification {\n  name: string;\n  size: number;\n  type: number;\n  normalized?: boolean;\n}\n\nexport interface ProgramDefinition<Uniform extends string = string> {\n  VERTICES: number;\n  VERTEX_SHADER_SOURCE: string;\n  FRAGMENT_SHADER_SOURCE: string;\n  UNIFORMS: ReadonlyArray<Uniform>;\n  ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  METHOD: GLenum;\n}\n\nexport interface InstancedProgramDefinition<Uniform extends string = string> extends ProgramDefinition<Uniform> {\n  CONSTANT_ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  CONSTANT_DATA: number[][];\n}\n\nexport abstract class AbstractProgram {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  constructor(_gl: WebGLRenderingContext, _pickGl: WebGLRenderingContext, _renderer: Sigma) {}\n  abstract reallocate(capacity: number): void;\n  abstract render(params: RenderParams): void;\n}\n\nexport abstract class Program<Uniform extends string = string> implements AbstractProgram, InstancedProgramDefinition {\n  VERTICES: number;\n  VERTEX_SHADER_SOURCE: string;\n  FRAGMENT_SHADER_SOURCE: string;\n  UNIFORMS: ReadonlyArray<Uniform>;\n  ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  METHOD: GLenum;\n  CONSTANT_ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  CONSTANT_DATA: number[][];\n\n  ATTRIBUTES_ITEMS_COUNT: number;\n  STRIDE: number;\n\n  renderer: Sigma;\n  array: Float32Array = new Float32Array();\n  constantArray: Float32Array = new Float32Array();\n  capacity = 0;\n  verticesCount = 0;\n\n  normalProgram: ProgramInfo;\n  pickProgram: ProgramInfo | null;\n\n  isInstanced: boolean;\n\n  abstract getDefinition(): ProgramDefinition<Uniform> | InstancedProgramDefinition<Uniform>;\n\n  constructor(\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    pickingBuffer: WebGLFramebuffer | null,\n    renderer: Sigma,\n  ) {\n    // Reading and caching program definition\n    const def = this.getDefinition();\n    this.VERTICES = def.VERTICES;\n    this.VERTEX_SHADER_SOURCE = def.VERTEX_SHADER_SOURCE;\n    this.FRAGMENT_SHADER_SOURCE = def.FRAGMENT_SHADER_SOURCE;\n    this.UNIFORMS = def.UNIFORMS;\n    this.ATTRIBUTES = def.ATTRIBUTES;\n    this.METHOD = def.METHOD;\n    this.CONSTANT_ATTRIBUTES = \"CONSTANT_ATTRIBUTES\" in def ? def.CONSTANT_ATTRIBUTES : [];\n    this.CONSTANT_DATA = \"CONSTANT_DATA\" in def ? def.CONSTANT_DATA : [];\n\n    this.isInstanced = \"CONSTANT_ATTRIBUTES\" in def;\n\n    // Computing stride\n    this.ATTRIBUTES_ITEMS_COUNT = getAttributesItemsCount(this.ATTRIBUTES);\n    this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT;\n\n    // Members\n    this.renderer = renderer;\n    this.normalProgram = this.getProgramInfo(\"normal\", gl, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);\n    this.pickProgram = pickingBuffer\n      ? this.getProgramInfo(\n          \"pick\",\n          gl,\n          PICKING_PREFIX + def.VERTEX_SHADER_SOURCE,\n          PICKING_PREFIX + def.FRAGMENT_SHADER_SOURCE,\n          pickingBuffer,\n        )\n      : null;\n\n    // For instanced programs:\n    if (this.isInstanced) {\n      const constantAttributesItemsCount = getAttributesItemsCount(this.CONSTANT_ATTRIBUTES);\n\n      if (this.CONSTANT_DATA.length !== this.VERTICES)\n        throw new Error(\n          `Program: error while getting constant data (expected ${this.VERTICES} items, received ${this.CONSTANT_DATA.length} instead)`,\n        );\n\n      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * constantAttributesItemsCount);\n      for (let i = 0; i < this.CONSTANT_DATA.length; i++) {\n        const vector = this.CONSTANT_DATA[i];\n\n        if (vector.length !== constantAttributesItemsCount)\n          throw new Error(\n            `Program: error while getting constant data (one vector has ${vector.length} items instead of ${constantAttributesItemsCount})`,\n          );\n\n        for (let j = 0; j < vector.length; j++) this.constantArray[i * constantAttributesItemsCount + j] = vector[j];\n      }\n\n      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;\n    }\n  }\n\n  protected getProgramInfo(\n    name: \"normal\" | \"pick\",\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    vertexShaderSource: string,\n    fragmentShaderSource: string,\n    frameBuffer: WebGLFramebuffer | null,\n  ): ProgramInfo {\n    const def = this.getDefinition();\n\n    // WebGL buffers\n    const buffer = gl.createBuffer();\n    if (buffer === null) throw new Error(\"Program: error while creating the WebGL buffer.\");\n\n    // Shaders and program\n    const vertexShader = loadVertexShader(gl, vertexShaderSource);\n    const fragmentShader = loadFragmentShader(gl, fragmentShaderSource);\n    const program = loadProgram(gl, [vertexShader, fragmentShader]);\n\n    // Initializing locations\n    const uniformLocations = {} as ProgramInfo[\"uniformLocations\"];\n    def.UNIFORMS.forEach((uniformName) => {\n      const location = gl.getUniformLocation(program, uniformName);\n      if (location) uniformLocations[uniformName] = location;\n    });\n\n    const attributeLocations = {} as ProgramInfo[\"attributeLocations\"];\n    def.ATTRIBUTES.forEach((attr) => {\n      attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n    });\n\n    // For instanced programs:\n    let constantBuffer;\n    if (\"CONSTANT_ATTRIBUTES\" in def) {\n      def.CONSTANT_ATTRIBUTES.forEach((attr) => {\n        attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n      });\n\n      constantBuffer = gl.createBuffer();\n      if (constantBuffer === null) throw new Error(\"Program: error while creating the WebGL constant buffer.\");\n    }\n\n    return {\n      name,\n      program,\n      gl,\n      frameBuffer,\n      buffer,\n      constantBuffer: constantBuffer || ({} as WebGLBuffer),\n      uniformLocations,\n      attributeLocations,\n      isPicking: name === \"pick\",\n    };\n  }\n\n  protected bindProgram(program: ProgramInfo): void {\n    let offset = 0;\n\n    const { gl, buffer } = program;\n    if (!this.isInstanced) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n      offset = 0;\n      this.ATTRIBUTES.forEach((attr) => (offset += this.bindAttribute(attr, program, offset)));\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    } else {\n      // Handle constant data (things that remain unchanged for all items):\n      gl.bindBuffer(gl.ARRAY_BUFFER, program.constantBuffer);\n\n      offset = 0;\n      this.CONSTANT_ATTRIBUTES.forEach((attr) => (offset += this.bindAttribute(attr, program, offset, false)));\n      gl.bufferData(gl.ARRAY_BUFFER, this.constantArray, gl.STATIC_DRAW);\n\n      // Handle \"instance specific\" data (things that vary for each item):\n      gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);\n\n      offset = 0;\n      this.ATTRIBUTES.forEach((attr) => (offset += this.bindAttribute(attr, program, offset, true)));\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  }\n\n  protected unbindProgram(program: ProgramInfo): void {\n    if (!this.isInstanced) {\n      this.ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program));\n    } else {\n      this.CONSTANT_ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program, false));\n      this.ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program, true));\n    }\n  }\n\n  protected bindAttribute(\n    attr: ProgramAttributeSpecification,\n    program: ProgramInfo,\n    offset: number,\n    setDivisor?: boolean,\n  ): number {\n    const sizeFactor = SIZE_FACTOR_PER_ATTRIBUTE_TYPE[attr.type];\n    if (typeof sizeFactor !== \"number\") throw new Error(`Program.bind: yet unsupported attribute type \"${attr.type}\"`);\n\n    const location = program.attributeLocations[attr.name];\n    const gl = program.gl;\n\n    if (location !== -1) {\n      gl.enableVertexAttribArray(location);\n\n      const stride = !this.isInstanced\n        ? this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT\n        : (setDivisor ? this.ATTRIBUTES_ITEMS_COUNT : getAttributesItemsCount(this.CONSTANT_ATTRIBUTES)) *\n          Float32Array.BYTES_PER_ELEMENT;\n\n      gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized || false, stride, offset);\n\n      if (this.isInstanced && setDivisor) {\n        if (gl instanceof WebGL2RenderingContext) {\n          gl.vertexAttribDivisor(location, 1);\n        } else {\n          const ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n          if (ext) ext.vertexAttribDivisorANGLE(location, 1);\n        }\n      }\n    }\n\n    return attr.size * sizeFactor;\n  }\n\n  protected unbindAttribute(attr: ProgramAttributeSpecification, program: ProgramInfo, unsetDivisor?: boolean) {\n    const location = program.attributeLocations[attr.name];\n    const gl = program.gl;\n\n    if (location !== -1) {\n      gl.disableVertexAttribArray(location);\n\n      if (this.isInstanced && unsetDivisor) {\n        if (gl instanceof WebGL2RenderingContext) {\n          gl.vertexAttribDivisor(location, 0);\n        } else {\n          const ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n          if (ext) ext.vertexAttribDivisorANGLE(location, 0);\n        }\n      }\n    }\n  }\n\n  reallocate(capacity: number): void {\n    // If desired capacity has not changed we do nothing\n    // NOTE: it's possible here to implement more subtle reallocation schemes\n    // when the number of rendered items increase or decrease\n    if (capacity === this.capacity) return;\n\n    this.capacity = capacity;\n    this.verticesCount = this.VERTICES * capacity;\n    this.array = new Float32Array(\n      !this.isInstanced\n        ? this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT\n        : this.capacity * this.ATTRIBUTES_ITEMS_COUNT,\n    );\n  }\n\n  hasNothingToRender(): boolean {\n    return this.verticesCount === 0;\n  }\n\n  abstract setUniforms(params: RenderParams, programInfo: ProgramInfo): void;\n\n  protected renderProgram(params: RenderParams, programInfo: ProgramInfo): void {\n    const { gl, program } = programInfo;\n\n    // With the current fix for #1397, the alpha blending is enabled for the\n    // picking layer:\n    gl.enable(gl.BLEND);\n\n    // Original code:\n    // if (!isPicking) gl.enable(gl.BLEND);\n    // else gl.disable(gl.BLEND);\n\n    gl.useProgram(program);\n    this.setUniforms(params, programInfo);\n    this.drawWebGL(this.METHOD, programInfo);\n  }\n\n  render(params: RenderParams): void {\n    if (this.hasNothingToRender()) return;\n\n    if (this.pickProgram) {\n      this.pickProgram.gl.viewport(\n        0,\n        0,\n        (params.width * params.pixelRatio) / params.downSizingRatio,\n        (params.height * params.pixelRatio) / params.downSizingRatio,\n      );\n      this.bindProgram(this.pickProgram);\n      this.renderProgram({ ...params, pixelRatio: params.pixelRatio / params.downSizingRatio }, this.pickProgram);\n      this.unbindProgram(this.pickProgram);\n    }\n\n    this.normalProgram.gl.viewport(0, 0, params.width * params.pixelRatio, params.height * params.pixelRatio);\n    this.bindProgram(this.normalProgram);\n    this.renderProgram(params, this.normalProgram);\n    this.unbindProgram(this.normalProgram);\n  }\n\n  drawWebGL(method: GLenum, { gl, frameBuffer }: ProgramInfo): void {\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n\n    if (!this.isInstanced) {\n      gl.drawArrays(method, 0, this.verticesCount);\n    } else {\n      if (gl instanceof WebGL2RenderingContext) {\n        gl.drawArraysInstanced(method, 0, this.VERTICES, this.capacity);\n      } else {\n        const ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n        if (ext) ext.drawArraysInstancedANGLE(method, 0, this.VERTICES, this.capacity);\n      }\n    }\n  }\n}\n","/**\n * Sigma.js WebGL Abstract Node Program\n * =====================================\n *\n * @module\n */\nimport Sigma from \"../sigma\";\nimport { AbstractProgram, Program } from \"./program\";\nimport { NodeDisplayData, NonEmptyArray, RenderParams } from \"../types\";\nimport { NodeLabelDrawingFunction } from \"./node-labels\";\nimport { NodeHoverDrawingFunction } from \"./node-hover\";\nimport { indexToColor } from \"../utils\";\n\nexport abstract class AbstractNodeProgram extends AbstractProgram {\n  static drawLabel: NodeLabelDrawingFunction | undefined;\n  static drawHover: NodeHoverDrawingFunction | undefined;\n  abstract process(nodeIndex: number, offset: number, data: NodeDisplayData): void;\n}\n\nexport abstract class NodeProgram<Uniform extends string = string>\n  extends Program<Uniform>\n  implements AbstractNodeProgram\n{\n  static drawLabel: NodeLabelDrawingFunction | undefined = undefined;\n  static drawHover: NodeHoverDrawingFunction | undefined = undefined;\n\n  process(nodeIndex: number, offset: number, data: NodeDisplayData): void {\n    let i = offset * this.STRIDE;\n    // NOTE: dealing with hidden items automatically\n    if (data.hidden) {\n      for (let l = i + this.STRIDE; i < l; i++) {\n        this.array[i] = 0;\n      }\n      return;\n    }\n\n    return this.processVisibleItem(indexToColor(nodeIndex), i, data);\n  }\n\n  abstract processVisibleItem(nodeIndex: number, i: number, data: NodeDisplayData): void;\n}\n\nclass NodeImageClass implements AbstractNodeProgram {\n  static drawLabel: NodeLabelDrawingFunction | undefined = undefined;\n  static drawHover: NodeHoverDrawingFunction | undefined = undefined;\n\n  constructor(_gl: WebGLRenderingContext, _pickingBuffer: WebGLFramebuffer | null, _renderer: Sigma) {\n    return this;\n  }\n  reallocate(_capacity: number): void {\n    return undefined;\n  }\n  process(_nodeIndex: number, _offset: number, _data: NodeDisplayData): void {\n    return undefined;\n  }\n  render(_params: RenderParams): void {\n    return undefined;\n  }\n}\nexport type NodeProgramType = typeof NodeImageClass;\n\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional node \"draw label\" function.\n * @param  {function} drawHover - An optional node \"draw hover\" function.\n * @return {function}\n */\nexport function createNodeCompoundProgram(\n  programClasses: NonEmptyArray<NodeProgramType>,\n  drawLabel?: NodeLabelDrawingFunction,\n  drawHover?: NodeLabelDrawingFunction,\n): NodeProgramType {\n  return class NodeCompoundProgram implements AbstractNodeProgram {\n    static drawLabel = drawLabel;\n    static drawHover = drawHover;\n\n    programs: NonEmptyArray<AbstractNodeProgram>;\n\n    constructor(gl: WebGLRenderingContext, pickingBuffer: WebGLFramebuffer | null, renderer: Sigma) {\n      this.programs = programClasses.map((Program) => {\n        return new Program(gl, pickingBuffer, renderer);\n      }) as unknown as NonEmptyArray<AbstractNodeProgram>;\n    }\n\n    reallocate(capacity: number): void {\n      this.programs.forEach((program) => program.reallocate(capacity));\n    }\n\n    process(nodeIndex: number, offset: number, data: NodeDisplayData): void {\n      this.programs.forEach((program) => program.process(nodeIndex, offset, data));\n    }\n\n    render(params: RenderParams): void {\n      this.programs.forEach((program) => program.render(params));\n    }\n  };\n}\n","attribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_position;\nattribute float a_size;\n\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\n\n  v_border = (0.5 / a_size) * u_sizeRatio;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n","precision mediump float;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float radius = 0.5;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\n  float dist = radius - length(m);\n\n  // No antialiasing for picking mode:\n  #ifdef PICKING_MODE\n  if (dist > v_border)\n    gl_FragColor = v_color;\n  else\n    gl_FragColor = transparent;\n\n  #else\n  float t = 0.0;\n  if (dist > v_border)\n    t = 1.0;\n  else if (dist > 0.0)\n    t = dist / v_border;\n\n  gl_FragColor = mix(transparent, v_color, t);\n  #endif\n}\n","/**\n * Sigma.js WebGL Renderer Node Program\n * =====================================\n *\n * Simple program rendering nodes using GL_POINTS. This is faster than the\n * three triangle option but has some quirks and is not supported equally by\n * every GPU.\n * @module\n */\nimport { NodeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { NodeProgram } from \"../../node\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport { ProgramInfo } from \"../../program\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\"u_sizeRatio\", \"u_pixelRatio\", \"u_matrix\"] as const;\n\nexport default class NodePointProgram extends NodeProgram<(typeof UNIFORMS)[number]> {\n  getDefinition() {\n    return {\n      VERTICES: 1,\n      VERTEX_SHADER_SOURCE,\n      FRAGMENT_SHADER_SOURCE,\n      METHOD: WebGLRenderingContext.POINTS,\n      UNIFORMS,\n      ATTRIBUTES: [\n        { name: \"a_position\", size: 2, type: FLOAT },\n        { name: \"a_size\", size: 1, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n      ],\n    };\n  }\n\n  processVisibleItem(nodeIndex: number, startIndex: number, data: NodeDisplayData) {\n    const array = this.array;\n\n    array[startIndex++] = data.x;\n    array[startIndex++] = data.y;\n    array[startIndex++] = data.size;\n    array[startIndex++] = floatColor(data.color);\n    array[startIndex++] = nodeIndex;\n  }\n\n  setUniforms({ sizeRatio, pixelRatio, matrix }: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n    const { u_sizeRatio, u_pixelRatio, u_matrix } = uniformLocations;\n\n    gl.uniform1f(u_pixelRatio, pixelRatio);\n    gl.uniform1f(u_sizeRatio, sizeRatio);\n    gl.uniformMatrix3fv(u_matrix, false, matrix);\n  }\n}\n","/**\n * Sigma.js WebGL Abstract Edge Program\n * =====================================\n *\n * @module\n */\nimport Sigma from \"../sigma\";\nimport { AbstractProgram, Program } from \"./program\";\nimport { NodeDisplayData, EdgeDisplayData, RenderParams } from \"../types\";\nimport { EdgeLabelDrawingFunction } from \"./edge-labels\";\nimport { indexToColor } from \"../utils\";\n\nexport abstract class AbstractEdgeProgram extends AbstractProgram {\n  static drawLabel: EdgeLabelDrawingFunction | undefined;\n\n  abstract process(\n    edgeIndex: number,\n    offset: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ): void;\n}\n\nexport abstract class EdgeProgram<Uniform extends string = string>\n  extends Program<Uniform>\n  implements AbstractEdgeProgram\n{\n  static drawLabel: EdgeLabelDrawingFunction | undefined = undefined;\n\n  process(\n    edgeIndex: number,\n    offset: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ): void {\n    let i = offset * this.STRIDE;\n    // NOTE: dealing with hidden items automatically\n    if (data.hidden || sourceData.hidden || targetData.hidden) {\n      for (let l = i + this.STRIDE; i < l; i++) {\n        this.array[i] = 0;\n      }\n      return;\n    }\n\n    return this.processVisibleItem(indexToColor(edgeIndex), i, sourceData, targetData, data);\n  }\n\n  abstract processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ): void;\n}\n\nclass EdgeImageClass implements AbstractEdgeProgram {\n  static drawLabel: EdgeLabelDrawingFunction | undefined = undefined;\n\n  constructor(_gl: WebGLRenderingContext, _pickingBuffer: WebGLFramebuffer | null, _renderer: Sigma) {\n    return this;\n  }\n  reallocate(_capacity: number): void {\n    return undefined;\n  }\n  process(\n    _edgeIndex: number,\n    _offset: number,\n    _sourceData: NodeDisplayData,\n    _targetData: NodeDisplayData,\n    _data: EdgeDisplayData,\n  ): void {\n    return undefined;\n  }\n  render(_params: RenderParams): void {\n    return undefined;\n  }\n}\nexport type EdgeProgramType = typeof EdgeImageClass;\n\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional edge \"draw label\" function.\n * @return {function}\n */\nexport function createEdgeCompoundProgram(\n  programClasses: Array<EdgeProgramType>,\n  drawLabel?: EdgeLabelDrawingFunction,\n): EdgeProgramType {\n  return class EdgeCompoundProgram implements AbstractEdgeProgram {\n    static drawLabel = drawLabel;\n\n    programs: Array<AbstractEdgeProgram>;\n\n    constructor(gl: WebGLRenderingContext, pickingBuffer: WebGLFramebuffer | null, renderer: Sigma) {\n      this.programs = programClasses.map((Program) => {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n\n    reallocate(capacity: number): void {\n      this.programs.forEach((program) => program.reallocate(capacity));\n    }\n\n    process(\n      edgeIndex: number,\n      offset: number,\n      sourceData: NodeDisplayData,\n      targetData: NodeDisplayData,\n      data: EdgeDisplayData,\n    ): void {\n      this.programs.forEach((program) => program.process(edgeIndex, offset, sourceData, targetData, data));\n    }\n\n    render(params: RenderParams): void {\n      this.programs.forEach((program) => program.render(params));\n    }\n  };\n}\n","attribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_zoomRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n\n  // We require edges to be at least `minThickness` pixels thick *on screen*\n  // (so we need to compensate the size ratio):\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\n  // referential (in a ([0, 1], [0, 1]) space), using our \"magic\" correction\n  // ratio:\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\n\n  // For the fragment shader though, we need a thickness that takes the \"magic\"\n  // correction ratio into account (as in webGLThickness), but so that the\n  // antialiasing effect does not depend on the zoom level. So here's yet\n  // another thickness version:\n  v_thickness = webGLThickness / u_zoomRatio;\n\n  v_normal = unitNormal;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n","precision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float feather = 0.001;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  // We only handle antialiasing for normal mode:\n  #ifdef PICKING_MODE\n  gl_FragColor = v_color;\n  #else\n  float dist = length(v_normal) * v_thickness;\n\n  float t = smoothstep(\n    v_thickness - feather,\n    v_thickness,\n    dist\n  );\n\n  gl_FragColor = mix(v_color, transparent, t);\n  #endif\n}\n","/**\n * Sigma.js WebGL Renderer Edge Program\n * =====================================\n *\n * Program rendering edges as thick lines using four points translated\n * orthogonally from the source & target's centers by half thickness.\n *\n * Rendering two triangles by using only four points is made possible through\n * the use of indices.\n *\n * This method should be faster than the 6 points / 2 triangles approach and\n * should handle thickness better than with gl.LINES.\n *\n * This version of the shader balances geometry computation evenly between\n * the CPU & GPU (normals are computed on the CPU side).\n * @module\n */\nimport { NodeDisplayData, EdgeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { EdgeProgram } from \"../../edge\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport { ProgramInfo } from \"../../program\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\"] as const;\n\nexport default class EdgeRectangleProgram extends EdgeProgram<(typeof UNIFORMS)[number]> {\n  getDefinition() {\n    return {\n      VERTICES: 6,\n      VERTEX_SHADER_SOURCE,\n      FRAGMENT_SHADER_SOURCE,\n      METHOD: WebGLRenderingContext.TRIANGLES,\n      UNIFORMS,\n      ATTRIBUTES: [\n        { name: \"a_positionStart\", size: 2, type: FLOAT },\n        { name: \"a_positionEnd\", size: 2, type: FLOAT },\n        { name: \"a_normal\", size: 2, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n      ],\n      CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 2, then position will be a_positionEnd\n        { name: \"a_positionCoef\", size: 1, type: FLOAT },\n        { name: \"a_normalCoef\", size: 1, type: FLOAT },\n      ],\n      CONSTANT_DATA: [\n        [0, 1],\n        [0, -1],\n        [1, 1],\n        [1, 1],\n        [0, -1],\n        [1, -1],\n      ],\n    };\n  }\n\n  processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ) {\n    const thickness = data.size || 1;\n    const x1 = sourceData.x;\n    const y1 = sourceData.y;\n    const x2 = targetData.x;\n    const y2 = targetData.y;\n    const color = floatColor(data.color);\n\n    // Computing normals\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n\n    let len = dx * dx + dy * dy;\n    let n1 = 0;\n    let n2 = 0;\n\n    if (len) {\n      len = 1 / Math.sqrt(len);\n\n      n1 = -dy * len * thickness;\n      n2 = dx * len * thickness;\n    }\n\n    const array = this.array;\n\n    array[startIndex++] = x1;\n    array[startIndex++] = y1;\n    array[startIndex++] = x2;\n    array[startIndex++] = y2;\n    array[startIndex++] = n1;\n    array[startIndex++] = n2;\n    array[startIndex++] = color;\n    array[startIndex++] = edgeIndex;\n  }\n\n  setUniforms(params: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n    const { u_matrix, u_zoomRatio, u_correctionRatio, u_sizeRatio } = uniformLocations;\n\n    gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    gl.uniform1f(u_zoomRatio, params.zoomRatio);\n    gl.uniform1f(u_sizeRatio, params.sizeRatio);\n    gl.uniform1f(u_correctionRatio, params.correctionRatio);\n  }\n}\n","attribute vec2 a_position;\nattribute vec2 a_normal;\nattribute float a_radius;\nattribute vec3 a_barycentric;\n\n#ifdef PICKING_MODE\nattribute vec4 a_id;\n#else\nattribute vec4 a_color;\n#endif\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\nconst float arrowHeadWidthLengthRatio = 0.66;\nconst float arrowHeadLengthThicknessRatio = 2.5;\n\nvoid main() {\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl and\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\n  // happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\n  float webGLArrowHeadHalfWidth = webGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;\n\n  float da = a_barycentric.x;\n  float db = a_barycentric.y;\n  float dc = a_barycentric.z;\n\n  vec2 delta = vec2(\n      da * (webGLNodeRadius * unitNormal.y)\n    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadHalfWidth * unitNormal.x)\n    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadHalfWidth * unitNormal.x),\n\n      da * (-webGLNodeRadius * unitNormal.x)\n    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadHalfWidth * unitNormal.y)\n    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadHalfWidth * unitNormal.y)\n  );\n\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\n\n  gl_Position = vec4(position, 0, 1);\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n","precision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n","/**\n * Sigma.js WebGL Renderer Arrow Program\n * ======================================\n *\n * Program rendering direction arrows as a simple triangle.\n * @module\n */\nimport { NodeDisplayData, EdgeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { EdgeProgram } from \"../../edge\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport { ProgramInfo } from \"../../program\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\"] as const;\n\nexport default class EdgeArrowHeadProgram extends EdgeProgram<(typeof UNIFORMS)[number]> {\n  getDefinition() {\n    return {\n      VERTICES: 3,\n      VERTEX_SHADER_SOURCE,\n      FRAGMENT_SHADER_SOURCE,\n      METHOD: WebGLRenderingContext.TRIANGLES,\n      UNIFORMS,\n      ATTRIBUTES: [\n        { name: \"a_position\", size: 2, type: FLOAT },\n        { name: \"a_normal\", size: 2, type: FLOAT },\n        { name: \"a_radius\", size: 1, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n      ],\n      CONSTANT_ATTRIBUTES: [{ name: \"a_barycentric\", size: 3, type: FLOAT }],\n      CONSTANT_DATA: [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n      ],\n    };\n  }\n\n  processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ) {\n    const thickness = data.size || 1;\n    const radius = targetData.size || 1;\n    const x1 = sourceData.x;\n    const y1 = sourceData.y;\n    const x2 = targetData.x;\n    const y2 = targetData.y;\n    const color = floatColor(data.color);\n\n    // Computing normals\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n\n    let len = dx * dx + dy * dy;\n    let n1 = 0;\n    let n2 = 0;\n\n    if (len) {\n      len = 1 / Math.sqrt(len);\n\n      n1 = -dy * len * thickness;\n      n2 = dx * len * thickness;\n    }\n\n    const array = this.array;\n\n    array[startIndex++] = x2;\n    array[startIndex++] = y2;\n    array[startIndex++] = -n1;\n    array[startIndex++] = -n2;\n    array[startIndex++] = radius;\n    array[startIndex++] = color;\n    array[startIndex++] = edgeIndex;\n  }\n\n  setUniforms(params: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n    const { u_matrix, u_sizeRatio, u_correctionRatio } = uniformLocations;\n\n    gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    gl.uniform1f(u_sizeRatio, params.sizeRatio);\n    gl.uniform1f(u_correctionRatio, params.correctionRatio);\n  }\n}\n","attribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\nattribute float a_radius;\nattribute float a_radiusCoef;\n\nuniform mat3 u_matrix;\nuniform float u_zoomRatio;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\nconst float arrowHeadLengthThicknessRatio = 2.5;\n\nvoid main() {\n  float radius = a_radius * a_radiusCoef;\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl. Please read it to\n  // get better comments on what's happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  // Here, we move the point to leave space for the arrow head:\n  float direction = sign(radius);\n  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\n\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);\n\n  v_thickness = webGLThickness / u_zoomRatio;\n\n  v_normal = unitNormal;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n","/**\n * Sigma.js WebGL Renderer Edge Program\n * =====================================\n *\n * Program rendering edges as thick lines but with a twist: the end of edge\n * does not sit in the middle of target node but instead stays by some margin.\n *\n * This is useful when combined with arrows to draw directed edges.\n * @module\n */\nimport EdgeRectangleProgram from \"../edge-rectangle\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\nimport { EdgeDisplayData, NodeDisplayData } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nexport default class EdgeClampedProgram extends EdgeRectangleProgram {\n  getDefinition() {\n    return {\n      ...super.getDefinition(),\n      VERTEX_SHADER_SOURCE,\n      ATTRIBUTES: [\n        { name: \"a_positionStart\", size: 2, type: FLOAT },\n        { name: \"a_positionEnd\", size: 2, type: FLOAT },\n        { name: \"a_normal\", size: 2, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_radius\", size: 1, type: FLOAT },\n      ],\n      CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 1, then position will be a_positionEnd\n        { name: \"a_positionCoef\", size: 1, type: FLOAT },\n        { name: \"a_normalCoef\", size: 1, type: FLOAT },\n        { name: \"a_radiusCoef\", size: 1, type: FLOAT },\n      ],\n      CONSTANT_DATA: [\n        [0, 1, 0],\n        [0, -1, 0],\n        [1, 1, 1],\n        [1, 1, 1],\n        [0, -1, 0],\n        [1, -1, -1],\n      ],\n    };\n  }\n\n  processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ) {\n    const thickness = data.size || 1;\n    const x1 = sourceData.x;\n    const y1 = sourceData.y;\n    const x2 = targetData.x;\n    const y2 = targetData.y;\n    const color = floatColor(data.color);\n\n    // Computing normals\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n\n    const radius = targetData.size || 1;\n\n    let len = dx * dx + dy * dy;\n    let n1 = 0;\n    let n2 = 0;\n\n    if (len) {\n      len = 1 / Math.sqrt(len);\n\n      n1 = -dy * len * thickness;\n      n2 = dx * len * thickness;\n    }\n\n    const array = this.array;\n\n    array[startIndex++] = x1;\n    array[startIndex++] = y1;\n    array[startIndex++] = x2;\n    array[startIndex++] = y2;\n    array[startIndex++] = n1;\n    array[startIndex++] = n2;\n    array[startIndex++] = color;\n    array[startIndex++] = edgeIndex;\n    array[startIndex++] = radius;\n  }\n}\n","/**\n * Sigma.js WebGL Renderer Edge Arrow Program\n * ===========================================\n *\n * Compound program rendering edges as an arrow from the source to the target.\n * @module\n */\nimport { createEdgeCompoundProgram } from \"../../edge\";\nimport EdgeArrowHeadProgram from \"../edge-arrow-head\";\nimport EdgeClampedProgram from \"../edge-clamped\";\n\nconst EdgeArrowProgram = createEdgeCompoundProgram([EdgeClampedProgram, EdgeArrowHeadProgram]);\n\nexport default EdgeArrowProgram;\n","import { EdgeDisplayData, NodeDisplayData, PartialButFor } from \"../types\";\nimport { Settings } from \"../settings\";\n\nexport type EdgeLabelDrawingFunction = (\n  context: CanvasRenderingContext2D,\n  edgeData: PartialButFor<EdgeDisplayData, \"label\" | \"color\" | \"size\">,\n  sourceData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  targetData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  settings: Settings,\n) => void;\n\nexport function drawStraightEdgeLabel(\n  context: CanvasRenderingContext2D,\n  edgeData: PartialButFor<EdgeDisplayData, \"label\" | \"color\" | \"size\">,\n  sourceData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  targetData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  settings: Settings,\n): void {\n  const size = settings.edgeLabelSize,\n    font = settings.edgeLabelFont,\n    weight = settings.edgeLabelWeight,\n    color = settings.edgeLabelColor.attribute\n      ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\"\n      : settings.edgeLabelColor.color;\n\n  let label = edgeData.label;\n\n  if (!label) return;\n\n  context.fillStyle = color;\n  context.font = `${weight} ${size}px ${font}`;\n\n  // Computing positions without considering nodes sizes:\n  const sSize = sourceData.size;\n  const tSize = targetData.size;\n  let sx = sourceData.x;\n  let sy = sourceData.y;\n  let tx = targetData.x;\n  let ty = targetData.y;\n  let cx = (sx + tx) / 2;\n  let cy = (sy + ty) / 2;\n  let dx = tx - sx;\n  let dy = ty - sy;\n  let d = Math.sqrt(dx * dx + dy * dy);\n\n  if (d < sSize + tSize) return;\n\n  // Adding nodes sizes:\n  sx += (dx * sSize) / d;\n  sy += (dy * sSize) / d;\n  tx -= (dx * tSize) / d;\n  ty -= (dy * tSize) / d;\n  cx = (sx + tx) / 2;\n  cy = (sy + ty) / 2;\n  dx = tx - sx;\n  dy = ty - sy;\n  d = Math.sqrt(dx * dx + dy * dy);\n\n  // Handling ellipsis\n  let textLength = context.measureText(label).width;\n\n  if (textLength > d) {\n    const ellipsis = \"\";\n    label = label + ellipsis;\n    textLength = context.measureText(label).width;\n\n    while (textLength > d && label.length > 1) {\n      label = label.slice(0, -2) + ellipsis;\n      textLength = context.measureText(label).width;\n    }\n\n    if (label.length < 4) return;\n  }\n\n  let angle;\n  if (dx > 0) {\n    if (dy > 0) angle = Math.acos(dx / d);\n    else angle = Math.asin(dy / d);\n  } else {\n    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;\n    else angle = Math.asin(dx / d) + Math.PI / 2;\n  }\n\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n\n  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);\n\n  context.restore();\n}\n","import { NodeDisplayData, PartialButFor } from \"../types\";\nimport { Settings } from \"../settings\";\n\nexport type NodeLabelDrawingFunction = (\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings,\n) => void;\n\nexport function drawDiscNodeLabel(\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings,\n): void {\n  if (!data.label) return;\n\n  const size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight,\n    color = settings.labelColor.attribute\n      ? data[settings.labelColor.attribute] || settings.labelColor.color || \"#000\"\n      : settings.labelColor.color;\n\n  context.fillStyle = color;\n  context.font = `${weight} ${size}px ${font}`;\n\n  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}\n","import { Settings } from \"../settings\";\nimport { NodeDisplayData, PartialButFor } from \"../types\";\nimport { drawDiscNodeLabel } from \"./node-labels\";\n\nexport type NodeHoverDrawingFunction = (\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings,\n) => void;\n\n/**\n * Draw an hovered node.\n * - if there is no label => display a shadow on the node\n * - if the label box is bigger than node size => display a label box that contains the node with a shadow\n * - else node with shadow and the label box\n */\nexport function drawDiscNodeHover(\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings,\n): void {\n  const size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight;\n\n  context.font = `${weight} ${size}px ${font}`;\n\n  // Then we draw the label background\n  context.fillStyle = \"#FFF\";\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 8;\n  context.shadowColor = \"#000\";\n\n  const PADDING = 2;\n\n  if (typeof data.label === \"string\") {\n    const textWidth = context.measureText(data.label).width,\n      boxWidth = Math.round(textWidth + 5),\n      boxHeight = Math.round(size + 2 * PADDING),\n      radius = Math.max(data.size, size / 2) + PADDING;\n\n    const angleRadian = Math.asin(boxHeight / 2 / radius);\n    const xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));\n\n    context.beginPath();\n    context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);\n    context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);\n    context.arc(data.x, data.y, radius, angleRadian, -angleRadian);\n    context.closePath();\n    context.fill();\n  } else {\n    context.beginPath();\n    context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);\n    context.closePath();\n    context.fill();\n  }\n\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 0;\n\n  // And finally we draw the label\n  drawDiscNodeLabel(context, data, settings);\n}\n","/**\n * Sigma.js Settings\n * =================================\n *\n * The list of settings and some handy functions.\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport { assign } from \"./utils\";\nimport { EdgeDisplayData, NodeDisplayData } from \"./types\";\nimport NodePointProgram from \"./rendering/programs/node-point\";\nimport EdgeRectangleProgram from \"./rendering/programs/edge-rectangle\";\nimport EdgeArrowProgram from \"./rendering/programs/edge-arrow\";\nimport { EdgeProgramType } from \"./rendering\";\nimport { NodeProgramType } from \"./rendering\";\nimport { drawStraightEdgeLabel, EdgeLabelDrawingFunction } from \"./rendering/edge-labels\";\nimport { drawDiscNodeLabel, NodeLabelDrawingFunction } from \"./rendering/node-labels\";\nimport { drawDiscNodeHover, NodeHoverDrawingFunction } from \"./rendering/node-hover\";\n\n/**\n * Sigma.js settings\n * =================================\n */\nexport interface Settings {\n  // Performance\n  hideEdgesOnMove: boolean;\n  hideLabelsOnMove: boolean;\n  renderLabels: boolean;\n  renderEdgeLabels: boolean;\n  enableEdgeEvents: boolean;\n  // Component rendering\n  defaultNodeColor: string;\n  defaultNodeType: string;\n  defaultEdgeColor: string;\n  defaultEdgeType: string;\n  labelFont: string;\n  labelSize: number;\n  labelWeight: string;\n  labelColor: { attribute: string; color?: string } | { color: string; attribute?: undefined };\n  edgeLabelFont: string;\n  edgeLabelSize: number;\n  edgeLabelWeight: string;\n  edgeLabelColor: { attribute: string; color?: string } | { color: string; attribute?: undefined };\n  stagePadding: number;\n  zoomToSizeRatioFunction: (ratio: number) => number;\n  itemSizesReference: \"screen\" | \"positions\";\n  defaultDrawEdgeLabel: EdgeLabelDrawingFunction;\n  defaultDrawNodeLabel: NodeLabelDrawingFunction;\n  defaultDrawNodeHover: NodeHoverDrawingFunction;\n\n  // Labels\n  labelDensity: number;\n  labelGridCellSize: number;\n  labelRenderedSizeThreshold: number;\n\n  // Reducers\n  nodeReducer: null | ((node: string, data: Attributes) => Partial<NodeDisplayData>);\n  edgeReducer: null | ((edge: string, data: Attributes) => Partial<EdgeDisplayData>);\n\n  // Features\n  zIndex: boolean;\n  minCameraRatio: null | number;\n  maxCameraRatio: null | number;\n\n  // Lifecycle\n  allowInvalidContainer: boolean;\n\n  // Program classes\n  nodeProgramClasses: { [type: string]: NodeProgramType };\n  nodeHoverProgramClasses: { [type: string]: NodeProgramType };\n  edgeProgramClasses: { [type: string]: EdgeProgramType };\n}\n\nexport const DEFAULT_SETTINGS: Settings = {\n  // Performance\n  hideEdgesOnMove: false,\n  hideLabelsOnMove: false,\n  renderLabels: true,\n  renderEdgeLabels: false,\n  enableEdgeEvents: false,\n\n  // Component rendering\n  defaultNodeColor: \"#999\",\n  defaultNodeType: \"circle\",\n  defaultEdgeColor: \"#ccc\",\n  defaultEdgeType: \"line\",\n  labelFont: \"Arial\",\n  labelSize: 14,\n  labelWeight: \"normal\",\n  labelColor: { color: \"#000\" },\n  edgeLabelFont: \"Arial\",\n  edgeLabelSize: 14,\n  edgeLabelWeight: \"normal\",\n  edgeLabelColor: { attribute: \"color\" },\n  stagePadding: 30,\n  zoomToSizeRatioFunction: Math.sqrt,\n  itemSizesReference: \"screen\",\n  defaultDrawEdgeLabel: drawStraightEdgeLabel,\n  defaultDrawNodeLabel: drawDiscNodeLabel,\n  defaultDrawNodeHover: drawDiscNodeHover,\n\n  // Labels\n  labelDensity: 1,\n  labelGridCellSize: 100,\n  labelRenderedSizeThreshold: 6,\n\n  // Reducers\n  nodeReducer: null,\n  edgeReducer: null,\n\n  // Features\n  zIndex: false,\n  minCameraRatio: null,\n  maxCameraRatio: null,\n\n  // Lifecycle\n  allowInvalidContainer: false,\n\n  // Program classes\n  nodeProgramClasses: {},\n  nodeHoverProgramClasses: {},\n  edgeProgramClasses: {},\n};\n\nexport const DEFAULT_NODE_PROGRAM_CLASSES: Record<string, NodeProgramType> = {\n  circle: NodePointProgram,\n};\n\nexport const DEFAULT_EDGE_PROGRAM_CLASSES: Record<string, EdgeProgramType> = {\n  arrow: EdgeArrowProgram,\n  line: EdgeRectangleProgram,\n};\n\nexport function validateSettings(settings: Settings): void {\n  if (typeof settings.labelDensity !== \"number\" || settings.labelDensity < 0) {\n    throw new Error(\"Settings: invalid `labelDensity`. Expecting a positive number.\");\n  }\n\n  const { minCameraRatio, maxCameraRatio } = settings;\n  if (typeof minCameraRatio === \"number\" && typeof maxCameraRatio === \"number\" && maxCameraRatio < minCameraRatio) {\n    throw new Error(\n      \"Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`.\",\n    );\n  }\n}\n\nexport function resolveSettings(settings: Partial<Settings>): Settings {\n  const resolvedSettings = assign({}, DEFAULT_SETTINGS, settings);\n\n  resolvedSettings.nodeProgramClasses = assign({}, DEFAULT_NODE_PROGRAM_CLASSES, resolvedSettings.nodeProgramClasses);\n  resolvedSettings.edgeProgramClasses = assign({}, DEFAULT_EDGE_PROGRAM_CLASSES, resolvedSettings.edgeProgramClasses);\n\n  return resolvedSettings;\n}\n","/**\n * Sigma.js Touch Captor\n * ======================\n *\n * Sigma's captor dealing with touch.\n * @module\n */\nimport { CameraState, Coordinates, Dimensions, TouchCoords } from \"../../types\";\nimport Captor, { getPosition, getTouchCoords, getTouchesArray } from \"./captor\";\nimport Sigma from \"../../sigma\";\n\nconst DRAG_TIMEOUT = 200;\nconst TOUCH_INERTIA_RATIO = 3;\nconst TOUCH_INERTIA_DURATION = 200;\n\nexport type FakeSigmaMouseEvent = MouseEvent & { isFakeSigmaMouseEvent?: true };\n\n/**\n * Event types.\n */\nexport type TouchCaptorEvents = {\n  touchdown(coordinates: TouchCoords): void;\n  touchup(coordinates: TouchCoords): void;\n  touchmove(coordinates: TouchCoords): void;\n};\n\n/**\n * Touch captor class.\n *\n * @constructor\n */\nexport default class TouchCaptor extends Captor<TouchCaptorEvents> {\n  enabled = true;\n  isMoving = false;\n  hasMoved = false;\n  startCameraState?: CameraState;\n  touchMode = 0; // number of touches down\n  movingTimeout?: number;\n\n  startTouchesAngle?: number;\n  startTouchesDistance?: number;\n  startTouchesPositions: Coordinates[] = [];\n  lastTouchesPositions?: Coordinates[];\n  lastTouches?: Touch[];\n\n  constructor(container: HTMLElement, renderer: Sigma) {\n    super(container, renderer);\n\n    // Binding methods:\n    this.handleStart = this.handleStart.bind(this);\n    this.handleLeave = this.handleLeave.bind(this);\n    this.handleMove = this.handleMove.bind(this);\n\n    // Binding events\n    container.addEventListener(\"touchstart\", this.handleStart, false);\n    container.addEventListener(\"touchend\", this.handleLeave, false);\n    container.addEventListener(\"touchcancel\", this.handleLeave, false);\n    container.addEventListener(\"touchmove\", this.handleMove, false);\n  }\n\n  kill(): void {\n    const container = this.container;\n\n    container.removeEventListener(\"touchstart\", this.handleStart);\n    container.removeEventListener(\"touchend\", this.handleLeave);\n    container.removeEventListener(\"touchcancel\", this.handleLeave);\n    container.removeEventListener(\"touchmove\", this.handleMove);\n  }\n\n  getDimensions(): Dimensions {\n    return {\n      width: this.container.offsetWidth,\n      height: this.container.offsetHeight,\n    };\n  }\n\n  dispatchRelatedMouseEvent(type: string, e: TouchEvent, touch?: Touch, emitter?: EventTarget): void {\n    const mousePosition = touch || e.touches[0];\n    const mouseEvent = new MouseEvent(type, {\n      clientX: mousePosition.clientX,\n      clientY: mousePosition.clientY,\n      altKey: e.altKey,\n      ctrlKey: e.ctrlKey,\n    });\n\n    (mouseEvent as FakeSigmaMouseEvent).isFakeSigmaMouseEvent = true;\n\n    (emitter || this.container).dispatchEvent(mouseEvent);\n  }\n\n  handleStart(e: TouchEvent): void {\n    if (!this.enabled) return;\n\n    // Prevent default to avoid default browser behaviors...\n    e.preventDefault();\n    // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n    if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousedown\", e);\n\n    const touches = getTouchesArray(e.touches);\n    this.touchMode = touches.length;\n\n    this.startCameraState = this.renderer.getCamera().getState();\n    this.startTouchesPositions = touches.map((touch) => getPosition(touch, this.container));\n    this.lastTouches = touches;\n    this.lastTouchesPositions = this.startTouchesPositions;\n\n    // When there are two touches down, let's record distance and angle as well:\n    if (this.touchMode === 2) {\n      const [{ x: x0, y: y0 }, { x: x1, y: y1 }] = this.startTouchesPositions;\n      this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n      this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n    }\n\n    this.emit(\"touchdown\", getTouchCoords(e, this.container));\n  }\n\n  handleLeave(e: TouchEvent): void {\n    if (!this.enabled) return;\n\n    // Prevent default to avoid default browser behaviors...\n    e.preventDefault();\n    // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n    if (e.touches.length === 0 && this.lastTouches && this.lastTouches.length) {\n      this.dispatchRelatedMouseEvent(\"mouseup\", e, this.lastTouches[0], document);\n      // ... and only click if no move was made\n      if (!this.hasMoved) {\n        this.dispatchRelatedMouseEvent(\"click\", e, this.lastTouches[0]);\n      }\n    }\n\n    if (this.movingTimeout) {\n      this.isMoving = false;\n      clearTimeout(this.movingTimeout);\n    }\n\n    switch (this.touchMode) {\n      case 2:\n        if (e.touches.length === 1) {\n          this.handleStart(e);\n\n          e.preventDefault();\n          break;\n        }\n      /* falls through */\n      case 1:\n        // TODO\n        // Dispatch event\n\n        if (this.isMoving) {\n          const camera = this.renderer.getCamera();\n          const cameraState = camera.getState(),\n            previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };\n\n          camera.animate(\n            {\n              x: cameraState.x + TOUCH_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + TOUCH_INERTIA_RATIO * (cameraState.y - previousCameraState.y),\n            },\n            {\n              duration: TOUCH_INERTIA_DURATION,\n              easing: \"quadraticOut\",\n            },\n          );\n        }\n\n        this.hasMoved = false;\n        this.isMoving = false;\n        this.touchMode = 0;\n        break;\n    }\n\n    this.emit(\"touchup\", getTouchCoords(e, this.container));\n  }\n\n  handleMove(e: TouchEvent): void {\n    if (!this.enabled) return;\n\n    // Prevent default to avoid default browser behaviors...\n    e.preventDefault();\n    // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n    if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousemove\", e);\n\n    const touches = getTouchesArray(e.touches);\n    const touchesPositions = touches.map((touch) => getPosition(touch, this.container));\n    this.lastTouches = touches;\n    this.lastTouchesPositions = touchesPositions;\n\n    // If a move was initiated at some point and we get back to startpoint,\n    // we should still consider that we did move (which also happens after a\n    // multiple touch when only one touch remains in which case handleStart\n    // is recalled within handleLeave).\n    // Now, some mobile browsers report zero-distance moves so we also check that\n    // one of the touches did actually move from the origin position.\n    this.hasMoved ||= touchesPositions.some((position, idx) => {\n      const startPosition = this.startTouchesPositions[idx];\n\n      return position.x !== startPosition.x || position.y !== startPosition.y;\n    });\n\n    // If there was no move, do not trigger touch moves behavior\n    if (!this.hasMoved) {\n      return;\n    }\n\n    this.isMoving = true;\n\n    if (this.movingTimeout) clearTimeout(this.movingTimeout);\n\n    this.movingTimeout = window.setTimeout(() => {\n      this.isMoving = false;\n    }, DRAG_TIMEOUT);\n\n    const camera = this.renderer.getCamera();\n    const startCameraState = this.startCameraState as CameraState;\n\n    switch (this.touchMode) {\n      case 1: {\n        const { x: xStart, y: yStart } = this.renderer.viewportToFramedGraph(\n          (this.startTouchesPositions || [])[0] as Coordinates,\n        );\n        const { x, y } = this.renderer.viewportToFramedGraph(touchesPositions[0]);\n\n        camera.setState({\n          x: startCameraState.x + xStart - x,\n          y: startCameraState.y + yStart - y,\n        });\n        break;\n      }\n      case 2: {\n        /**\n         * Here is the thinking here:\n         *\n         * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n         *    of the d'n'd and now\n         *\n         * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n         *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n         *    position of this same touch now\n         */\n        const newCameraState: Partial<CameraState> = {};\n\n        const { x: x0, y: y0 } = touchesPositions[0];\n        const { x: x1, y: y1 } = touchesPositions[1];\n\n        const angleDiff = Math.atan2(y1 - y0, x1 - x0) - (this.startTouchesAngle as number);\n        const ratioDiff = Math.hypot(y1 - y0, x1 - x0) / (this.startTouchesDistance as number);\n\n        // 1.\n        const newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n        newCameraState.ratio = newRatio;\n        newCameraState.angle = startCameraState.angle + angleDiff;\n\n        // 2.\n        const dimensions = this.getDimensions();\n        const touchGraphPosition = this.renderer.viewportToFramedGraph(\n          (this.startTouchesPositions || [])[0] as Coordinates,\n          { cameraState: startCameraState },\n        );\n        const smallestDimension = Math.min(dimensions.width, dimensions.height);\n\n        const dx = smallestDimension / dimensions.width;\n        const dy = smallestDimension / dimensions.height;\n        const ratio = newRatio / smallestDimension;\n\n        // Align with center of the graph:\n        let x = x0 - smallestDimension / 2 / dx;\n        let y = y0 - smallestDimension / 2 / dy;\n\n        // Rotate:\n        [x, y] = [\n          x * Math.cos(-newCameraState.angle) - y * Math.sin(-newCameraState.angle),\n          y * Math.cos(-newCameraState.angle) + x * Math.sin(-newCameraState.angle),\n        ];\n\n        newCameraState.x = touchGraphPosition.x - x * ratio;\n        newCameraState.y = touchGraphPosition.y + y * ratio;\n\n        camera.setState(newCameraState);\n\n        break;\n      }\n    }\n\n    this.emit(\"touchmove\", getTouchCoords(e, this.container));\n  }\n}\n","/**\n * Extend function\n * ================\n *\n * Function used to push a bunch of values into an array at once.\n * Freely inspired by @Yomguithereal/helpers/extend.\n */\n\n/**\n * Extends the target array with the given values.\n *\n * @param  {array} array  - Target array.\n * @param  {array} values - A set of the values to add.\n */\nexport function extend<T>(array: T[], values: Set<T>): void {\n  const l2 = values.size;\n\n  if (l2 === 0) return;\n\n  const l1 = array.length;\n\n  array.length += l2;\n\n  let i = 0;\n  values.forEach((value) => {\n    array[l1 + i] = value;\n    i++;\n  });\n}\n","export function getPixelColor(\n  gl: WebGLRenderingContext,\n  frameBuffer: WebGLBuffer | null,\n  x: number,\n  y: number,\n  pixelRatio: number,\n  downSizingRatio: number,\n): [number, number, number, number] {\n  const bufferX = Math.floor((x / downSizingRatio) * pixelRatio);\n  const bufferY = Math.floor(gl.drawingBufferHeight / downSizingRatio - (y / downSizingRatio) * pixelRatio);\n\n  const pixel = new Uint8Array(4);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.readPixels(bufferX, bufferY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n  const [r, g, b, a] = pixel;\n  return [r, g, b, a];\n}\n","/**\n * Sigma.js\n * ========\n * @module\n */\nimport Graph from \"graphology-types\";\n\nimport Camera from \"./core/camera\";\nimport MouseCaptor from \"./core/captors/mouse\";\nimport {\n  CameraState,\n  Coordinates,\n  Dimensions,\n  EdgeDisplayData,\n  Extent,\n  Listener,\n  MouseCoords,\n  NodeDisplayData,\n  PlainObject,\n  CoordinateConversionOverride,\n  TypedEventEmitter,\n  MouseInteraction,\n  RenderParams,\n} from \"./types\";\nimport {\n  createElement,\n  getPixelRatio,\n  createNormalizationFunction,\n  NormalizationFunction,\n  cancelFrame,\n  matrixFromCamera,\n  requestFrame,\n  validateGraph,\n  zIndexOrdering,\n  getMatrixImpact,\n  graphExtent,\n  colorToIndex,\n} from \"./utils\";\nimport { edgeLabelsToDisplayFromNodes, LabelGrid } from \"./core/labels\";\nimport { Settings, validateSettings, resolveSettings } from \"./settings\";\nimport { AbstractNodeProgram } from \"./rendering/node\";\nimport { AbstractEdgeProgram } from \"./rendering/edge\";\nimport TouchCaptor, { FakeSigmaMouseEvent } from \"./core/captors/touch\";\nimport { identity, multiplyVec2 } from \"./utils/matrices\";\nimport { extend } from \"./utils/array\";\nimport { getPixelColor } from \"./utils/picking\";\n\n/**\n * Constants.\n */\nconst X_LABEL_MARGIN = 150;\nconst Y_LABEL_MARGIN = 50;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings: Settings, key: string, data: Partial<NodeDisplayData>): NodeDisplayData {\n  if (!data.hasOwnProperty(\"x\") || !data.hasOwnProperty(\"y\"))\n    throw new Error(\n      `Sigma: could not find a valid position (x, y) for node \"${key}\". All your nodes must have a number \"x\" and \"y\". Maybe your forgot to apply a layout or your \"nodeReducer\" is not returning the correct data?`,\n    );\n\n  if (!data.color) data.color = settings.defaultNodeColor;\n\n  if (!data.label && data.label !== \"\") data.label = null;\n\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;\n  else data.label = null;\n\n  if (!data.size) data.size = 2;\n\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n\n  if (!data.hasOwnProperty(\"highlighted\")) data.highlighted = false;\n\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n\n  if (!data.zIndex) data.zIndex = 0;\n\n  return data as NodeDisplayData;\n}\n\nfunction applyEdgeDefaults(settings: Settings, _key: string, data: Partial<EdgeDisplayData>): EdgeDisplayData {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n\n  if (!data.label) data.label = \"\";\n\n  if (!data.size) data.size = 0.5;\n\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n\n  if (!data.zIndex) data.zIndex = 0;\n\n  return data as EdgeDisplayData;\n}\n\n/**\n * Event types.\n */\nexport interface SigmaEventPayload {\n  event: MouseCoords;\n  preventSigmaDefault(): void;\n}\n\nexport interface SigmaStageEventPayload extends SigmaEventPayload {}\nexport interface SigmaNodeEventPayload extends SigmaEventPayload {\n  node: string;\n}\nexport interface SigmaEdgeEventPayload extends SigmaEventPayload {\n  edge: string;\n}\n\nexport type SigmaStageEvents = {\n  [E in MouseInteraction as `${E}Stage`]: (payload: SigmaStageEventPayload) => void;\n};\n\nexport type SigmaNodeEvents = {\n  [E in MouseInteraction as `${E}Node`]: (payload: SigmaNodeEventPayload) => void;\n};\n\nexport type SigmaEdgeEvents = {\n  [E in MouseInteraction as `${E}Edge`]: (payload: SigmaEdgeEventPayload) => void;\n};\n\nexport type SigmaAdditionalEvents = {\n  // Lifecycle events\n  beforeRender(): void;\n  afterRender(): void;\n  resize(): void;\n  kill(): void;\n\n  // Additional node events\n  enterNode(payload: SigmaNodeEventPayload): void;\n  leaveNode(payload: SigmaNodeEventPayload): void;\n\n  // Additional edge events\n  enterEdge(payload: SigmaEdgeEventPayload): void;\n  leaveEdge(payload: SigmaEdgeEventPayload): void;\n};\n\nexport type SigmaEvents = SigmaStageEvents & SigmaNodeEvents & SigmaEdgeEvents & SigmaAdditionalEvents;\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nexport default class Sigma<GraphType extends Graph = Graph> extends TypedEventEmitter<SigmaEvents> {\n  private settings: Settings;\n  private graph: GraphType;\n  private mouseCaptor: MouseCaptor;\n  private touchCaptor: TouchCaptor;\n  private container: HTMLElement;\n  private elements: PlainObject<HTMLCanvasElement> = {};\n  private canvasContexts: PlainObject<CanvasRenderingContext2D> = {};\n  private webGLContexts: PlainObject<WebGLRenderingContext> = {};\n  private pickingLayers: Set<string> = new Set();\n  private textures: PlainObject<WebGLTexture> = {};\n  private frameBuffers: PlainObject<WebGLFramebuffer> = {};\n  private activeListeners: PlainObject<Listener> = {};\n  private labelGrid: LabelGrid = new LabelGrid();\n  private nodeDataCache: Record<string, NodeDisplayData> = {};\n  private edgeDataCache: Record<string, EdgeDisplayData> = {};\n\n  // Indices to keep track of the index of the item inside programs\n  private nodeProgramIndex: Record<string, number> = {};\n  private edgeProgramIndex: Record<string, number> = {};\n  private nodesWithForcedLabels: Set<string> = new Set<string>();\n  private edgesWithForcedLabels: Set<string> = new Set<string>();\n  private nodeExtent: { x: Extent; y: Extent } = { x: [0, 1], y: [0, 1] };\n  private nodeZExtent: [number, number] = [Infinity, -Infinity];\n  private edgeZExtent: [number, number] = [Infinity, -Infinity];\n\n  private matrix: Float32Array = identity();\n  private invMatrix: Float32Array = identity();\n  private correctionRatio = 1;\n  private customBBox: { x: Extent; y: Extent } | null = null;\n  private normalizationFunction: NormalizationFunction = createNormalizationFunction({\n    x: [0, 1],\n    y: [0, 1],\n  });\n\n  // Cache:\n  private graphToViewportRatio = 1;\n  private itemIDsIndex: Record<number, { type: \"node\" | \"edge\"; id: string }> = {};\n  private nodeIndices: Record<string, number> = {};\n  private edgeIndices: Record<string, number> = {};\n\n  // Starting dimensions and pixel ratio\n  private width = 0;\n  private height = 0;\n  private pixelRatio = getPixelRatio();\n  private pickingDownSizingRatio = 2 * this.pixelRatio;\n\n  // Graph State\n  private displayedNodeLabels: Set<string> = new Set();\n  private displayedEdgeLabels: Set<string> = new Set();\n  private highlightedNodes: Set<string> = new Set();\n  private hoveredNode: string | null = null;\n  private hoveredEdge: string | null = null;\n\n  // Internal states\n  private renderFrame: number | null = null;\n  private renderHighlightedNodesFrame: number | null = null;\n  private needToProcess = false;\n  private checkEdgesEventsFrame: number | null = null;\n\n  // Programs\n  private nodePrograms: { [key: string]: AbstractNodeProgram } = {};\n  private nodeHoverPrograms: { [key: string]: AbstractNodeProgram } = {};\n  private edgePrograms: { [key: string]: AbstractEdgeProgram } = {};\n\n  private camera: Camera;\n\n  constructor(graph: GraphType, container: HTMLElement, settings: Partial<Settings> = {}) {\n    super();\n\n    // Resolving settings\n    this.settings = resolveSettings(settings);\n\n    // Validating\n    validateSettings(this.settings);\n    validateGraph(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    this.graph = graph;\n    this.container = container;\n\n    // Initializing contexts\n    this.createWebGLContext(\"edges\", { picking: settings.enableEdgeEvents });\n    this.createCanvasContext(\"edgeLabels\");\n    this.createWebGLContext(\"nodes\", { picking: true });\n    this.createCanvasContext(\"labels\");\n    this.createCanvasContext(\"hovers\");\n    this.createWebGLContext(\"hoverNodes\");\n    this.createCanvasContext(\"mouse\");\n\n    // Initial resize\n    this.resize();\n\n    // Loading programs\n    for (const type in this.settings.nodeProgramClasses) {\n      const NodeProgramClass = this.settings.nodeProgramClasses[type];\n      this.nodePrograms[type] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);\n\n      let NodeHoverProgram = NodeProgramClass;\n      if (type in this.settings.nodeHoverProgramClasses) {\n        NodeHoverProgram = this.settings.nodeHoverProgramClasses[type];\n      }\n\n      this.nodeHoverPrograms[type] = new NodeHoverProgram(this.webGLContexts.hoverNodes, null, this);\n    }\n\n    for (const type in this.settings.edgeProgramClasses) {\n      const EdgeProgramClass = this.settings.edgeProgramClasses[type];\n      this.edgePrograms[type] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);\n    }\n\n    // Initializing the camera\n    this.camera = new Camera();\n\n    // Binding camera events\n    this.bindCameraHandlers();\n\n    // Initializing captors\n    this.mouseCaptor = new MouseCaptor(this.elements.mouse, this);\n    this.touchCaptor = new TouchCaptor(this.elements.mouse, this);\n\n    // Binding event handlers\n    this.bindEventHandlers();\n\n    // Binding graph handlers\n    this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    this.refresh();\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to create a canvas element.\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  private createCanvas(id: string): HTMLCanvasElement {\n    const canvas: HTMLCanvasElement = createElement<HTMLCanvasElement>(\n      \"canvas\",\n      {\n        position: \"absolute\",\n      },\n      {\n        class: `sigma-${id}`,\n      },\n    );\n\n    this.elements[id] = canvas;\n    this.container.appendChild(canvas);\n\n    return canvas;\n  }\n\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  private createCanvasContext(id: string): this {\n    const canvas = this.createCanvas(id);\n\n    const contextOptions = {\n      preserveDrawingBuffer: false,\n      antialias: false,\n    };\n\n    this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions) as CanvasRenderingContext2D;\n\n    return this;\n  }\n\n  /**\n   * Internal function used to create a WebGL context and add the relevant DOM\n   * elements.\n   *\n   * @param  {string}  id      - Context's id.\n   * @param  {object?} options - #getContext params to override (optional)\n   * @return {Sigma}\n   */\n  private createWebGLContext(\n    id: string,\n    options?: { preserveDrawingBuffer?: boolean; antialias?: boolean; hidden?: boolean; picking?: boolean },\n  ): this {\n    const canvas = this.createCanvas(id);\n    if (options?.hidden) canvas.remove();\n\n    const contextOptions = {\n      preserveDrawingBuffer: false,\n      antialias: false,\n      ...(options || {}),\n    };\n\n    let context;\n\n    // First we try webgl2 for an easy performance boost\n    context = canvas.getContext(\"webgl2\", contextOptions);\n\n    // Else we fall back to webgl\n    if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n    // Edge, I am looking right at you...\n    if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n\n    const gl = context as WebGLRenderingContext;\n    this.webGLContexts[id] = gl;\n\n    // Blending:\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n    // Prepare frame buffer for picking layers:\n    if (options?.picking) {\n      this.pickingLayers.add(id);\n      const newFrameBuffer = gl.createFramebuffer();\n      if (!newFrameBuffer) throw new Error(`Sigma: cannot create a new frame buffer for layer ${id}`);\n      this.frameBuffers[id] = newFrameBuffer;\n    }\n\n    return this;\n  }\n\n  /**\n   * Method (re)binding WebGL texture (for picking).\n   *\n   * @return {Sigma}\n   */\n  private resetWebGLTexture(id: string): this {\n    const gl = this.webGLContexts[id] as WebGLRenderingContext;\n\n    const frameBuffer = this.frameBuffers[id];\n    const currentTexture = this.textures[id];\n    if (currentTexture) gl.deleteTexture(currentTexture);\n\n    const pickingTexture = gl.createTexture();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n\n    this.textures[id] = pickingTexture as WebGLTexture;\n\n    return this;\n  }\n\n  /**\n   * Method binding camera handlers.\n   *\n   * @return {Sigma}\n   */\n  private bindCameraHandlers(): this {\n    this.activeListeners.camera = () => {\n      this.scheduleRender();\n    };\n\n    this.camera.on(\"updated\", this.activeListeners.camera);\n\n    return this;\n  }\n\n  /**\n   * Method unbinding camera handlers.\n   *\n   * @return {Sigma}\n   */\n  private unbindCameraHandlers(): this {\n    this.camera.removeListener(\"updated\", this.activeListeners.camera);\n    return this;\n  }\n\n  /**\n   * Method that returns the closest node to a given position.\n   */\n  private getNodeAtPosition(position: Coordinates): string | null {\n    const { x, y } = position;\n    const color = getPixelColor(\n      this.webGLContexts.nodes,\n      this.frameBuffers.nodes,\n      x,\n      y,\n      this.pixelRatio,\n      this.pickingDownSizingRatio,\n    );\n    const index = colorToIndex(...color);\n    const itemAt = this.itemIDsIndex[index];\n\n    return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n  }\n\n  /**\n   * Method binding event handlers.\n   *\n   * @return {Sigma}\n   */\n  private bindEventHandlers(): this {\n    // Handling window resize\n    this.activeListeners.handleResize = () => {\n      // need to call a refresh to rebuild the labelgrid\n      this.scheduleRefresh();\n    };\n\n    window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n    // Handling mouse move\n    this.activeListeners.handleMove = (e: MouseCoords): void => {\n      const baseEvent = {\n        event: e,\n        preventSigmaDefault(): void {\n          e.preventSigmaDefault();\n        },\n      };\n\n      const nodeToHover = this.getNodeAtPosition(e);\n      if (nodeToHover && this.hoveredNode !== nodeToHover && !this.nodeDataCache[nodeToHover].hidden) {\n        // Handling passing from one node to the other directly\n        if (this.hoveredNode) this.emit(\"leaveNode\", { ...baseEvent, node: this.hoveredNode });\n\n        this.hoveredNode = nodeToHover;\n        this.emit(\"enterNode\", { ...baseEvent, node: nodeToHover });\n        this.scheduleHighlightedNodesRender();\n        return;\n      }\n\n      // Checking if the hovered node is still hovered\n      if (this.hoveredNode) {\n        if (this.getNodeAtPosition(e) !== this.hoveredNode) {\n          const node = this.hoveredNode;\n          this.hoveredNode = null;\n\n          this.emit(\"leaveNode\", { ...baseEvent, node });\n          this.scheduleHighlightedNodesRender();\n          return;\n        }\n      }\n\n      if (this.settings.enableEdgeEvents) {\n        this.checkEdgeHoverEvents(baseEvent);\n      }\n    };\n\n    // Handling click\n    const createMouseListener = (eventType: MouseInteraction): ((e: MouseCoords) => void) => {\n      return (e) => {\n        const baseEvent = {\n          event: e,\n          preventSigmaDefault(): void {\n            e.preventSigmaDefault();\n          },\n        };\n\n        const isFakeSigmaMouseEvent = (e.original as FakeSigmaMouseEvent).isFakeSigmaMouseEvent;\n        const nodeAtPosition = isFakeSigmaMouseEvent ? this.getNodeAtPosition(e) : this.hoveredNode;\n\n        if (nodeAtPosition)\n          return this.emit(`${eventType}Node`, {\n            ...baseEvent,\n            node: nodeAtPosition,\n          });\n\n        if (this.settings.enableEdgeEvents) {\n          const edge = this.getEdgeAtPoint(e.x, e.y);\n          if (edge) return this.emit(`${eventType}Edge`, { ...baseEvent, edge });\n        }\n\n        return this.emit(`${eventType}Stage`, baseEvent);\n      };\n    };\n\n    this.activeListeners.handleClick = createMouseListener(\"click\");\n    this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n    this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n    this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n    this.activeListeners.handleDown = createMouseListener(\"down\");\n\n    this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n    this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n    this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n    this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n    this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n    this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n\n    // TODO\n    // Deal with Touch captor events\n\n    return this;\n  }\n\n  /**\n   * Method binding graph handlers\n   *\n   * @return {Sigma}\n   */\n  private bindGraphHandlers(): this {\n    const graph = this.graph;\n\n    const LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n    this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = (e: { hints?: { attributes?: string[] } }) => {\n      const updatedFields = e.hints?.attributes;\n      // we process all nodes\n      this.graph.forEachNode((node) => this.updateNode(node));\n\n      // if coord, type or zIndex have changed, we need to schedule a render\n      // (zIndex for the programIndex)\n      const layoutChanged = !updatedFields || updatedFields.some((f) => LAYOUT_IMPACTING_FIELDS.has(f));\n      this.refresh({ partialGraph: { nodes: graph.nodes() }, skipIndexation: !layoutChanged, schedule: true });\n    };\n\n    this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = (e: { hints?: { attributes?: string[] } }) => {\n      const updatedFields = e.hints?.attributes;\n      // we process all edges\n      this.graph.forEachEdge((edge) => this.updateEdge(edge));\n      const layoutChanged = updatedFields && [\"zIndex\", \"type\"].some((f) => updatedFields?.includes(f));\n      this.refresh({ partialGraph: { edges: graph.edges() }, skipIndexation: !layoutChanged, schedule: true });\n    };\n\n    // On add node, we add the node in indices and then call for a render\n    this.activeListeners.addNodeGraphUpdate = (payload: { key: string }): void => {\n      const node = payload.key;\n      // we process the node\n      this.addNode(node);\n      // schedule a render for the node\n      this.refresh({ partialGraph: { nodes: [node] }, skipIndexation: false, schedule: true });\n    };\n\n    // On update node, we update indices and then call for a render\n    this.activeListeners.updateNodeGraphUpdate = (payload: { key: string }): void => {\n      const node = payload.key;\n      // schedule a render for the node\n      this.refresh({ partialGraph: { nodes: [node] }, skipIndexation: false, schedule: true });\n    };\n\n    // On drop node, we remove the node from indices and then call for a refresh\n    this.activeListeners.dropNodeGraphUpdate = (payload: { key: string }): void => {\n      const node = payload.key;\n      // we process the node\n      this.removeNode(node);\n      // schedule a render for everything\n      this.refresh({ schedule: true });\n    };\n\n    // On add edge, we remove the edge from indices and then call for a refresh\n    this.activeListeners.addEdgeGraphUpdate = (payload: { key: string }): void => {\n      const edge = payload.key;\n      // we process the edge\n      this.addEdge(edge);\n      // schedule a render for the edge\n      this.refresh({ partialGraph: { edges: [edge] }, schedule: true });\n    };\n\n    // On update edge, we update indices and then call for a refresh\n    this.activeListeners.updateEdgeGraphUpdate = (payload: { key: string }): void => {\n      const edge = payload.key;\n      // schedule a repaint for the edge\n      this.refresh({ partialGraph: { edges: [edge] }, skipIndexation: false, schedule: true });\n    };\n\n    // On drop edge, we remove the edge from indices and then call for a refresh\n    this.activeListeners.dropEdgeGraphUpdate = (payload: { key: string }): void => {\n      const edge = payload.key;\n      // we process the edge\n      this.removeEdge(edge);\n      // schedule a render for all edges\n      this.refresh({ schedule: true });\n    };\n\n    // On clear edges, we clear the edge indices and then call for a refresh\n    this.activeListeners.clearEdgesGraphUpdate = (): void => {\n      // we clear the edge data structures\n      this.clearEdgeState();\n      this.clearEdgeIndices();\n      // schedule a render for all edges\n      this.refresh({ schedule: true });\n    };\n\n    // On graph clear, we clear indices and then call for a refresh\n    this.activeListeners.clearGraphUpdate = (): void => {\n      // clear graph state\n      this.clearEdgeState();\n      this.clearNodeState();\n\n      // clear graph indices\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n\n      // schedule a render for all\n      this.refresh({ schedule: true });\n    };\n\n    graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n    graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n    graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n    graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n    graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n    graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n    graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n    graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n\n    return this;\n  }\n\n  /**\n   * Method used to unbind handlers from the graph.\n   *\n   * @return {undefined}\n   */\n  private unbindGraphHandlers() {\n    const graph = this.graph;\n\n    graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n    graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n    graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n    graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n    graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n    graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n    graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n    graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n  }\n\n  /**\n   * Method dealing with \"leaveEdge\" and \"enterEdge\" events.\n   *\n   * @return {Sigma}\n   */\n  private checkEdgeHoverEvents(payload: SigmaEventPayload): this {\n    const edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(payload.event.x, payload.event.y);\n\n    if (edgeToHover !== this.hoveredEdge) {\n      if (this.hoveredEdge) this.emit(\"leaveEdge\", { ...payload, edge: this.hoveredEdge });\n      if (edgeToHover) this.emit(\"enterEdge\", { ...payload, edge: edgeToHover });\n      this.hoveredEdge = edgeToHover;\n    }\n\n    return this;\n  }\n\n  /**\n   * Method looking for an edge colliding with a given point at (x, y). Returns\n   * the key of the edge if any, or null else.\n   */\n  private getEdgeAtPoint(x: number, y: number): string | null {\n    const color = getPixelColor(\n      this.webGLContexts.edges,\n      this.frameBuffers.edges,\n      x,\n      y,\n      this.pixelRatio,\n      this.pickingDownSizingRatio,\n    );\n    const index = colorToIndex(...color);\n    const itemAt = this.itemIDsIndex[index];\n\n    return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n  }\n\n  /**\n   * Method used to process the whole graph's data.\n   *  - extent\n   *  - normalizationFunction\n   *  - compute node's coordinate\n   *  - labelgrid\n   *  - program data allocation\n   * @return {Sigma}\n   */\n  private process(): this {\n    const graph = this.graph;\n    const settings = this.settings;\n    const dimensions = this.getDimensions();\n\n    //\n    // NODES\n    //\n    this.nodeExtent = graphExtent(this.graph);\n    this.normalizationFunction = createNormalizationFunction(this.customBBox || this.nodeExtent);\n\n    // NOTE: it is important to compute this matrix after computing the node's extent\n    // because #.getGraphDimensions relies on it\n    const nullCamera = new Camera();\n    const nullCameraMatrix = matrixFromCamera(\n      nullCamera.getState(),\n      dimensions,\n      this.getGraphDimensions(),\n      this.getSetting(\"stagePadding\") || 0,\n    );\n    // Resetting the label grid\n    // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n    this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n\n    const nodesPerPrograms: Record<string, number> = {};\n    const nodeIndices: typeof this.nodeIndices = {};\n    const edgeIndices: typeof this.edgeIndices = {};\n    const itemIDsIndex: typeof this.itemIDsIndex = {};\n    let incrID = 1;\n\n    let nodes = graph.nodes();\n\n    // Do some indexation on the whole graph\n    for (let i = 0, l = nodes.length; i < l; i++) {\n      const node = nodes[i];\n      const data = this.nodeDataCache[node];\n\n      // Get initial coordinates\n      const attrs = graph.getNodeAttributes(node);\n      data.x = attrs.x;\n      data.y = attrs.y;\n      this.normalizationFunction.applyTo(data);\n\n      // labelgrid\n      if (typeof data.label === \"string\" && !data.hidden)\n        this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, { matrix: nullCameraMatrix }));\n\n      // update count per program\n      nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n    }\n    this.labelGrid.organize();\n\n    // Allocate memory to programs\n    for (const type in this.nodePrograms) {\n      if (!this.nodePrograms.hasOwnProperty(type)) {\n        throw new Error(`Sigma: could not find a suitable program for node type \"${type}\"!`);\n      }\n      this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      nodesPerPrograms[type] = 0;\n    }\n\n    // Order nodes by zIndex before to add them to program\n    if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1])\n      nodes = zIndexOrdering<string>(\n        this.nodeZExtent,\n        (node: string): number => this.nodeDataCache[node].zIndex,\n        nodes,\n      );\n\n    // Add data to programs\n    for (let i = 0, l = nodes.length; i < l; i++) {\n      const node = nodes[i];\n\n      nodeIndices[node] = incrID;\n      itemIDsIndex[nodeIndices[node]] = { type: \"node\", id: node };\n      incrID++;\n\n      const data = this.nodeDataCache[node];\n      this.addNodeToProgram(node, nodeIndices[node], nodesPerPrograms[data.type]++);\n    }\n\n    //\n    // EDGES\n    //\n\n    const edgesPerPrograms: Record<string, number> = {};\n    let edges = graph.edges();\n\n    // Allocate memory to programs\n    for (let i = 0, l = edges.length; i < l; i++) {\n      const edge = edges[i];\n      const data = this.edgeDataCache[edge];\n      edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;\n    }\n\n    // Order edges by zIndex before to add them to program\n    if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1])\n      edges = zIndexOrdering<string>(\n        this.edgeZExtent,\n        (edge: string): number => this.edgeDataCache[edge].zIndex,\n        edges,\n      );\n\n    for (const type in this.edgePrograms) {\n      if (!this.edgePrograms.hasOwnProperty(type)) {\n        throw new Error(`Sigma: could not find a suitable program for edge type \"${type}\"!`);\n      }\n      this.edgePrograms[type].reallocate(edgesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      edgesPerPrograms[type] = 0;\n    }\n\n    // Add data to programs\n    for (let i = 0, l = edges.length; i < l; i++) {\n      const edge = edges[i];\n\n      edgeIndices[edge] = incrID;\n      itemIDsIndex[edgeIndices[edge]] = { type: \"edge\", id: edge };\n      incrID++;\n\n      const data = this.edgeDataCache[edge];\n      this.addEdgeToProgram(edge, edgeIndices[edge], edgesPerPrograms[data.type]++);\n    }\n\n    this.itemIDsIndex = itemIDsIndex;\n    this.nodeIndices = nodeIndices;\n    this.edgeIndices = edgeIndices;\n\n    return this;\n  }\n\n  /**\n   * Method that backports potential settings updates where it's needed.\n   * @private\n   */\n  private handleSettingsUpdate(): this {\n    this.camera.minRatio = this.settings.minCameraRatio;\n    this.camera.maxRatio = this.settings.maxCameraRatio;\n    this.camera.setState(this.camera.validateState(this.camera.getState()));\n\n    return this;\n  }\n\n  /**\n   * Method used to render labels.\n   *\n   * @return {Sigma}\n   */\n  private renderLabels(): this {\n    if (!this.settings.renderLabels) return this;\n\n    const cameraState = this.camera.getState();\n\n    // Selecting labels to draw\n    const labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n    extend(labelsToDisplay, this.nodesWithForcedLabels);\n\n    this.displayedNodeLabels = new Set();\n\n    // Drawing labels\n    const context = this.canvasContexts.labels;\n\n    for (let i = 0, l = labelsToDisplay.length; i < l; i++) {\n      const node = labelsToDisplay[i];\n      const data = this.nodeDataCache[node];\n\n      // If the node was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      // NOTE: we can do better probably\n      if (this.displayedNodeLabels.has(node)) continue;\n\n      // If the node is hidden, we don't need to display its label obviously\n      if (data.hidden) continue;\n\n      const { x, y } = this.framedGraphToViewport(data);\n\n      // NOTE: we can cache the labels we need to render until the camera's ratio changes\n      const size = this.scaleSize(data.size);\n\n      // Is node big enough?\n      if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n      // Is node actually on screen (with some margin)\n      // NOTE: we used to rely on the quadtree for this, but the coordinates\n      // conversion make it unreliable and at that point we already converted\n      // to viewport coordinates and since the label grid already culls the\n      // number of potential labels to display this looks like a good\n      // performance compromise.\n      // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n      // considering cells obviously outside of the range of the current\n      // view rectangle.\n      if (\n        x < -X_LABEL_MARGIN ||\n        x > this.width + X_LABEL_MARGIN ||\n        y < -Y_LABEL_MARGIN ||\n        y > this.height + Y_LABEL_MARGIN\n      )\n        continue;\n\n      // Because displayed edge labels depend directly on actually rendered node\n      // labels, we need to only add to this.displayedNodeLabels nodes whose label\n      // is rendered.\n      // This makes this.displayedNodeLabels depend on viewport, which might become\n      // an issue once we start memoizing getLabelsToDisplay.\n      this.displayedNodeLabels.add(node);\n\n      const { nodeProgramClasses, defaultDrawNodeLabel } = this.settings;\n      const drawLabel = nodeProgramClasses[data.type].drawLabel || defaultDrawNodeLabel;\n      drawLabel(\n        context,\n        {\n          key: node,\n          ...data,\n          size,\n          x,\n          y,\n        },\n        this.settings,\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to render edge labels, based on which node labels were\n   * rendered.\n   *\n   * @return {Sigma}\n   */\n  private renderEdgeLabels(): this {\n    if (!this.settings.renderEdgeLabels) return this;\n\n    const context = this.canvasContexts.edgeLabels;\n\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n\n    const edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n      graph: this.graph,\n      hoveredNode: this.hoveredNode,\n      displayedNodeLabels: this.displayedNodeLabels,\n      highlightedNodes: this.highlightedNodes,\n    });\n    extend(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n\n    const displayedLabels = new Set<string>();\n    for (let i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n      const edge = edgeLabelsToDisplay[i],\n        extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]],\n        edgeData = this.edgeDataCache[edge];\n\n      // If the edge was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      if (displayedLabels.has(edge)) continue;\n\n      // If the edge is hidden we don't need to display its label\n      // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n      if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n        continue;\n      }\n\n      const { edgeProgramClasses, defaultDrawEdgeLabel } = this.settings;\n      const drawLabel = edgeProgramClasses[edgeData.type].drawLabel || defaultDrawEdgeLabel;\n      drawLabel(\n        context,\n        {\n          key: edge,\n          ...edgeData,\n          size: this.scaleSize(edgeData.size),\n        },\n        {\n          key: extremities[0],\n          ...sourceData,\n          ...this.framedGraphToViewport(sourceData),\n          size: this.scaleSize(sourceData.size),\n        },\n        {\n          key: extremities[1],\n          ...targetData,\n          ...this.framedGraphToViewport(targetData),\n          size: this.scaleSize(targetData.size),\n        },\n        this.settings,\n      );\n      displayedLabels.add(edge);\n    }\n\n    this.displayedEdgeLabels = displayedLabels;\n\n    return this;\n  }\n\n  /**\n   * Method used to render the highlighted nodes.\n   *\n   * @return {Sigma}\n   */\n  private renderHighlightedNodes(): void {\n    const context = this.canvasContexts.hovers;\n\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n\n    // Rendering\n    const render = (node: string): void => {\n      const data = this.nodeDataCache[node];\n\n      const { x, y } = this.framedGraphToViewport(data);\n\n      const size = this.scaleSize(data.size);\n\n      const { nodeProgramClasses, defaultDrawNodeHover } = this.settings;\n      const drawHover = nodeProgramClasses[data.type].drawHover || defaultDrawNodeHover;\n      drawHover(\n        context,\n        {\n          key: node,\n          ...data,\n          size,\n          x,\n          y,\n        },\n        this.settings,\n      );\n    };\n\n    const nodesToRender: string[] = [];\n\n    if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n      nodesToRender.push(this.hoveredNode);\n    }\n\n    this.highlightedNodes.forEach((node) => {\n      // The hovered node has already been highlighted\n      if (node !== this.hoveredNode) nodesToRender.push(node);\n    });\n\n    // Draw labels:\n    nodesToRender.forEach((node) => render(node));\n\n    // Draw WebGL nodes on top of the labels:\n    const nodesPerPrograms: Record<string, number> = {};\n\n    // 1. Count nodes per type:\n    nodesToRender.forEach((node) => {\n      const type = this.nodeDataCache[node].type;\n      nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n    });\n    // 2. Allocate for each type for the proper number of nodes\n    for (const type in this.nodeHoverPrograms) {\n      this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n      // Also reset count, to use when rendering:\n      nodesPerPrograms[type] = 0;\n    }\n    // 3. Process all nodes to render:\n    nodesToRender.forEach((node) => {\n      const data = this.nodeDataCache[node];\n      this.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n    });\n    // 4. Clear hovered nodes layer:\n    this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n    // 5. Render:\n    for (const type in this.nodeHoverPrograms) {\n      const program = this.nodeHoverPrograms[type];\n\n      program.render({\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio,\n        downSizingRatio: this.pickingDownSizingRatio,\n      });\n    }\n  }\n\n  /**\n   * Method used to schedule a hover render.\n   *\n   */\n  private scheduleHighlightedNodesRender(): void {\n    if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n\n    this.renderHighlightedNodesFrame = requestFrame(() => {\n      // Resetting state\n      this.renderHighlightedNodesFrame = null;\n\n      // Rendering\n      this.renderHighlightedNodes();\n      this.renderEdgeLabels();\n    });\n  }\n\n  /**\n   * Method used to render.\n   *\n   * @return {Sigma}\n   */\n  private render(): this {\n    this.emit(\"beforeRender\");\n\n    const exitRender = () => {\n      this.emit(\"afterRender\");\n      return this;\n    };\n\n    // If a render was scheduled, we cancel it\n    if (this.renderFrame) {\n      cancelFrame(this.renderFrame);\n      this.renderFrame = null;\n    }\n\n    // First we need to resize\n    this.resize();\n\n    // Do we need to reprocess data?\n    if (this.needToProcess) this.process();\n    this.needToProcess = false;\n\n    // Clearing the canvases\n    this.clear();\n\n    // Prepare the textures\n    this.pickingLayers.forEach((layer) => this.resetWebGLTexture(layer));\n\n    // If we have no nodes we can stop right there\n    if (!this.graph.order) return exitRender();\n\n    // TODO: improve this heuristic or move to the captor itself?\n    // TODO: deal with the touch captor here as well\n    const mouseCaptor = this.mouseCaptor;\n    const moving =\n      this.camera.isAnimated() ||\n      mouseCaptor.isMoving ||\n      mouseCaptor.draggedEvents ||\n      mouseCaptor.currentWheelDirection;\n\n    // Then we need to extract a matrix from the camera\n    const cameraState = this.camera.getState();\n    const viewportDimensions = this.getDimensions();\n    const graphDimensions = this.getGraphDimensions();\n    const padding = this.getSetting(\"stagePadding\") || 0;\n    this.matrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding);\n    this.invMatrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding, true);\n    this.correctionRatio = getMatrixImpact(this.matrix, cameraState, viewportDimensions);\n    this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n    // [jacomyal]\n    // This comment is related to the one above the `getMatrixImpact` definition:\n    // - `this.correctionRatio` is somehow not completely explained\n    // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n    //   graph\n    // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n    // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n    // when I change the graph, the viewport or the camera. It might be useful later so I prefer to let this comment:\n    // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n    const params: RenderParams = {\n      matrix: this.matrix,\n      width: this.width,\n      height: this.height,\n      pixelRatio: this.pixelRatio,\n      zoomRatio: this.camera.ratio,\n      sizeRatio: 1 / this.scaleSize(),\n      correctionRatio: this.correctionRatio,\n      downSizingRatio: this.pickingDownSizingRatio,\n    };\n\n    // Drawing nodes\n    for (const type in this.nodePrograms) {\n      const program = this.nodePrograms[type];\n      program.render(params);\n    }\n\n    // Drawing edges\n    if (!this.settings.hideEdgesOnMove || !moving) {\n      for (const type in this.edgePrograms) {\n        const program = this.edgePrograms[type];\n        program.render(params);\n      }\n    }\n\n    // Do not display labels on move per setting\n    if (this.settings.hideLabelsOnMove && moving) return exitRender();\n\n    this.renderLabels();\n    this.renderEdgeLabels();\n    this.renderHighlightedNodes();\n\n    return exitRender();\n  }\n\n  /**\n   * Add a node in the internal data structures.\n   * @private\n   * @param key The node's graphology ID\n   */\n  private addNode(key: string): void {\n    // Node display data resolution:\n    //  1. First we get the node's attributes\n    //  2. We optionally reduce them using the function provided by the user\n    //     Note that this function must return a total object and won't be merged\n    //  3. We apply our defaults, while running some vital checks\n    //  4. We apply the normalization function\n    // We shallow copy node data to avoid dangerous behaviors from reducers\n    let attr = Object.assign({}, this.graph.getNodeAttributes(key));\n    if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);\n    const data = applyNodeDefaults(this.settings, key, attr);\n    this.nodeDataCache[key] = data;\n\n    // Label:\n    // We delete and add if needed because this function is also used from\n    // update\n    this.nodesWithForcedLabels.delete(key);\n    if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n    // Highlighted:\n    // We remove and re add if needed because this function is also used from\n    // update\n    this.highlightedNodes.delete(key);\n    if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n    // zIndex\n    if (this.settings.zIndex) {\n      if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n      if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n    }\n  }\n\n  /**\n   * Update a node the internal data structures.\n   * @private\n   * @param key The node's graphology ID\n   */\n  private updateNode(key: string): void {\n    this.addNode(key);\n\n    // Re-apply normalization on the node\n    const data = this.nodeDataCache[key];\n    this.normalizationFunction.applyTo(data);\n  }\n\n  /**\n   * Remove a node from the internal data structures.\n   * @private\n   * @param key The node's graphology ID\n   */\n  private removeNode(key: string): void {\n    // Remove from node cache\n    delete this.nodeDataCache[key];\n    // Remove from node program index\n    delete this.nodeProgramIndex[key];\n    // Remove from higlighted nodes\n    this.highlightedNodes.delete(key);\n    // Remove from hovered\n    if (this.hoveredNode === key) this.hoveredNode = null;\n    // Remove from forced label\n    this.nodesWithForcedLabels.delete(key);\n  }\n\n  /**\n   * Add an edge into the internal data structures.\n   * @private\n   * @param key The edge's graphology ID\n   */\n  private addEdge(key: string): void {\n    // Edge display data resolution:\n    //  1. First we get the edge's attributes\n    //  2. We optionally reduce them using the function provided by the user\n    //  3. Note that this function must return a total object and won't be merged\n    //  4. We apply our defaults, while running some vital checks\n    // We shallow copy edge data to avoid dangerous behaviors from reducers\n    let attr = Object.assign({}, this.graph.getEdgeAttributes(key));\n    if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);\n    const data = applyEdgeDefaults(this.settings, key, attr);\n    this.edgeDataCache[key] = data;\n\n    // Forced label\n    // we filter and re push if needed because this function is also used from\n    // update\n    this.edgesWithForcedLabels.delete(key);\n    if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n    // Check zIndex\n    if (this.settings.zIndex) {\n      if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n      if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n    }\n  }\n\n  /**\n   * Update an edge in the internal data structures.\n   * @private\n   * @param key The edge's graphology ID\n   */\n  private updateEdge(key: string): void {\n    this.addEdge(key);\n  }\n\n  /**\n   * Remove an edge from the internal data structures.\n   * @private\n   * @param key The edge's graphology ID\n   */\n  private removeEdge(key: string): void {\n    // Remove from edge cache\n    delete this.edgeDataCache[key];\n    // Remove from programId index\n    delete this.edgeProgramIndex[key];\n    // Remove from hovered\n    if (this.hoveredEdge === key) this.hoveredEdge = null;\n    // Remove from forced label\n    this.edgesWithForcedLabels.delete(key);\n  }\n\n  /**\n   * Clear all indices related to nodes.\n   * @private\n   */\n  private clearNodeIndices(): void {\n    // LabelGrid & nodeExtent are only manage/populated in the process function\n    this.labelGrid = new LabelGrid();\n    this.nodeExtent = { x: [0, 1], y: [0, 1] };\n    this.nodeDataCache = {};\n    this.edgeProgramIndex = {};\n    this.nodesWithForcedLabels = new Set<string>();\n    this.nodeZExtent = [Infinity, -Infinity];\n  }\n\n  /**\n   * Clear all indices related to edges.\n   * @private\n   */\n  private clearEdgeIndices(): void {\n    this.edgeDataCache = {};\n    this.edgeProgramIndex = {};\n    this.edgesWithForcedLabels = new Set<string>();\n    this.edgeZExtent = [Infinity, -Infinity];\n  }\n\n  /**\n   * Clear all indices.\n   * @private\n   */\n  private clearIndices(): void {\n    this.clearEdgeIndices();\n    this.clearNodeIndices();\n  }\n\n  /**\n   * Clear all graph state related to nodes.\n   * @private\n   */\n  private clearNodeState(): void {\n    this.displayedNodeLabels = new Set();\n    this.highlightedNodes = new Set();\n    this.hoveredNode = null;\n  }\n\n  /**\n   * Clear all graph state related to edges.\n   * @private\n   */\n  private clearEdgeState(): void {\n    this.displayedEdgeLabels = new Set();\n    this.highlightedNodes = new Set();\n    this.hoveredEdge = null;\n  }\n\n  /**\n   * Clear all graph state.\n   * @private\n   */\n  private clearState(): void {\n    this.clearEdgeState();\n    this.clearNodeState();\n  }\n\n  /**\n   * Add the node data to its program.\n   * @private\n   * @param node The node's graphology ID\n   * @param fingerprint A fingerprint used to identity the node with picking\n   * @param position The index where to place the node in the program\n   */\n  private addNodeToProgram(node: string, fingerprint: number, position: number): void {\n    const data = this.nodeDataCache[node];\n    const nodeProgram = this.nodePrograms[data.type];\n    if (!nodeProgram) throw new Error(`Sigma: could not find a suitable program for node type \"${data.type}\"!`);\n    nodeProgram.process(fingerprint, position, data);\n    // Saving program index\n    this.nodeProgramIndex[node] = position;\n  }\n\n  /**\n   * Add the edge data to its program.\n   * @private\n   * @param edge The edge's graphology ID\n   * @param fingerprint A fingerprint used to identity the edge with picking\n   * @param position The index where to place the edge in the program\n   */\n  private addEdgeToProgram(edge: string, fingerprint: number, position: number): void {\n    const data = this.edgeDataCache[edge];\n    const edgeProgram = this.edgePrograms[data.type];\n    if (!edgeProgram) throw new Error(`Sigma: could not find a suitable program for edge type \"${data.type}\"!`);\n    const extremities = this.graph.extremities(edge),\n      sourceData = this.nodeDataCache[extremities[0]],\n      targetData = this.nodeDataCache[extremities[1]];\n    edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n    // Saving program index\n    this.edgeProgramIndex[edge] = position;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Public API.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the renderer's camera.\n   *\n   * @return {Camera}\n   */\n  getCamera(): Camera {\n    return this.camera;\n  }\n\n  /**\n   * Method setting the renderer's camera.\n   *\n   * @param  {Camera} camera - New camera.\n   * @return {Sigma}\n   */\n  setCamera(camera: Camera): void {\n    this.unbindCameraHandlers();\n    this.camera = camera;\n    this.bindCameraHandlers();\n  }\n\n  /**\n   * Method returning the container DOM element.\n   *\n   * @return {HTMLElement}\n   */\n  getContainer(): HTMLElement {\n    return this.container;\n  }\n\n  /**\n   * Method returning the renderer's graph.\n   *\n   * @return {Graph}\n   */\n  getGraph(): GraphType {\n    return this.graph;\n  }\n\n  /**\n   * Method used to set the renderer's graph.\n   *\n   * @return {Graph}\n   */\n  setGraph(graph: GraphType): void {\n    if (graph === this.graph) return;\n\n    // Unbinding handlers on the current graph\n    this.unbindGraphHandlers();\n\n    if (this.checkEdgesEventsFrame !== null) {\n      cancelFrame(this.checkEdgesEventsFrame);\n      this.checkEdgesEventsFrame = null;\n    }\n\n    // Installing new graph\n    this.graph = graph;\n\n    // Binding new handlers\n    this.bindGraphHandlers();\n\n    // Re-rendering now to avoid discrepancies from now to next frame\n    this.refresh();\n  }\n\n  /**\n   * Method returning the mouse captor.\n   *\n   * @return {MouseCaptor}\n   */\n  getMouseCaptor(): MouseCaptor {\n    return this.mouseCaptor;\n  }\n\n  /**\n   * Method returning the touch captor.\n   *\n   * @return {TouchCaptor}\n   */\n  getTouchCaptor(): TouchCaptor {\n    return this.touchCaptor;\n  }\n\n  /**\n   * Method returning the current renderer's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  getDimensions(): Dimensions {\n    return { width: this.width, height: this.height };\n  }\n\n  /**\n   * Method returning the current graph's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  getGraphDimensions(): Dimensions {\n    const extent = this.customBBox || this.nodeExtent;\n\n    return {\n      width: extent.x[1] - extent.x[0] || 1,\n      height: extent.y[1] - extent.y[0] || 1,\n    };\n  }\n\n  /**\n   * Method used to get all the sigma node attributes.\n   * It's usefull for example to get the position of a node\n   * and to get values that are set by the nodeReducer\n   *\n   * @param  {string} key - The node's key.\n   * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n   */\n  getNodeDisplayData(key: unknown): NodeDisplayData | undefined {\n    const node = this.nodeDataCache[key as string];\n    return node ? Object.assign({}, node) : undefined;\n  }\n\n  /**\n   * Method used to get all the sigma edge attributes.\n   * It's useful for example to get values that are set by the edgeReducer.\n   *\n   * @param  {string} key - The edge's key.\n   * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n   */\n  getEdgeDisplayData(key: unknown): EdgeDisplayData | undefined {\n    const edge = this.edgeDataCache[key as string];\n    return edge ? Object.assign({}, edge) : undefined;\n  }\n\n  /**\n   * Method used to get the set of currently displayed node labels.\n   *\n   * @return {Set<string>} A set of node keys whose label is displayed.\n   */\n  getNodeDisplayedLabels(): Set<string> {\n    return new Set(this.displayedNodeLabels);\n  }\n\n  /**\n   * Method used to get the set of currently displayed edge labels.\n   *\n   * @return {Set<string>} A set of edge keys whose label is displayed.\n   */\n  getEdgeDisplayedLabels(): Set<string> {\n    return new Set(this.displayedEdgeLabels);\n  }\n\n  /**\n   * Method returning a copy of the settings collection.\n   *\n   * @return {Settings} A copy of the settings collection.\n   */\n  getSettings(): Settings {\n    return { ...this.settings };\n  }\n\n  /**\n   * Method returning the current value for a given setting key.\n   *\n   * @param  {string} key - The setting key to get.\n   * @return {any} The value attached to this setting key or undefined if not found\n   */\n  getSetting<K extends keyof Settings>(key: K): Settings[K] | undefined {\n    return this.settings[key];\n  }\n\n  /**\n   * Method setting the value of a given setting key. Note that this will schedule\n   * a new render next frame.\n   *\n   * @param  {string} key - The setting key to set.\n   * @param  {any}    value - The value to set.\n   * @return {Sigma}\n   */\n  setSetting<K extends keyof Settings>(key: K, value: Settings[K]): this {\n    this.settings[key] = value;\n    validateSettings(this.settings);\n    this.handleSettingsUpdate();\n    this.refresh();\n    return this;\n  }\n\n  /**\n   * Method updating the value of a given setting key using the provided function.\n   * Note that this will schedule a new render next frame.\n   *\n   * @param  {string}   key     - The setting key to set.\n   * @param  {function} updater - The update function.\n   * @return {Sigma}\n   */\n  updateSetting<K extends keyof Settings>(key: K, updater: (value: Settings[K]) => Settings[K]): this {\n    this.settings[key] = updater(this.settings[key]);\n    validateSettings(this.settings);\n    this.handleSettingsUpdate();\n    this.scheduleRefresh();\n    return this;\n  }\n\n  /**\n   * Method used to resize the renderer.\n   *\n   * @return {Sigma}\n   */\n  resize(): this {\n    const previousWidth = this.width,\n      previousHeight = this.height;\n\n    this.width = this.container.offsetWidth;\n    this.height = this.container.offsetHeight;\n    this.pixelRatio = getPixelRatio();\n\n    if (this.width === 0) {\n      if (this.settings.allowInvalidContainer) this.width = 1;\n      else\n        throw new Error(\n          \"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\",\n        );\n    }\n\n    if (this.height === 0) {\n      if (this.settings.allowInvalidContainer) this.height = 1;\n      else\n        throw new Error(\n          \"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\",\n        );\n    }\n\n    // If nothing has changed, we can stop right here\n    if (previousWidth === this.width && previousHeight === this.height) return this;\n\n    this.emit(\"resize\");\n\n    // Sizing dom elements\n    for (const id in this.elements) {\n      const element = this.elements[id];\n\n      element.style.width = this.width + \"px\";\n      element.style.height = this.height + \"px\";\n    }\n\n    // Sizing canvas contexts\n    for (const id in this.canvasContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n\n      if (this.pixelRatio !== 1) this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);\n    }\n\n    // Sizing WebGL contexts\n    for (const id in this.webGLContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n\n      const gl = this.webGLContexts[id];\n      gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n      // Clear picking texture if needed\n      if (this.pickingLayers.has(id)) {\n        const currentTexture = this.textures[id];\n        if (currentTexture) gl.deleteTexture(currentTexture);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to clear all the canvases.\n   *\n   * @return {Sigma}\n   */\n  clear(): this {\n    this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n    this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n    this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n    this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n    this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n    this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n\n    return this;\n  }\n\n  /**\n   * Method used to refresh, i.e. force the renderer to reprocess graph\n   * data and render, but keep the state.\n   * - if a partialGraph is provided, we only reprocess those nodes & edges.\n   * - if schedule is TRUE, we schedule a render instead of sync render\n   * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n   *\n   * @return {Sigma}\n   */\n  refresh(opts?: {\n    partialGraph?: { nodes?: string[]; edges?: string[] };\n    schedule?: boolean;\n    skipIndexation?: boolean;\n  }): this {\n    const skipIndexation = opts?.skipIndexation !== undefined ? opts?.skipIndexation : false;\n    const schedule = opts?.schedule !== undefined ? opts.schedule : false;\n    const fullRefresh = !opts || !opts.partialGraph;\n\n    if (fullRefresh) {\n      // Re-index graph data\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n      this.graph.forEachNode((node) => this.addNode(node));\n      this.graph.forEachEdge((edge) => this.addEdge(edge));\n    } else {\n      const nodes = opts.partialGraph?.nodes || [];\n      for (let i = 0, l = nodes?.length || 0; i < l; i++) {\n        const node = nodes[i];\n        // Recompute node's data (ie. apply reducer)\n        this.updateNode(node);\n        // Add node to the program if layout is unchanged.\n        // otherwise it will be done in the process function\n        if (skipIndexation) {\n          const programIndex = this.nodeProgramIndex[node];\n          if (programIndex === undefined) throw new Error(`Sigma: node \"${node}\" can't be repaint`);\n          this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n        }\n      }\n\n      const edges = opts?.partialGraph?.edges || [];\n      for (let i = 0, l = edges.length; i < l; i++) {\n        const edge = edges[i];\n        // Recompute edge's data (ie. apply reducer)\n        this.updateEdge(edge);\n        // Add edge to the program\n        // otherwise it will be done in the process function\n        if (skipIndexation) {\n          const programIndex = this.edgeProgramIndex[edge];\n          if (programIndex === undefined) throw new Error(`Sigma: edge \"${edge}\" can't be repaint`);\n          this.addEdgeToProgram(edge, this.edgeIndices[edge], programIndex);\n        }\n      }\n    }\n\n    // Do we need to call the process function ?\n    if (fullRefresh || !skipIndexation) this.needToProcess = true;\n\n    if (schedule) this.scheduleRender();\n    else this.render();\n\n    return this;\n  }\n\n  /**\n   * Method used to schedule a render at the next available frame.\n   * This method can be safely called on a same frame because it basically\n   * debounces refresh to the next frame.\n   *\n   * @return {Sigma}\n   */\n  scheduleRender(): this {\n    if (!this.renderFrame) {\n      this.renderFrame = requestFrame(() => {\n        this.render();\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n   * at the next available frame.\n   * This method can be safely called on a same frame because it basically\n   * debounces refresh to the next frame.\n   *\n   * @return {Sigma}\n   */\n  scheduleRefresh(opts?: { partialGraph?: { nodes?: string[]; edges?: string[] }; layoutUnchange?: boolean }): this {\n    return this.refresh({ ...opts, schedule: true });\n  }\n\n  /**\n   * Method used to (un)zoom, while preserving the position of a viewport point.\n   * Used for instance to zoom \"on the mouse cursor\".\n   *\n   * @param viewportTarget\n   * @param newRatio\n   * @return {CameraState}\n   */\n  getViewportZoomedState(viewportTarget: Coordinates, newRatio: number): CameraState {\n    const { ratio, angle, x, y } = this.camera.getState();\n\n    // TODO: handle max zoom\n    const ratioDiff = newRatio / ratio;\n\n    const center = {\n      x: this.width / 2,\n      y: this.height / 2,\n    };\n\n    const graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n    const graphCenterPosition = this.viewportToFramedGraph(center);\n\n    return {\n      angle,\n      x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n      y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n      ratio: newRatio,\n    };\n  }\n\n  /**\n   * Method returning the abstract rectangle containing the graph according\n   * to the camera's state.\n   *\n   * @return {object} - The view's rectangle.\n   */\n  viewRectangle(): {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    height: number;\n  } {\n    // TODO: reduce relative margin?\n    const marginX = (0 * this.width) / 8,\n      marginY = (0 * this.height) / 8;\n\n    const p1 = this.viewportToFramedGraph({ x: 0 - marginX, y: 0 - marginY }),\n      p2 = this.viewportToFramedGraph({ x: this.width + marginX, y: 0 - marginY }),\n      h = this.viewportToFramedGraph({ x: 0, y: this.height + marginY });\n\n    return {\n      x1: p1.x,\n      y1: p1.y,\n      x2: p2.x,\n      y2: p2.y,\n      height: p2.y - h.y,\n    };\n  }\n\n  /**\n   * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  framedGraphToViewport(coordinates: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    const recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n    const matrix = override.matrix\n      ? override.matrix\n      : recomputeMatrix\n        ? matrixFromCamera(\n            override.cameraState || this.camera.getState(),\n            override.viewportDimensions || this.getDimensions(),\n            override.graphDimensions || this.getGraphDimensions(),\n            override.padding || this.getSetting(\"stagePadding\") || 0,\n          )\n        : this.matrix;\n\n    const viewportPos = multiplyVec2(matrix, coordinates);\n\n    return {\n      x: ((1 + viewportPos.x) * this.width) / 2,\n      y: ((1 - viewportPos.y) * this.height) / 2,\n    };\n  }\n\n  /**\n   * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  viewportToFramedGraph(coordinates: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    const recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n    const invMatrix = override.matrix\n      ? override.matrix\n      : recomputeMatrix\n        ? matrixFromCamera(\n            override.cameraState || this.camera.getState(),\n            override.viewportDimensions || this.getDimensions(),\n            override.graphDimensions || this.getGraphDimensions(),\n            override.padding || this.getSetting(\"stagePadding\") || 0,\n            true,\n          )\n        : this.invMatrix;\n\n    const res = multiplyVec2(invMatrix, {\n      x: (coordinates.x / this.width) * 2 - 1,\n      y: 1 - (coordinates.y / this.height) * 2,\n    });\n\n    if (isNaN(res.x)) res.x = 0;\n    if (isNaN(res.y)) res.y = 0;\n\n    return res;\n  }\n\n  /**\n   * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n   * stage) to the graph system (the reference system of data as they are in the given graph instance).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  viewportPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  viewportToGraph(viewportPoint: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n  }\n\n  /**\n   * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n   * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  graphPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  graphToViewport(graphPoint: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n  }\n\n  /**\n   * Method returning the distance multiplier between the graph system and the\n   * viewport system.\n   */\n  getGraphToViewportRatio(): number {\n    const graphP1 = { x: 0, y: 0 };\n    const graphP2 = { x: 1, y: 1 };\n    const graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n\n    const viewportP1 = this.graphToViewport(graphP1);\n    const viewportP2 = this.graphToViewport(graphP2);\n    const viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n\n    return viewportD / graphD;\n  }\n\n  /**\n   * Method returning the graph's bounding box.\n   *\n   * @return {{ x: Extent, y: Extent }}\n   */\n  getBBox(): { x: Extent; y: Extent } {\n    return this.nodeExtent;\n  }\n\n  /**\n   * Method returning the graph's custom bounding box, if any.\n   *\n   * @return {{ x: Extent, y: Extent } | null}\n   */\n  getCustomBBox(): { x: Extent; y: Extent } | null {\n    return this.customBBox;\n  }\n\n  /**\n   * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n   *\n   * @return {Sigma}\n   */\n  setCustomBBox(customBBox: { x: Extent; y: Extent } | null): this {\n    this.customBBox = customBBox;\n    this.scheduleRender();\n    return this;\n  }\n\n  /**\n   * Method used to shut the container & release event listeners.\n   *\n   * @return {undefined}\n   */\n  kill(): void {\n    // Emitting \"kill\" events so that plugins and such can cleanup\n    this.emit(\"kill\");\n\n    // Releasing events\n    this.removeAllListeners();\n\n    // Releasing camera handlers\n    this.unbindCameraHandlers();\n\n    // Releasing DOM events & captors\n    window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n    this.mouseCaptor.kill();\n    this.touchCaptor.kill();\n\n    // Releasing graph handlers\n    this.unbindGraphHandlers();\n\n    // Releasing cache & state\n    this.clearIndices();\n    this.clearState();\n\n    this.nodeDataCache = {};\n    this.edgeDataCache = {};\n\n    this.highlightedNodes.clear();\n\n    // Clearing frames\n    if (this.renderFrame) {\n      cancelFrame(this.renderFrame);\n      this.renderFrame = null;\n    }\n\n    if (this.renderHighlightedNodesFrame) {\n      cancelFrame(this.renderHighlightedNodesFrame);\n      this.renderHighlightedNodesFrame = null;\n    }\n\n    // Destroying WebGL contexts\n    for (const id in this.webGLContexts) {\n      const context = this.webGLContexts[id];\n      context.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    }\n\n    // Destroying canvases\n    const container = this.container;\n\n    while (container.firstChild) container.removeChild(container.firstChild);\n\n    // Destroying remaining collections\n    this.canvasContexts = {};\n    this.webGLContexts = {};\n    this.elements = {};\n\n    this.nodePrograms = {};\n    this.nodeHoverPrograms = {};\n    this.edgePrograms = {};\n  }\n\n  /**\n   * Method used to scale the given size according to the camera's ratio, i.e.\n   * zooming state.\n   *\n   * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n   * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n   * @return {number}              - The scaled size.\n   */\n  scaleSize(size = 1, cameraRatio = this.camera.ratio): number {\n    return (\n      (size / this.settings.zoomToSizeRatioFunction(cameraRatio)) *\n      (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1)\n    );\n  }\n\n  /**\n   * Method that returns the collection of all used canvases.\n   * At the moment, the instantiated canvases are the following, and in the\n   * following order in the DOM:\n   * - `edges`\n   * - `nodes`\n   * - `edgeLabels`\n   * - `labels`\n   * - `hovers`\n   * - `hoverNodes`\n   * - `mouse`\n   *\n   * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n   */\n  getCanvases(): PlainObject<HTMLCanvasElement> {\n    return { ...this.elements };\n  }\n}\n"],"names":["isGraph","value","identity","scale","m","x","y","rotate","r","s","c","translate","multiply","a","b","a00","a01","a02","a10","a11","a12","a20","a21","a22","b00","b01","b02","b10","b11","b12","b20","b21","b22","multiplyVec2","z","b0","b1","HTML_COLORS","assign","target","objects","i","l","o","requestFrame","callback","cancelFrame","requestID","createElement","tag","style","attributes","element","k","getPixelRatio","graphExtent","graph","xMin","xMax","yMin","yMax","_","attr","createNormalizationFunction","extent","minX","maxX","minY","maxY","ratio","dX","dY","fn","data","zIndexOrdering","_extent","getter","elements","zA","zB","INT8","INT32","FLOAT32","RGBA_TEST_REGEX","RGBA_EXTRACT_REGEX","parseColor","val","g","match","FLOAT_COLOR_CACHE","htmlColor","floatColor","rgbaToFloat","masking","parsed","color","FLOAT_INDEX_CACHE","indexToColor","index","colorToIndex","_a","getCorrectionRatio","viewportDimensions","graphDimensions","viewportRatio","graphRatio","matrixFromCamera","state","padding","inverse","angle","width","height","matrix","smallestDimension","correctionRatio","getMatrixImpact","cameraState","validateGraph","key","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","easings","ANIMATE_DEFAULTS","R","ReflectApply","receiver","args","ReflectOwnKeys","ProcessEmitWarning","warning","NumberIsNaN","EventEmitter","eventsModule","once","defaultMaxListeners","checkListener","listener","arg","n","_getMaxListeners","that","type","doError","events","er","err","handler","len","listeners","arrayClone","_addListener","prepend","existing","w","onceWrapper","_onceWrap","wrapped","list","position","originalListener","spliceOne","keys","_listeners","unwrap","evlistener","unwrapListeners","emitter","listenerCount","arr","copy","ret","name","resolve","reject","errorListener","resolver","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","wrapListener","TypedEventEmitter","DEFAULT_ZOOMING_RATIO","Camera","validatedState","validState","updater","opts","options","easing","start","initialState","t","coefficient","newState","factorOrOptions","getPosition","e","dom","bbox","getMouseCoords","res","getWheelCoords","getWheelDelta","MAX_TOUCHES","getTouchesArray","touches","getTouchCoords","touch","Captor","container","renderer","DRAG_TIMEOUT","DRAGGED_EVENTS_TOLERANCE","MOUSE_INERTIA_DURATION","MOUSE_INERTIA_RATIO","MOUSE_ZOOM_DURATION","ZOOMING_RATIO","DOUBLE_CLICK_TIMEOUT","DOUBLE_CLICK_ZOOMING_RATIO","DOUBLE_CLICK_ZOOMING_DURATION","MouseCaptor","mouseCoords","camera","newRatio","previousCameraState","shouldRefresh","eX","eY","lastMouse","mouse","offsetX","offsetY","delta","wheelCoords","ratioDiff","wheelDirection","now","LabelCandidate","size","first","second","LabelGrid","dimensions","cellSize","pos","xIndex","candidate","cell","density","cellArea","scaledDensity","labelsToDisplayPerCell","labels","edgeLabelsToDisplayFromNodes","params","hoveredNode","highlightedNodes","displayedNodeLabels","worthyEdges","edge","source","loadShader","gl","glType","shader","infoLog","loadVertexShader","loadFragmentShader","loadProgram","shaders","program","PICKING_PREFIX","SIZE_FACTOR_PER_ATTRIBUTE_TYPE","getAttributeItemsCount","getAttributesItemsCount","attrs","Program","pickingBuffer","def","constantAttributesItemsCount","vector","j","vertexShaderSource","fragmentShaderSource","frameBuffer","buffer","vertexShader","fragmentShader","uniformLocations","uniformName","location","attributeLocations","constantBuffer","offset","setDivisor","sizeFactor","stride","ext","unsetDivisor","capacity","programInfo","method","_NodeProgram","nodeIndex","NodeProgram","_NodeImageClass","_gl","_pickingBuffer","_renderer","_capacity","_nodeIndex","_offset","_data","_params","NodeImageClass","vert_default","frag_default","UNSIGNED_BYTE","FLOAT","UNIFORMS","NodePointProgram","VERTEX_SHADER_SOURCE","FRAGMENT_SHADER_SOURCE","startIndex","array","sizeRatio","pixelRatio","u_sizeRatio","u_pixelRatio","u_matrix","_EdgeProgram","edgeIndex","sourceData","targetData","EdgeProgram","_EdgeImageClass","_edgeIndex","_sourceData","_targetData","EdgeImageClass","createEdgeCompoundProgram","programClasses","drawLabel","EdgeRectangleProgram","thickness","x1","y1","x2","y2","dx","dy","n1","n2","u_zoomRatio","u_correctionRatio","EdgeArrowHeadProgram","radius","EdgeClampedProgram","EdgeArrowProgram","drawStraightEdgeLabel","context","edgeData","settings","font","weight","label","sSize","tSize","sx","sy","tx","ty","cx","cy","d","textLength","ellipsis","drawDiscNodeLabel","drawDiscNodeHover","PADDING","textWidth","boxWidth","boxHeight","angleRadian","xDeltaCoord","DEFAULT_SETTINGS","DEFAULT_NODE_PROGRAM_CLASSES","DEFAULT_EDGE_PROGRAM_CLASSES","validateSettings","minCameraRatio","maxCameraRatio","resolveSettings","resolvedSettings","TOUCH_INERTIA_RATIO","TOUCH_INERTIA_DURATION","TouchCaptor","mousePosition","mouseEvent","x0","y0","touchesPositions","idx","startPosition","startCameraState","xStart","yStart","newCameraState","angleDiff","touchGraphPosition","extend","values","l2","l1","getPixelColor","downSizingRatio","bufferX","bufferY","pixel","X_LABEL_MARGIN","Y_LABEL_MARGIN","applyNodeDefaults","applyEdgeDefaults","_key","Sigma","NodeProgramClass","NodeHoverProgram","EdgeProgramClass","id","canvas","contextOptions","newFrameBuffer","currentTexture","pickingTexture","itemAt","baseEvent","nodeToHover","node","createMouseListener","eventType","nodeAtPosition","LAYOUT_IMPACTING_FIELDS","updatedFields","layoutChanged","f","payload","edgeToHover","nullCamera","nullCameraMatrix","nodesPerPrograms","nodeIndices","edgeIndices","itemIDsIndex","incrID","nodes","edgesPerPrograms","edges","labelsToDisplay","nodeProgramClasses","defaultDrawNodeLabel","edgeLabelsToDisplay","displayedLabels","extremities","edgeProgramClasses","defaultDrawEdgeLabel","render","defaultDrawNodeHover","nodesToRender","exitRender","layer","mouseCaptor","moving","fingerprint","nodeProgram","edgeProgram","previousWidth","previousHeight","skipIndexation","schedule","fullRefresh","programIndex","_b","viewportTarget","center","graphMousePosition","graphCenterPosition","marginX","marginY","p1","p2","h","coordinates","override","recomputeMatrix","viewportPos","invMatrix","viewportPoint","graphPoint","graphP1","graphP2","graphD","viewportP1","viewportP2","customBBox","cameraRatio"],"mappings":"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","x_google_ignoreList":[0,6]}