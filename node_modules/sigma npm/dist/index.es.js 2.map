{"version":3,"file":"index.es.js","sources":["../../../node_modules/graphology-utils/is-graph.js","../src/utils/matrices.ts","../src/utils/data.ts","../src/utils/index.ts","../src/utils/easings.ts","../src/utils/animate.ts","../../../node_modules/events/events.js","../src/types.ts","../src/core/camera.ts","../src/core/captors/captor.ts","../src/core/captors/mouse.ts","../src/core/labels.ts","../src/rendering/utils.ts","../src/rendering/program.ts","../src/rendering/node.ts","../src/rendering/programs/node-point/vert.glsl","../src/rendering/programs/node-point/frag.glsl","../src/rendering/programs/node-point/index.ts","../src/rendering/edge.ts","../src/rendering/programs/edge-rectangle/vert.glsl","../src/rendering/programs/edge-rectangle/frag.glsl","../src/rendering/programs/edge-rectangle/index.ts","../src/rendering/programs/edge-arrow-head/vert.glsl","../src/rendering/programs/edge-arrow-head/frag.glsl","../src/rendering/programs/edge-arrow-head/index.ts","../src/rendering/programs/edge-clamped/vert.glsl","../src/rendering/programs/edge-clamped/index.ts","../src/rendering/programs/edge-arrow/index.ts","../src/rendering/edge-labels.ts","../src/rendering/node-labels.ts","../src/rendering/node-hover.ts","../src/settings.ts","../src/core/captors/touch.ts","../src/utils/array.ts","../src/utils/picking.ts","../src/sigma.ts"],"sourcesContent":["/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n","/**\n * Sigma.js WebGL Matrices Helpers\n * ================================\n *\n * Matrices-related helper functions used by sigma's WebGL renderer.\n * @module\n */\nimport { Coordinates } from \"../types\";\n\nexport function identity(): Float32Array {\n  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);\n}\n\n// TODO: optimize\nexport function scale(m: Float32Array, x: number, y?: number): Float32Array {\n  m[0] = x;\n  m[4] = typeof y === \"number\" ? y : x;\n\n  return m;\n}\n\nexport function rotate(m: Float32Array, r: number): Float32Array {\n  const s = Math.sin(r),\n    c = Math.cos(r);\n\n  m[0] = c;\n  m[1] = s;\n  m[3] = -s;\n  m[4] = c;\n\n  return m;\n}\n\nexport function translate(m: Float32Array, x: number, y: number): Float32Array {\n  m[6] = x;\n  m[7] = y;\n\n  return m;\n}\n\nexport function multiply<T extends number[] | Float32Array>(a: T, b: Float32Array | number[]): T {\n  const a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  const a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  const a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n\n  const b00 = b[0],\n    b01 = b[1],\n    b02 = b[2];\n  const b10 = b[3],\n    b11 = b[4],\n    b12 = b[5];\n  const b20 = b[6],\n    b21 = b[7],\n    b22 = b[8];\n\n  a[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  a[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  a[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n  a[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  a[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  a[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n  a[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  a[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  a[8] = b20 * a02 + b21 * a12 + b22 * a22;\n\n  return a;\n}\n\nexport function multiplyVec2(a: Float32Array | number[], b: Coordinates, z = 1): Coordinates {\n  const a00 = a[0];\n  const a01 = a[1];\n  const a10 = a[3];\n  const a11 = a[4];\n  const a20 = a[6];\n  const a21 = a[7];\n\n  const b0 = b.x;\n  const b1 = b.y;\n\n  return { x: b0 * a00 + b1 * a10 + a20 * z, y: b0 * a01 + b1 * a11 + a21 * z };\n}\n","export const HTML_COLORS: Record<string, string> = {\n  black: \"#000000\",\n  silver: \"#C0C0C0\",\n  gray: \"#808080\",\n  grey: \"#808080\",\n  white: \"#FFFFFF\",\n  maroon: \"#800000\",\n  red: \"#FF0000\",\n  purple: \"#800080\",\n  fuchsia: \"#FF00FF\",\n  green: \"#008000\",\n  lime: \"#00FF00\",\n  olive: \"#808000\",\n  yellow: \"#FFFF00\",\n  navy: \"#000080\",\n  blue: \"#0000FF\",\n  teal: \"#008080\",\n  aqua: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  mediumblue: \"#0000CD\",\n  darkgreen: \"#006400\",\n  darkcyan: \"#008B8B\",\n  deepskyblue: \"#00BFFF\",\n  darkturquoise: \"#00CED1\",\n  mediumspringgreen: \"#00FA9A\",\n  springgreen: \"#00FF7F\",\n  cyan: \"#00FFFF\",\n  midnightblue: \"#191970\",\n  dodgerblue: \"#1E90FF\",\n  lightseagreen: \"#20B2AA\",\n  forestgreen: \"#228B22\",\n  seagreen: \"#2E8B57\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  limegreen: \"#32CD32\",\n  mediumseagreen: \"#3CB371\",\n  turquoise: \"#40E0D0\",\n  royalblue: \"#4169E1\",\n  steelblue: \"#4682B4\",\n  darkslateblue: \"#483D8B\",\n  mediumturquoise: \"#48D1CC\",\n  indigo: \"#4B0082\",\n  darkolivegreen: \"#556B2F\",\n  cadetblue: \"#5F9EA0\",\n  cornflowerblue: \"#6495ED\",\n  rebeccapurple: \"#663399\",\n  mediumaquamarine: \"#66CDAA\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  slateblue: \"#6A5ACD\",\n  olivedrab: \"#6B8E23\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  mediumslateblue: \"#7B68EE\",\n  lawngreen: \"#7CFC00\",\n  chartreuse: \"#7FFF00\",\n  aquamarine: \"#7FFFD4\",\n  skyblue: \"#87CEEB\",\n  lightskyblue: \"#87CEFA\",\n  blueviolet: \"#8A2BE2\",\n  darkred: \"#8B0000\",\n  darkmagenta: \"#8B008B\",\n  saddlebrown: \"#8B4513\",\n  darkseagreen: \"#8FBC8F\",\n  lightgreen: \"#90EE90\",\n  mediumpurple: \"#9370DB\",\n  darkviolet: \"#9400D3\",\n  palegreen: \"#98FB98\",\n  darkorchid: \"#9932CC\",\n  yellowgreen: \"#9ACD32\",\n  sienna: \"#A0522D\",\n  brown: \"#A52A2A\",\n  darkgray: \"#A9A9A9\",\n  darkgrey: \"#A9A9A9\",\n  lightblue: \"#ADD8E6\",\n  greenyellow: \"#ADFF2F\",\n  paleturquoise: \"#AFEEEE\",\n  lightsteelblue: \"#B0C4DE\",\n  powderblue: \"#B0E0E6\",\n  firebrick: \"#B22222\",\n  darkgoldenrod: \"#B8860B\",\n  mediumorchid: \"#BA55D3\",\n  rosybrown: \"#BC8F8F\",\n  darkkhaki: \"#BDB76B\",\n  mediumvioletred: \"#C71585\",\n  indianred: \"#CD5C5C\",\n  peru: \"#CD853F\",\n  chocolate: \"#D2691E\",\n  tan: \"#D2B48C\",\n  lightgray: \"#D3D3D3\",\n  lightgrey: \"#D3D3D3\",\n  thistle: \"#D8BFD8\",\n  orchid: \"#DA70D6\",\n  goldenrod: \"#DAA520\",\n  palevioletred: \"#DB7093\",\n  crimson: \"#DC143C\",\n  gainsboro: \"#DCDCDC\",\n  plum: \"#DDA0DD\",\n  burlywood: \"#DEB887\",\n  lightcyan: \"#E0FFFF\",\n  lavender: \"#E6E6FA\",\n  darksalmon: \"#E9967A\",\n  violet: \"#EE82EE\",\n  palegoldenrod: \"#EEE8AA\",\n  lightcoral: \"#F08080\",\n  khaki: \"#F0E68C\",\n  aliceblue: \"#F0F8FF\",\n  honeydew: \"#F0FFF0\",\n  azure: \"#F0FFFF\",\n  sandybrown: \"#F4A460\",\n  wheat: \"#F5DEB3\",\n  beige: \"#F5F5DC\",\n  whitesmoke: \"#F5F5F5\",\n  mintcream: \"#F5FFFA\",\n  ghostwhite: \"#F8F8FF\",\n  salmon: \"#FA8072\",\n  antiquewhite: \"#FAEBD7\",\n  linen: \"#FAF0E6\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  oldlace: \"#FDF5E6\",\n  magenta: \"#FF00FF\",\n  deeppink: \"#FF1493\",\n  orangered: \"#FF4500\",\n  tomato: \"#FF6347\",\n  hotpink: \"#FF69B4\",\n  coral: \"#FF7F50\",\n  darkorange: \"#FF8C00\",\n  lightsalmon: \"#FFA07A\",\n  orange: \"#FFA500\",\n  lightpink: \"#FFB6C1\",\n  pink: \"#FFC0CB\",\n  gold: \"#FFD700\",\n  peachpuff: \"#FFDAB9\",\n  navajowhite: \"#FFDEAD\",\n  moccasin: \"#FFE4B5\",\n  bisque: \"#FFE4C4\",\n  mistyrose: \"#FFE4E1\",\n  blanchedalmond: \"#FFEBCD\",\n  papayawhip: \"#FFEFD5\",\n  lavenderblush: \"#FFF0F5\",\n  seashell: \"#FFF5EE\",\n  cornsilk: \"#FFF8DC\",\n  lemonchiffon: \"#FFFACD\",\n  floralwhite: \"#FFFAF0\",\n  snow: \"#FFFAFA\",\n  lightyellow: \"#FFFFE0\",\n  ivory: \"#FFFFF0\",\n};\n","/**\n * Sigma.js Utils\n * ===============\n *\n * Various helper functions & classes used throughout the library.\n * @module\n */\nimport Graph, { Attributes } from \"graphology-types\";\nimport isGraph from \"graphology-utils/is-graph\";\nimport { CameraState, Coordinates, Dimensions, Extent, PlainObject } from \"../types\";\nimport { multiply, identity, scale, rotate, translate, multiplyVec2 } from \"./matrices\";\nimport { HTML_COLORS } from \"./data\";\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nexport function isPlainObject(value: any): boolean {\n  return typeof value === \"object\" && value !== null && value.constructor === Object;\n}\n\n/**\n * Helper to use Object.assign with more than two objects.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexport function assign<T>(target: Partial<T> | undefined, ...objects: Array<Partial<T | undefined>>): T {\n  target = target || {};\n\n  for (let i = 0, l = objects.length; i < l; i++) {\n    const o = objects[i];\n\n    if (!o) continue;\n\n    Object.assign(target, o);\n  }\n\n  return target as T;\n}\n\n/**\n * Very simple recursive Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexport function assignDeep<T>(target: Partial<T> | undefined, ...objects: Array<Partial<T | undefined>>): T {\n  target = target || {};\n\n  for (let i = 0, l = objects.length; i < l; i++) {\n    const o = objects[i];\n\n    if (!o) continue;\n\n    for (const k in o) {\n      if (isPlainObject(o[k])) {\n        target[k] = assignDeep(target[k], o[k]);\n      } else {\n        target[k] = o[k];\n      }\n    }\n  }\n\n  return target as T;\n}\n\n/**\n * Just some dirty trick to make requestAnimationFrame and cancelAnimationFrame \"work\" in Node.js, for unit tests:\n */\nexport const requestFrame =\n  typeof requestAnimationFrame !== \"undefined\"\n    ? (callback: FrameRequestCallback) => requestAnimationFrame(callback)\n    : (callback: FrameRequestCallback) => setTimeout(callback, 0);\nexport const cancelFrame =\n  typeof cancelAnimationFrame !== \"undefined\"\n    ? (requestID: number) => cancelAnimationFrame(requestID)\n    : (requestID: number) => clearTimeout(requestID);\n\n/**\n * Function used to create DOM elements easily.\n *\n * @param  {string} tag        - Tag name of the element to create.\n * @param  {object} style      - Styles map.\n * @param  {object} attributes - Attributes map.\n * @return {HTMLElement}\n */\nexport function createElement<T extends HTMLElement>(\n  tag: string,\n  style?: Partial<CSSStyleDeclaration>,\n  attributes?: PlainObject<string>,\n): T {\n  const element: T = document.createElement(tag) as T;\n\n  if (style) {\n    for (const k in style) {\n      element.style[k] = style[k] as string;\n    }\n  }\n\n  if (attributes) {\n    for (const k in attributes) {\n      element.setAttribute(k, attributes[k]);\n    }\n  }\n\n  return element;\n}\n\n/**\n * Function returning the browser's pixel ratio.\n *\n * @return {number}\n */\nexport function getPixelRatio(): number {\n  if (typeof window.devicePixelRatio !== \"undefined\") return window.devicePixelRatio;\n\n  return 1;\n}\n\n/**\n * Function returning the graph's node extent in x & y.\n *\n * @param  {Graph}\n * @return {object}\n */\nexport function graphExtent(graph: Graph): { x: Extent; y: Extent } {\n  if (!graph.order) return { x: [0, 1], y: [0, 1] };\n\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let yMin = Infinity;\n  let yMax = -Infinity;\n\n  graph.forEachNode((_, attr) => {\n    const { x, y } = attr;\n\n    if (x < xMin) xMin = x;\n    if (x > xMax) xMax = x;\n\n    if (y < yMin) yMin = y;\n    if (y > yMax) yMax = y;\n  });\n\n  return { x: [xMin, xMax], y: [yMin, yMax] };\n}\n\n/**\n * Factory returning a function normalizing the given node's position & size.\n *\n * @param  {object}   extent  - Extent of the graph.\n * @return {function}\n */\nexport interface NormalizationFunction {\n  (data: Coordinates): Coordinates;\n  ratio: number;\n  inverse(data: Coordinates): Coordinates;\n  applyTo(data: Coordinates): void;\n}\nexport function createNormalizationFunction(extent: { x: Extent; y: Extent }): NormalizationFunction {\n  const {\n    x: [minX, maxX],\n    y: [minY, maxY],\n  } = extent;\n\n  let ratio = Math.max(maxX - minX, maxY - minY),\n    dX = (maxX + minX) / 2,\n    dY = (maxY + minY) / 2;\n\n  if (ratio === 0 || Math.abs(ratio) === Infinity || isNaN(ratio)) ratio = 1;\n  if (isNaN(dX)) dX = 0;\n  if (isNaN(dY)) dY = 0;\n\n  const fn = (data: Coordinates): Coordinates => {\n    return {\n      x: 0.5 + (data.x - dX) / ratio,\n      y: 0.5 + (data.y - dY) / ratio,\n    };\n  };\n\n  // TODO: possibility to apply this in batch over array of indices\n  fn.applyTo = (data: Coordinates): void => {\n    data.x = 0.5 + (data.x - dX) / ratio;\n    data.y = 0.5 + (data.y - dY) / ratio;\n  };\n\n  fn.inverse = (data: Coordinates): Coordinates => {\n    return {\n      x: dX + ratio * (data.x - 0.5),\n      y: dY + ratio * (data.y - 0.5),\n    };\n  };\n\n  fn.ratio = ratio;\n\n  return fn;\n}\n\n/**\n * Function ordering the given elements in reverse z-order so they drawn\n * the correct way.\n *\n * @param  {number}   extent   - [min, max] z values.\n * @param  {function} getter   - Z attribute getter function.\n * @param  {array}    elements - The array to sort.\n * @return {array} - The sorted array.\n */\nexport function zIndexOrdering<T>(_extent: Extent, getter: (e: T) => number, elements: Array<T>): Array<T> {\n  // If k is > n, we'll use a standard sort\n  return elements.sort(function (a, b) {\n    const zA = getter(a) || 0,\n      zB = getter(b) || 0;\n\n    if (zA < zB) return -1;\n    if (zA > zB) return 1;\n\n    return 0;\n  });\n\n  // TODO: counting sort optimization\n}\n\n/**\n * WebGL utils\n * ===========\n */\n\n/**\n * Memoized function returning a float-encoded color from various string\n * formats describing colors.\n */\nconst INT8 = new Int8Array(4);\nconst INT32 = new Int32Array(INT8.buffer, 0, 1);\nconst FLOAT32 = new Float32Array(INT8.buffer, 0, 1);\n\nconst RGBA_TEST_REGEX = /^\\s*rgba?\\s*\\(/;\nconst RGBA_EXTRACT_REGEX = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)(?:\\s*,\\s*(.*)?)?\\)\\s*$/;\n\ntype RGBAColor = { r: number; g: number; b: number; a: number };\n\nexport function parseColor(val: string): RGBAColor {\n  let r = 0; // byte\n  let g = 0; // byte\n  let b = 0; // byte\n  let a = 1; // float\n\n  // Handling hexadecimal notation\n  if (val[0] === \"#\") {\n    if (val.length === 4) {\n      r = parseInt(val.charAt(1) + val.charAt(1), 16);\n      g = parseInt(val.charAt(2) + val.charAt(2), 16);\n      b = parseInt(val.charAt(3) + val.charAt(3), 16);\n    } else {\n      r = parseInt(val.charAt(1) + val.charAt(2), 16);\n      g = parseInt(val.charAt(3) + val.charAt(4), 16);\n      b = parseInt(val.charAt(5) + val.charAt(6), 16);\n    }\n    if (val.length === 9) {\n      a = parseInt(val.charAt(7) + val.charAt(8), 16) / 255;\n    }\n  }\n\n  // Handling rgb notation\n  else if (RGBA_TEST_REGEX.test(val)) {\n    const match = val.match(RGBA_EXTRACT_REGEX);\n    if (match) {\n      r = +match[1];\n      g = +match[2];\n      b = +match[3];\n\n      if (match[4]) a = +match[4];\n    }\n  }\n\n  return { r, g, b, a };\n}\n\nconst FLOAT_COLOR_CACHE: { [key: string]: number } = {};\nfor (const htmlColor in HTML_COLORS) {\n  FLOAT_COLOR_CACHE[htmlColor] = floatColor(HTML_COLORS[htmlColor]);\n  // Replicating cache for hex values for free\n  FLOAT_COLOR_CACHE[HTML_COLORS[htmlColor]] = FLOAT_COLOR_CACHE[htmlColor];\n}\n\nexport function rgbaToFloat(r: number, g: number, b: number, a: number, masking?: boolean): number {\n  INT32[0] = (a << 24) | (b << 16) | (g << 8) | r;\n  if (masking) INT32[0] = INT32[0] & 0xfeffffff;\n  return FLOAT32[0];\n}\nexport function floatColor(val: string): number {\n  // The html color names are case-insensitive\n  val = val.toLowerCase();\n\n  // If the color is already computed, we yield it\n  if (typeof FLOAT_COLOR_CACHE[val] !== \"undefined\") return FLOAT_COLOR_CACHE[val];\n\n  const parsed = parseColor(val);\n  const { r, g, b } = parsed;\n  let { a } = parsed;\n  a = (a * 255) | 0;\n\n  const color = rgbaToFloat(r, g, b, a, true);\n\n  FLOAT_COLOR_CACHE[val] = color;\n\n  return color;\n}\n\nconst FLOAT_INDEX_CACHE: { [key: number]: number } = {};\n\nexport function indexToColor(index: number): number {\n  // If the index is already computed, we yield it\n  if (typeof FLOAT_INDEX_CACHE[index] !== \"undefined\") return FLOAT_INDEX_CACHE[index];\n\n  // To address issue #1397, one strategy is to keep encoding 4 bytes colors,\n  // but with alpha hard-set to 1.0 (or 255):\n  const r = (index & 0x00ff0000) >>> 16;\n  const g = (index & 0x0000ff00) >>> 8;\n  const b = index & 0x000000ff;\n  const a = 0x000000ff;\n\n  // The original 4 bytes color encoding was the following:\n  // const r = (index & 0xff000000) >>> 24;\n  // const g = (index & 0x00ff0000) >>> 16;\n  // const b = (index & 0x0000ff00) >>> 8;\n  // const a = index & 0x000000ff;\n\n  const color = rgbaToFloat(r, g, b, a, true);\n  FLOAT_INDEX_CACHE[index] = color;\n\n  return color;\n}\nexport function colorToIndex(r: number, g: number, b: number, _a: number): number {\n  // As for the function indexToColor, because of #1397 and the \"alpha is always\n  // 1.0\" strategy, we need to fix this function as well:\n  return b + (g << 8) + (r << 16);\n\n  // The original 4 bytes color decoding is the following:\n  // return a + (b << 8) + (g << 16) + (r << 24);\n}\n\n/**\n * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This\n * helps to deal with quadtree in particular.\n * But at some point, we need to rescale it so that it takes the best place in the screen, i.e. we always want to see two\n * nodes \"touching\" opposite sides of the graph, with the camera being at its default state.\n *\n * This function determines this ratio.\n */\nexport function getCorrectionRatio(\n  viewportDimensions: { width: number; height: number },\n  graphDimensions: { width: number; height: number },\n): number {\n  const viewportRatio = viewportDimensions.height / viewportDimensions.width;\n  const graphRatio = graphDimensions.height / graphDimensions.width;\n\n  // If the stage and the graphs are in different directions (such as the graph being wider that tall while the stage\n  // is taller than wide), we can stop here to have indeed nodes touching opposite sides:\n  if ((viewportRatio < 1 && graphRatio > 1) || (viewportRatio > 1 && graphRatio < 1)) {\n    return 1;\n  }\n\n  // Else, we need to fit the graph inside the stage:\n  // 1. If the graph is \"squarer\" (i.e. with a ratio closer to 1), we need to make the largest sides touch;\n  // 2. If the stage is \"squarer\", we need to make the smallest sides touch.\n  return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));\n}\n\n/**\n * Function returning a matrix from the current state of the camera.\n */\n\n// TODO: it's possible to optimize this drastically!\nexport function matrixFromCamera(\n  state: CameraState,\n  viewportDimensions: { width: number; height: number },\n  graphDimensions: { width: number; height: number },\n  padding: number,\n  inverse?: boolean,\n): Float32Array {\n  const { angle, ratio, x, y } = state;\n\n  const { width, height } = viewportDimensions;\n\n  const matrix = identity();\n\n  const smallestDimension = Math.min(width, height) - 2 * padding;\n\n  const correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);\n\n  if (!inverse) {\n    multiply(\n      matrix,\n      scale(\n        identity(),\n        2 * (smallestDimension / width) * correctionRatio,\n        2 * (smallestDimension / height) * correctionRatio,\n      ),\n    );\n    multiply(matrix, rotate(identity(), -angle));\n    multiply(matrix, scale(identity(), 1 / ratio));\n    multiply(matrix, translate(identity(), -x, -y));\n  } else {\n    multiply(matrix, translate(identity(), x, y));\n    multiply(matrix, scale(identity(), ratio));\n    multiply(matrix, rotate(identity(), angle));\n    multiply(\n      matrix,\n      scale(\n        identity(),\n        width / smallestDimension / 2 / correctionRatio,\n        height / smallestDimension / 2 / correctionRatio,\n      ),\n    );\n  }\n\n  return matrix;\n}\n\n/**\n * All these transformations we apply on the matrix to get it rescale the graph\n * as we want make it very hard to get pixel-perfect distances in WebGL. This\n * function returns a factor that properly cancels the matrix effect on lengths.\n *\n * [jacomyal]\n * To be fully honest, I can't really explain happens here... I notice that the\n * following ratio works (i.e. it correctly compensates the matrix impact on all\n * camera states I could try):\n * > `R = size(V) / size(M * V) / W`\n * as long as `M * V` is in the direction of W (ie. parallel to (Ox)). It works\n * as well with H and a vector that transforms into something parallel to (Oy).\n *\n * Also, note that we use `angle` and not `-angle` (that would seem logical,\n * since we want to anticipate the rotation), because the image is vertically\n * swapped in WebGL.\n */\nexport function getMatrixImpact(\n  matrix: Float32Array,\n  cameraState: CameraState,\n  viewportDimensions: Dimensions,\n): number {\n  const { x, y } = multiplyVec2(matrix, { x: Math.cos(cameraState.angle), y: Math.sin(cameraState.angle) }, 0);\n  return 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / viewportDimensions.width;\n}\n\n/**\n * Function extracting the color at the given pixel.\n */\nexport function extractPixel(gl: WebGLRenderingContext, x: number, y: number, array: Uint8Array): Uint8Array {\n  const data = array || new Uint8Array(4);\n\n  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n  return data;\n}\n\n/**\n * Check if the graph variable is a valid graph, and if sigma can render it.\n */\nexport function validateGraph(graph: Graph): void {\n  // check if it's a valid graphology instance\n  if (!isGraph(graph)) throw new Error(\"Sigma: invalid graph instance.\");\n\n  // check if nodes have x/y attributes\n  graph.forEachNode((key: string, attributes: Attributes) => {\n    if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {\n      throw new Error(\n        `Sigma: Coordinates of node ${key} are invalid. A node must have a numeric 'x' and 'y' attribute.`,\n      );\n    }\n  });\n}\n","/**\n * Sigma.js Easings\n * =================\n *\n * Handy collection of easing functions.\n * @module\n */\nexport const linear = (k: number): number => k;\n\nexport const quadraticIn = (k: number): number => k * k;\n\nexport const quadraticOut = (k: number): number => k * (2 - k);\n\nexport const quadraticInOut = (k: number): number => {\n  if ((k *= 2) < 1) return 0.5 * k * k;\n  return -0.5 * (--k * (k - 2) - 1);\n};\n\nexport const cubicIn = (k: number): number => k * k * k;\n\nexport const cubicOut = (k: number): number => --k * k * k + 1;\n\nexport const cubicInOut = (k: number): number => {\n  if ((k *= 2) < 1) return 0.5 * k * k * k;\n  return 0.5 * ((k -= 2) * k * k + 2);\n};\n\nconst easings: { [key: string]: (k: number) => number } = {\n  linear,\n  quadraticIn,\n  quadraticOut,\n  quadraticInOut,\n  cubicIn,\n  cubicOut,\n  cubicInOut,\n};\nexport default easings;\n","/**\n * Sigma.js Animation Helpers\n * ===========================\n *\n * Handy helper functions dealing with nodes & edges attributes animation.\n * @module\n */\nimport Graph from \"graphology-types\";\nimport { PlainObject } from \"../types\";\nimport { cancelFrame, requestFrame } from \"./index\";\nimport easings from \"./easings\";\n\n/**\n * Defaults.\n */\nexport type Easing = keyof typeof easings | ((k: number) => number);\n\nexport interface AnimateOptions {\n  easing: Easing;\n  duration: number;\n}\nexport const ANIMATE_DEFAULTS = {\n  easing: \"quadraticInOut\",\n  duration: 150,\n};\n\n/**\n * Function used to animate the nodes.\n */\nexport function animateNodes(\n  graph: Graph,\n  targets: PlainObject<PlainObject<number>>,\n  opts: Partial<AnimateOptions>,\n  callback?: () => void,\n): () => void {\n  const options: AnimateOptions = Object.assign({}, ANIMATE_DEFAULTS, opts);\n\n  const easing: (k: number) => number = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n  const start = Date.now();\n\n  const startPositions: PlainObject<PlainObject<number>> = {};\n\n  for (const node in targets) {\n    const attrs = targets[node];\n    startPositions[node] = {};\n\n    for (const k in attrs) startPositions[node][k] = graph.getNodeAttribute(node, k);\n  }\n\n  let frame: number | null = null;\n\n  const step = () => {\n    frame = null;\n\n    let p = (Date.now() - start) / options.duration;\n\n    if (p >= 1) {\n      // Animation is done\n      for (const node in targets) {\n        const attrs = targets[node];\n\n        // We use given values to avoid precision issues and for convenience\n        for (const k in attrs) graph.setNodeAttribute(node, k, attrs[k]);\n      }\n\n      if (typeof callback === \"function\") callback();\n\n      return;\n    }\n\n    p = easing(p);\n\n    for (const node in targets) {\n      const attrs = targets[node];\n      const s = startPositions[node];\n\n      for (const k in attrs) graph.setNodeAttribute(node, k, attrs[k] * p + s[k] * (1 - p));\n    }\n\n    frame = requestFrame(step);\n  };\n\n  step();\n\n  return () => {\n    if (frame) cancelFrame(frame);\n  };\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Sigma.js Types\n * ===============\n *\n * Various type declarations used throughout the library.\n * @module\n */\nimport { EventEmitter } from \"events\";\n\n/**\n * Util type to represent maps of typed elements, but implemented with\n * JavaScript objects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PlainObject<T = any> = { [k: string]: T };\n\n/**\n * Returns a type similar to T, but with the K set of properties of the type\n * T *required*, and the rest optional.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PartialButFor<T, K extends keyof T> = Pick<T, K> & Partial<Omit<T, K>> & { [others: string]: any };\n\nexport type NonEmptyArray<T> = [T, ...T[]];\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport interface CameraState extends Coordinates {\n  angle: number;\n  ratio: number;\n}\n\nexport type MouseInteraction = \"click\" | \"doubleClick\" | \"rightClick\" | \"wheel\" | \"down\";\n\nexport interface MouseCoords extends Coordinates {\n  sigmaDefaultPrevented: boolean;\n  preventSigmaDefault(): void;\n  original: MouseEvent;\n}\n\nexport interface WheelCoords extends MouseCoords {\n  delta: number; // This will store the delta actually used by sigma\n}\n\nexport interface TouchCoords {\n  touches: Coordinates[];\n  original: TouchEvent;\n}\n\nexport interface Dimensions {\n  width: number;\n  height: number;\n}\n\nexport type Extent = [number, number];\n\nexport interface DisplayData {\n  label: string | null;\n  size: number;\n  color: string;\n  hidden: boolean;\n  forceLabel: boolean;\n  zIndex: number;\n  type: string;\n}\n\nexport interface NodeDisplayData extends Coordinates, DisplayData {\n  highlighted: boolean;\n}\nexport interface EdgeDisplayData extends DisplayData {}\n\nexport type CoordinateConversionOverride = {\n  cameraState?: CameraState;\n  matrix?: Float32Array;\n  viewportDimensions?: Dimensions;\n  graphDimensions?: Dimensions;\n  padding?: number;\n};\n\nexport interface RenderParams {\n  width: number;\n  height: number;\n  sizeRatio: number;\n  zoomRatio: number;\n  pixelRatio: number;\n  correctionRatio: number;\n  matrix: Float32Array;\n  downSizingRatio: number;\n}\n\n/**\n * Custom event emitter types.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Listener = (...args: any[]) => void;\nexport type EventsMapping = Record<string, Listener>;\n\ninterface ITypedEventEmitter<Events extends EventsMapping> {\n  rawEmitter: EventEmitter;\n\n  eventNames<Event extends keyof Events>(): Array<Event>;\n  setMaxListeners(n: number): this;\n  getMaxListeners(): number;\n  emit<Event extends keyof Events>(type: Event, ...args: Parameters<Events[Event]>): boolean;\n  addListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  on<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  once<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  prependListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  prependOnceListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  removeListener<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  off<Event extends keyof Events>(type: Event, listener: Events[Event]): this;\n  removeAllListeners<Event extends keyof Events>(type?: Event): this;\n  listeners<Event extends keyof Events>(type: Event): Events[Event][];\n  listenerCount<Event extends keyof Events>(type: Event): number;\n  rawListeners<Event extends keyof Events>(type: Event): Events[Event][];\n}\n\nexport class TypedEventEmitter<Events extends EventsMapping> extends (EventEmitter as unknown as {\n  new <T extends EventsMapping>(): ITypedEventEmitter<T>;\n})<Events> {\n  constructor() {\n    super();\n    this.rawEmitter = this as EventEmitter;\n  }\n}\n","/**\n * Sigma.js Camera Class\n * ======================\n *\n * Class designed to store camera information & used to update it.\n * @module\n */\nimport { ANIMATE_DEFAULTS, AnimateOptions } from \"../utils/animate\";\nimport easings from \"../utils/easings\";\nimport { cancelFrame, requestFrame } from \"../utils\";\nimport { CameraState, TypedEventEmitter } from \"../types\";\n\n/**\n * Defaults.\n */\nconst DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\nexport type CameraEvents = {\n  updated(state: CameraState): void;\n};\n\n/**\n * Camera class\n *\n * @constructor\n */\nexport default class Camera extends TypedEventEmitter<CameraEvents> implements CameraState {\n  x = 0.5;\n  y = 0.5;\n  angle = 0;\n  ratio = 1;\n\n  minRatio: number | null = null;\n  maxRatio: number | null = null;\n\n  private nextFrame: number | null = null;\n  private previousState: CameraState | null = null;\n  private enabled = true;\n\n  animationCallback?: () => void;\n\n  constructor() {\n    super();\n\n    // State\n    this.previousState = this.getState();\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   *\n   * @param state\n   * @return {Camera}\n   */\n  static from(state: CameraState): Camera {\n    const camera = new Camera();\n    return camera.setState(state);\n  }\n\n  /**\n   * Method used to enable the camera.\n   *\n   * @return {Camera}\n   */\n  enable(): this {\n    this.enabled = true;\n    return this;\n  }\n\n  /**\n   * Method used to disable the camera.\n   *\n   * @return {Camera}\n   */\n  disable(): this {\n    this.enabled = false;\n    return this;\n  }\n\n  /**\n   * Method used to retrieve the camera's current state.\n   *\n   * @return {object}\n   */\n  getState(): CameraState {\n    return {\n      x: this.x,\n      y: this.y,\n      angle: this.angle,\n      ratio: this.ratio,\n    };\n  }\n\n  /**\n   * Method used to check whether the camera has the given state.\n   *\n   * @return {object}\n   */\n  hasState(state: CameraState): boolean {\n    return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n  }\n\n  /**\n   * Method used to retrieve the camera's previous state.\n   *\n   * @return {object}\n   */\n  getPreviousState(): CameraState | null {\n    const state = this.previousState;\n\n    if (!state) return null;\n\n    return {\n      x: state.x,\n      y: state.y,\n      angle: state.angle,\n      ratio: state.ratio,\n    };\n  }\n\n  /**\n   * Method used to check minRatio and maxRatio values.\n   *\n   * @param ratio\n   * @return {number}\n   */\n  getBoundedRatio(ratio: number): number {\n    let r = ratio;\n    if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n    if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n    return r;\n  }\n\n  /**\n   * Method used to check various things to return a legit state candidate.\n   *\n   * @param state\n   * @return {object}\n   */\n  validateState(state: Partial<CameraState>): Partial<CameraState> {\n    const validatedState: Partial<CameraState> = {};\n    if (typeof state.x === \"number\") validatedState.x = state.x;\n    if (typeof state.y === \"number\") validatedState.y = state.y;\n    if (typeof state.angle === \"number\") validatedState.angle = state.angle;\n    if (typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n    return validatedState;\n  }\n\n  /**\n   * Method used to check whether the camera is currently being animated.\n   *\n   * @return {boolean}\n   */\n  isAnimated(): boolean {\n    return !!this.nextFrame;\n  }\n\n  /**\n   * Method used to set the camera's state.\n   *\n   * @param  {object} state - New state.\n   * @return {Camera}\n   */\n  setState(state: Partial<CameraState>): this {\n    if (!this.enabled) return this;\n\n    // TODO: update by function\n\n    // Keeping track of last state\n    this.previousState = this.getState();\n\n    const validState = this.validateState(state);\n    if (typeof validState.x === \"number\") this.x = validState.x;\n    if (typeof validState.y === \"number\") this.y = validState.y;\n    if (typeof validState.angle === \"number\") this.angle = validState.angle;\n    if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n\n    // Emitting\n    if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n\n    return this;\n  }\n\n  /**\n   * Method used to update the camera's state using a function.\n   *\n   * @param  {function} updater - Updated function taking current state and\n   *                              returning next state.\n   * @return {Camera}\n   */\n  updateState(updater: (state: CameraState) => Partial<CameraState>): this {\n    this.setState(updater(this.getState()));\n    return this;\n  }\n\n  /**\n   * Method used to animate the camera.\n   *\n   * @param  {object}                    state      - State to reach eventually.\n   * @param  {object}                    opts       - Options:\n   * @param  {number}                      duration - Duration of the animation.\n   * @param  {string | number => number}   easing   - Easing function or name of an existing one\n   * @param  {function}                  callback   - Callback\n   */\n  animate(state: Partial<CameraState>, opts?: Partial<AnimateOptions>, callback?: () => void): void {\n    if (!this.enabled) return;\n\n    const options: AnimateOptions = Object.assign({}, ANIMATE_DEFAULTS, opts);\n    const validState = this.validateState(state);\n\n    const easing: (k: number) => number =\n      typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n    // State\n    const start = Date.now(),\n      initialState = this.getState();\n\n    // Function performing the animation\n    const fn = () => {\n      const t = (Date.now() - start) / options.duration;\n\n      // The animation is over:\n      if (t >= 1) {\n        this.nextFrame = null;\n        this.setState(validState);\n\n        if (this.animationCallback) {\n          this.animationCallback.call(null);\n          this.animationCallback = undefined;\n        }\n\n        return;\n      }\n\n      const coefficient = easing(t);\n\n      const newState: Partial<CameraState> = {};\n\n      if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n      if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n      if (typeof validState.angle === \"number\")\n        newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n      if (typeof validState.ratio === \"number\")\n        newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n\n      this.setState(newState);\n\n      this.nextFrame = requestFrame(fn);\n    };\n\n    if (this.nextFrame) {\n      cancelFrame(this.nextFrame);\n      if (this.animationCallback) this.animationCallback.call(null);\n      this.nextFrame = requestFrame(fn);\n    } else {\n      fn();\n    }\n    this.animationCallback = callback;\n  }\n\n  /**\n   * Method used to zoom the camera.\n   *\n   * @param  {number|object} factorOrOptions - Factor or options.\n   * @return {function}\n   */\n  animatedZoom(factorOrOptions?: number | (Partial<AnimateOptions> & { factor?: number })): void {\n    if (!factorOrOptions) {\n      this.animate({ ratio: this.ratio / DEFAULT_ZOOMING_RATIO });\n    } else {\n      if (typeof factorOrOptions === \"number\") return this.animate({ ratio: this.ratio / factorOrOptions });\n      else\n        this.animate(\n          {\n            ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO),\n          },\n          factorOrOptions,\n        );\n    }\n  }\n\n  /**\n   * Method used to unzoom the camera.\n   *\n   * @param  {number|object} factorOrOptions - Factor or options.\n   */\n  animatedUnzoom(factorOrOptions?: number | (Partial<AnimateOptions> & { factor?: number })): void {\n    if (!factorOrOptions) {\n      this.animate({ ratio: this.ratio * DEFAULT_ZOOMING_RATIO });\n    } else {\n      if (typeof factorOrOptions === \"number\") return this.animate({ ratio: this.ratio * factorOrOptions });\n      else\n        this.animate(\n          {\n            ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO),\n          },\n          factorOrOptions,\n        );\n    }\n  }\n\n  /**\n   * Method used to reset the camera.\n   *\n   * @param  {object} options - Options.\n   */\n  animatedReset(options?: Partial<AnimateOptions>): void {\n    this.animate(\n      {\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0,\n      },\n      options,\n    );\n  }\n\n  /**\n   * Returns a new Camera instance, with the same state as the current camera.\n   *\n   * @return {Camera}\n   */\n  copy(): Camera {\n    return Camera.from(this.getState());\n  }\n}\n","/**\n * Sigma.js Captor Class\n * ======================\n * @module\n */\nimport { Coordinates, MouseCoords, TouchCoords, WheelCoords, TypedEventEmitter, EventsMapping } from \"../../types\";\nimport Sigma from \"../../sigma\";\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nexport function getPosition(e: MouseEvent | Touch, dom: HTMLElement): Coordinates {\n  const bbox = dom.getBoundingClientRect();\n\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top,\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nexport function getMouseCoords(e: MouseEvent, dom: HTMLElement): MouseCoords {\n  const res: MouseCoords = {\n    ...getPosition(e, dom),\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault(): void {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e,\n  };\n\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nexport function getWheelCoords(e: WheelEvent, dom: HTMLElement): WheelCoords {\n  return {\n    ...getMouseCoords(e, dom),\n    delta: getWheelDelta(e),\n  };\n}\n\nconst MAX_TOUCHES = 2;\nexport function getTouchesArray(touches: TouchList): Touch[] {\n  const arr: Touch[] = [];\n  for (let i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e   - A touch event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nexport function getTouchCoords(e: TouchEvent, dom: HTMLElement): TouchCoords {\n  return {\n    touches: getTouchesArray(e.touches).map((touch) => getPosition(touch, dom)),\n    original: e,\n  };\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nexport function getWheelDelta(e: WheelEvent): number {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return (e.deltaY * -3) / 360;\n\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nexport default abstract class Captor<Events extends EventsMapping> extends TypedEventEmitter<Events> {\n  container: HTMLElement;\n  renderer: Sigma;\n\n  constructor(container: HTMLElement, renderer: Sigma) {\n    super();\n\n    // Properties\n    this.container = container;\n    this.renderer = renderer;\n  }\n\n  abstract kill(): void;\n}\n","/**\n * Sigma.js Mouse Captor\n * ======================\n *\n * Sigma's captor dealing with the user's mouse.\n * @module\n */\nimport { CameraState, MouseCoords, WheelCoords } from \"../../types\";\nimport Sigma from \"../../sigma\";\nimport Captor, { getWheelDelta, getMouseCoords, getPosition, getWheelCoords } from \"./captor\";\n\n/**\n * Constants.\n */\nconst DRAG_TIMEOUT = 100;\nconst DRAGGED_EVENTS_TOLERANCE = 3;\nconst MOUSE_INERTIA_DURATION = 200;\nconst MOUSE_INERTIA_RATIO = 3;\nconst MOUSE_ZOOM_DURATION = 250;\nconst ZOOMING_RATIO = 1.7;\nconst DOUBLE_CLICK_TIMEOUT = 300;\nconst DOUBLE_CLICK_ZOOMING_RATIO = 2.2;\nconst DOUBLE_CLICK_ZOOMING_DURATION = 200;\n\n/**\n * Event types.\n */\nexport type MouseCaptorEvents = {\n  click(coordinates: MouseCoords): void;\n  rightClick(coordinates: MouseCoords): void;\n  doubleClick(coordinates: MouseCoords): void;\n  mouseup(coordinates: MouseCoords): void;\n  mousedown(coordinates: MouseCoords): void;\n  mousemove(coordinates: MouseCoords): void;\n  mousemovebody(coordinates: MouseCoords): void;\n  wheel(coordinates: WheelCoords): void;\n};\n\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nexport default class MouseCaptor extends Captor<MouseCaptorEvents> {\n  // State\n  enabled = true;\n  draggedEvents = 0;\n  downStartTime: number | null = null;\n  lastMouseX: number | null = null;\n  lastMouseY: number | null = null;\n  isMouseDown = false;\n  isMoving = false;\n  movingTimeout: number | null = null;\n  startCameraState: CameraState | null = null;\n  clicks = 0;\n  doubleClickTimeout: number | null = null;\n\n  currentWheelDirection: -1 | 0 | 1 = 0;\n  lastWheelTriggerTime?: number;\n\n  constructor(container: HTMLElement, renderer: Sigma) {\n    super(container, renderer);\n\n    // Binding methods\n    this.handleClick = this.handleClick.bind(this);\n    this.handleRightClick = this.handleRightClick.bind(this);\n    this.handleDown = this.handleDown.bind(this);\n    this.handleUp = this.handleUp.bind(this);\n    this.handleMove = this.handleMove.bind(this);\n    this.handleWheel = this.handleWheel.bind(this);\n    this.handleOut = this.handleOut.bind(this);\n\n    // Binding events\n    container.addEventListener(\"click\", this.handleClick, false);\n    container.addEventListener(\"contextmenu\", this.handleRightClick, false);\n    container.addEventListener(\"mousedown\", this.handleDown, false);\n    container.addEventListener(\"wheel\", this.handleWheel, false);\n    container.addEventListener(\"mouseout\", this.handleOut, false);\n\n    document.addEventListener(\"mousemove\", this.handleMove, false);\n    document.addEventListener(\"mouseup\", this.handleUp, false);\n  }\n\n  kill(): void {\n    const container = this.container;\n\n    container.removeEventListener(\"click\", this.handleClick);\n    container.removeEventListener(\"contextmenu\", this.handleRightClick);\n    container.removeEventListener(\"mousedown\", this.handleDown);\n    container.removeEventListener(\"wheel\", this.handleWheel);\n    container.removeEventListener(\"mouseout\", this.handleOut);\n\n    document.removeEventListener(\"mousemove\", this.handleMove);\n    document.removeEventListener(\"mouseup\", this.handleUp);\n  }\n\n  handleClick(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    this.clicks++;\n\n    if (this.clicks === 2) {\n      this.clicks = 0;\n      if (typeof this.doubleClickTimeout === \"number\") {\n        clearTimeout(this.doubleClickTimeout);\n        this.doubleClickTimeout = null;\n      }\n      return this.handleDoubleClick(e);\n    }\n\n    setTimeout(() => {\n      this.clicks = 0;\n      this.doubleClickTimeout = null;\n    }, DOUBLE_CLICK_TIMEOUT);\n\n    // NOTE: this is here to prevent click events on drag\n    if (this.draggedEvents < DRAGGED_EVENTS_TOLERANCE) this.emit(\"click\", getMouseCoords(e, this.container));\n  }\n\n  handleRightClick(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    this.emit(\"rightClick\", getMouseCoords(e, this.container));\n  }\n\n  handleDoubleClick(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    const mouseCoords = getMouseCoords(e, this.container);\n    this.emit(\"doubleClick\", mouseCoords);\n\n    if (mouseCoords.sigmaDefaultPrevented) return;\n\n    // default behavior\n    const camera = this.renderer.getCamera();\n    const newRatio = camera.getBoundedRatio(camera.getState().ratio / DOUBLE_CLICK_ZOOMING_RATIO);\n\n    camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n      easing: \"quadraticInOut\",\n      duration: DOUBLE_CLICK_ZOOMING_DURATION,\n    });\n  }\n\n  handleDown(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    // We only start dragging on left button\n    if (e.button === 0) {\n      this.startCameraState = this.renderer.getCamera().getState();\n\n      const { x, y } = getPosition(e, this.container);\n      this.lastMouseX = x;\n      this.lastMouseY = y;\n\n      this.draggedEvents = 0;\n\n      this.downStartTime = Date.now();\n      this.isMouseDown = true;\n    }\n\n    this.emit(\"mousedown\", getMouseCoords(e, this.container));\n  }\n\n  handleUp(e: MouseEvent): void {\n    if (!this.enabled || !this.isMouseDown) return;\n\n    const camera = this.renderer.getCamera();\n    this.isMouseDown = false;\n\n    if (typeof this.movingTimeout === \"number\") {\n      clearTimeout(this.movingTimeout);\n      this.movingTimeout = null;\n    }\n\n    const { x, y } = getPosition(e, this.container);\n\n    const cameraState = camera.getState(),\n      previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };\n\n    if (this.isMoving) {\n      camera.animate(\n        {\n          x: cameraState.x + MOUSE_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + MOUSE_INERTIA_RATIO * (cameraState.y - previousCameraState.y),\n        },\n        {\n          duration: MOUSE_INERTIA_DURATION,\n          easing: \"quadraticOut\",\n        },\n      );\n    } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n      camera.setState({\n        x: cameraState.x,\n        y: cameraState.y,\n      });\n    }\n\n    this.isMoving = false;\n    setTimeout(() => {\n      const shouldRefresh = this.draggedEvents > 0;\n      this.draggedEvents = 0;\n\n      // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n      // when someone releases camera pan drag after having stopped moving.\n      // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n      // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n      // It could be possible to render instead of scheduling a refresh but for\n      // now it seems good enough.\n      if (shouldRefresh) this.renderer.refresh();\n    }, 0);\n    this.emit(\"mouseup\", getMouseCoords(e, this.container));\n  }\n\n  handleMove(e: MouseEvent): void {\n    if (!this.enabled) return;\n\n    const mouseCoords = getMouseCoords(e, this.container);\n\n    // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n    // a drag-and-drop effect that works even when the mouse is out of the\n    // container:\n    this.emit(\"mousemovebody\", mouseCoords);\n\n    // Only trigger the \"mousemove\" event when the mouse is actually hovering\n    // the container, to avoid weirdly hovering nodes and/or edges when the\n    // mouse is not hover the container:\n    if (e.target === this.container) {\n      this.emit(\"mousemove\", mouseCoords);\n    }\n\n    if (mouseCoords.sigmaDefaultPrevented) return;\n\n    // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n    // stage while the mouse is not hover the container:\n    if (this.isMouseDown) {\n      this.isMoving = true;\n      this.draggedEvents++;\n\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n      }\n\n      this.movingTimeout = window.setTimeout(() => {\n        this.movingTimeout = null;\n        this.isMoving = false;\n      }, DRAG_TIMEOUT);\n\n      const camera = this.renderer.getCamera();\n\n      const { x: eX, y: eY } = getPosition(e, this.container);\n\n      const lastMouse = this.renderer.viewportToFramedGraph({\n        x: this.lastMouseX as number,\n        y: this.lastMouseY as number,\n      });\n\n      const mouse = this.renderer.viewportToFramedGraph({ x: eX, y: eY });\n\n      const offsetX = lastMouse.x - mouse.x,\n        offsetY = lastMouse.y - mouse.y;\n\n      const cameraState = camera.getState();\n\n      const x = cameraState.x + offsetX,\n        y = cameraState.y + offsetY;\n\n      camera.setState({ x, y });\n\n      this.lastMouseX = eX;\n      this.lastMouseY = eY;\n\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n\n  handleWheel(e: WheelEvent): void {\n    if (!this.enabled) return;\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    const delta = getWheelDelta(e);\n\n    if (!delta) return;\n\n    const wheelCoords = getWheelCoords(e, this.container);\n    this.emit(\"wheel\", wheelCoords);\n\n    if (wheelCoords.sigmaDefaultPrevented) return;\n\n    // Default behavior\n    const ratioDiff = delta > 0 ? 1 / ZOOMING_RATIO : ZOOMING_RATIO;\n    const camera = this.renderer.getCamera();\n    const newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);\n    const wheelDirection = delta > 0 ? 1 : -1;\n    const now = Date.now();\n\n    // Cancel events that are too close too each other and in the same direction:\n    if (\n      this.currentWheelDirection === wheelDirection &&\n      this.lastWheelTriggerTime &&\n      now - this.lastWheelTriggerTime < MOUSE_ZOOM_DURATION / 5\n    ) {\n      return;\n    }\n\n    camera.animate(\n      this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio),\n      {\n        easing: \"quadraticOut\",\n        duration: MOUSE_ZOOM_DURATION,\n      },\n      () => {\n        this.currentWheelDirection = 0;\n      },\n    );\n\n    this.currentWheelDirection = wheelDirection;\n    this.lastWheelTriggerTime = now;\n  }\n\n  handleOut(): void {\n    // TODO: dispatch event\n  }\n}\n","/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\nimport Graph from \"graphology-types\";\n\nimport { Dimensions, Coordinates } from \"../types\";\n\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nclass LabelCandidate {\n  key: string;\n  size: number;\n\n  constructor(key: string, size: number) {\n    this.key = key;\n    this.size = size;\n  }\n\n  static compare(first: LabelCandidate, second: LabelCandidate): number {\n    // First we compare by size\n    if (first.size > second.size) return -1;\n    if (first.size < second.size) return 1;\n\n    // Then since no two nodes can have the same key, we use it to\n    // deterministically tie-break by key\n    if (first.key > second.key) return 1;\n\n    // NOTE: this comparator cannot return 0\n    return -1;\n  }\n}\n\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nexport class LabelGrid {\n  width = 0;\n  height = 0;\n  cellSize = 0;\n  columns = 0;\n  rows = 0;\n  cells: Record<number, Array<LabelCandidate>> = {};\n\n  resizeAndClear(dimensions: Dimensions, cellSize: number): void {\n    this.width = dimensions.width;\n    this.height = dimensions.height;\n\n    this.cellSize = cellSize;\n\n    this.columns = Math.ceil(dimensions.width / cellSize);\n    this.rows = Math.ceil(dimensions.height / cellSize);\n\n    this.cells = {};\n  }\n\n  private getIndex(pos: Coordinates): number {\n    const xIndex = Math.floor(pos.x / this.cellSize);\n    const yIndex = Math.floor(pos.y / this.cellSize);\n\n    return yIndex * this.columns + xIndex;\n  }\n\n  add(key: string, size: number, pos: Coordinates): void {\n    const candidate = new LabelCandidate(key, size);\n\n    const index = this.getIndex(pos);\n    let cell = this.cells[index];\n\n    if (!cell) {\n      cell = [];\n      this.cells[index] = cell;\n    }\n\n    cell.push(candidate);\n  }\n\n  organize(): void {\n    for (const k in this.cells) {\n      const cell = this.cells[k];\n      cell.sort(LabelCandidate.compare);\n    }\n  }\n\n  getLabelsToDisplay(ratio: number, density: number): Array<string> {\n    // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n    // TODO: adjust threshold lower, but increase cells a bit?\n    // TODO: hunt for geom issue in disguise\n    // TODO: memoize while ratio does not move. method to force recompute\n    const cellArea = this.cellSize * this.cellSize;\n    const scaledCellArea = cellArea / ratio / ratio;\n    const scaledDensity = (scaledCellArea * density) / cellArea;\n\n    const labelsToDisplayPerCell = Math.ceil(scaledDensity);\n\n    const labels: string[] = [];\n\n    for (const k in this.cells) {\n      const cell = this.cells[k];\n\n      for (let i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n        labels.push(cell[i].key);\n      }\n    }\n\n    return labels;\n  }\n}\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nexport function edgeLabelsToDisplayFromNodes(params: {\n  displayedNodeLabels: Set<string>;\n  highlightedNodes: Set<string>;\n  graph: Graph;\n  hoveredNode: string | null;\n}): Array<string> {\n  const { graph, hoveredNode, highlightedNodes, displayedNodeLabels } = params;\n\n  const worthyEdges: Array<string> = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge((edge, _, source, target) => {\n    if (\n      source === hoveredNode ||\n      target === hoveredNode ||\n      highlightedNodes.has(source) ||\n      highlightedNodes.has(target) ||\n      (displayedNodeLabels.has(source) && displayedNodeLabels.has(target))\n    ) {\n      worthyEdges.push(edge);\n    }\n  });\n\n  return worthyEdges;\n}\n","/**\n * Sigma.js Shader Utils\n * ======================\n *\n * Code used to load sigma's shaders.\n * @module\n */\n\n/**\n * Function used to load a shader.\n */\nfunction loadShader(type: string, gl: WebGLRenderingContext, source: string): WebGLShader {\n  const glType = type === \"VERTEX\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;\n\n  // Creating the shader\n  const shader = gl.createShader(glType);\n  if (shader === null) {\n    throw new Error(`loadShader: error while creating the shader`);\n  }\n\n  // Loading source\n  gl.shaderSource(shader, source);\n\n  // Compiling the shader\n  gl.compileShader(shader);\n\n  // Retrieving compilation status\n  const successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  // Throwing if something went awry\n  if (!successfullyCompiled) {\n    const infoLog = gl.getShaderInfoLog(shader);\n\n    gl.deleteShader(shader);\n    throw new Error(`loadShader: error while compiling the shader:\\n${infoLog}\\n${source}`);\n  }\n\n  return shader;\n}\n\nexport function loadVertexShader(gl: WebGLRenderingContext, source: string): WebGLShader {\n  return loadShader(\"VERTEX\", gl, source);\n}\nexport function loadFragmentShader(gl: WebGLRenderingContext, source: string): WebGLShader {\n  return loadShader(\"FRAGMENT\", gl, source);\n}\n\n/**\n * Function used to load a program.\n */\nexport function loadProgram(gl: WebGLRenderingContext, shaders: Array<WebGLShader>): WebGLProgram {\n  const program = gl.createProgram();\n  if (program === null) {\n    throw new Error(\"loadProgram: error while creating the program.\");\n  }\n\n  let i, l;\n\n  // Attaching the shaders\n  for (i = 0, l = shaders.length; i < l; i++) gl.attachShader(program, shaders[i]);\n\n  gl.linkProgram(program);\n\n  // Checking status\n  const successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (!successfullyLinked) {\n    gl.deleteProgram(program);\n    throw new Error(\"loadProgram: error while linking the program.\");\n  }\n\n  return program;\n}\n","/**\n * Sigma.js WebGL Renderer Program\n * ================================\n *\n * Class representing a single WebGL program used by sigma's WebGL renderer.\n * @module\n */\nimport type Sigma from \"../sigma\";\nimport type { RenderParams } from \"../types\";\nimport { loadVertexShader, loadFragmentShader, loadProgram } from \"./utils\";\n\nconst PICKING_PREFIX = `#define PICKING_MODE\\n`;\n\nconst SIZE_FACTOR_PER_ATTRIBUTE_TYPE: Record<number, number> = {\n  [WebGL2RenderingContext.BOOL]: 1,\n  [WebGL2RenderingContext.BYTE]: 1,\n  [WebGL2RenderingContext.UNSIGNED_BYTE]: 1,\n  [WebGL2RenderingContext.SHORT]: 2,\n  [WebGL2RenderingContext.UNSIGNED_SHORT]: 2,\n  [WebGL2RenderingContext.INT]: 4,\n  [WebGL2RenderingContext.UNSIGNED_INT]: 4,\n  [WebGL2RenderingContext.FLOAT]: 4,\n};\n\nfunction getAttributeItemsCount(attr: ProgramAttributeSpecification): number {\n  return attr.normalized ? 1 : attr.size;\n}\nfunction getAttributesItemsCount(attrs: ProgramAttributeSpecification[]): number {\n  let res = 0;\n  attrs.forEach((attr) => (res += getAttributeItemsCount(attr)));\n  return res;\n}\n\nexport interface ProgramInfo<Uniform extends string = string> {\n  name: string;\n  isPicking: boolean;\n  program: WebGLProgram;\n  gl: WebGLRenderingContext | WebGL2RenderingContext;\n  frameBuffer: WebGLFramebuffer | null;\n  buffer: WebGLBuffer;\n  constantBuffer: WebGLBuffer;\n  uniformLocations: Record<Uniform, WebGLUniformLocation>;\n  attributeLocations: Record<string, GLint>;\n}\n\nexport interface ProgramAttributeSpecification {\n  name: string;\n  size: number;\n  type: number;\n  normalized?: boolean;\n}\n\nexport interface ProgramDefinition<Uniform extends string = string> {\n  VERTICES: number;\n  VERTEX_SHADER_SOURCE: string;\n  FRAGMENT_SHADER_SOURCE: string;\n  UNIFORMS: ReadonlyArray<Uniform>;\n  ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  METHOD: GLenum;\n}\n\nexport interface InstancedProgramDefinition<Uniform extends string = string> extends ProgramDefinition<Uniform> {\n  CONSTANT_ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  CONSTANT_DATA: number[][];\n}\n\nexport abstract class AbstractProgram {\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  constructor(_gl: WebGLRenderingContext, _pickGl: WebGLRenderingContext, _renderer: Sigma) {}\n  abstract reallocate(capacity: number): void;\n  abstract render(params: RenderParams): void;\n}\n\nexport abstract class Program<Uniform extends string = string> implements AbstractProgram, InstancedProgramDefinition {\n  VERTICES: number;\n  VERTEX_SHADER_SOURCE: string;\n  FRAGMENT_SHADER_SOURCE: string;\n  UNIFORMS: ReadonlyArray<Uniform>;\n  ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  METHOD: GLenum;\n  CONSTANT_ATTRIBUTES: Array<ProgramAttributeSpecification>;\n  CONSTANT_DATA: number[][];\n\n  ATTRIBUTES_ITEMS_COUNT: number;\n  STRIDE: number;\n\n  renderer: Sigma;\n  array: Float32Array = new Float32Array();\n  constantArray: Float32Array = new Float32Array();\n  capacity = 0;\n  verticesCount = 0;\n\n  normalProgram: ProgramInfo;\n  pickProgram: ProgramInfo | null;\n\n  isInstanced: boolean;\n\n  abstract getDefinition(): ProgramDefinition<Uniform> | InstancedProgramDefinition<Uniform>;\n\n  constructor(\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    pickingBuffer: WebGLFramebuffer | null,\n    renderer: Sigma,\n  ) {\n    // Reading and caching program definition\n    const def = this.getDefinition();\n    this.VERTICES = def.VERTICES;\n    this.VERTEX_SHADER_SOURCE = def.VERTEX_SHADER_SOURCE;\n    this.FRAGMENT_SHADER_SOURCE = def.FRAGMENT_SHADER_SOURCE;\n    this.UNIFORMS = def.UNIFORMS;\n    this.ATTRIBUTES = def.ATTRIBUTES;\n    this.METHOD = def.METHOD;\n    this.CONSTANT_ATTRIBUTES = \"CONSTANT_ATTRIBUTES\" in def ? def.CONSTANT_ATTRIBUTES : [];\n    this.CONSTANT_DATA = \"CONSTANT_DATA\" in def ? def.CONSTANT_DATA : [];\n\n    this.isInstanced = \"CONSTANT_ATTRIBUTES\" in def;\n\n    // Computing stride\n    this.ATTRIBUTES_ITEMS_COUNT = getAttributesItemsCount(this.ATTRIBUTES);\n    this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT;\n\n    // Members\n    this.renderer = renderer;\n    this.normalProgram = this.getProgramInfo(\"normal\", gl, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);\n    this.pickProgram = pickingBuffer\n      ? this.getProgramInfo(\n          \"pick\",\n          gl,\n          PICKING_PREFIX + def.VERTEX_SHADER_SOURCE,\n          PICKING_PREFIX + def.FRAGMENT_SHADER_SOURCE,\n          pickingBuffer,\n        )\n      : null;\n\n    // For instanced programs:\n    if (this.isInstanced) {\n      const constantAttributesItemsCount = getAttributesItemsCount(this.CONSTANT_ATTRIBUTES);\n\n      if (this.CONSTANT_DATA.length !== this.VERTICES)\n        throw new Error(\n          `Program: error while getting constant data (expected ${this.VERTICES} items, received ${this.CONSTANT_DATA.length} instead)`,\n        );\n\n      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * constantAttributesItemsCount);\n      for (let i = 0; i < this.CONSTANT_DATA.length; i++) {\n        const vector = this.CONSTANT_DATA[i];\n\n        if (vector.length !== constantAttributesItemsCount)\n          throw new Error(\n            `Program: error while getting constant data (one vector has ${vector.length} items instead of ${constantAttributesItemsCount})`,\n          );\n\n        for (let j = 0; j < vector.length; j++) this.constantArray[i * constantAttributesItemsCount + j] = vector[j];\n      }\n\n      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;\n    }\n  }\n\n  protected getProgramInfo(\n    name: \"normal\" | \"pick\",\n    gl: WebGLRenderingContext | WebGL2RenderingContext,\n    vertexShaderSource: string,\n    fragmentShaderSource: string,\n    frameBuffer: WebGLFramebuffer | null,\n  ): ProgramInfo {\n    const def = this.getDefinition();\n\n    // WebGL buffers\n    const buffer = gl.createBuffer();\n    if (buffer === null) throw new Error(\"Program: error while creating the WebGL buffer.\");\n\n    // Shaders and program\n    const vertexShader = loadVertexShader(gl, vertexShaderSource);\n    const fragmentShader = loadFragmentShader(gl, fragmentShaderSource);\n    const program = loadProgram(gl, [vertexShader, fragmentShader]);\n\n    // Initializing locations\n    const uniformLocations = {} as ProgramInfo[\"uniformLocations\"];\n    def.UNIFORMS.forEach((uniformName) => {\n      const location = gl.getUniformLocation(program, uniformName);\n      if (location) uniformLocations[uniformName] = location;\n    });\n\n    const attributeLocations = {} as ProgramInfo[\"attributeLocations\"];\n    def.ATTRIBUTES.forEach((attr) => {\n      attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n    });\n\n    // For instanced programs:\n    let constantBuffer;\n    if (\"CONSTANT_ATTRIBUTES\" in def) {\n      def.CONSTANT_ATTRIBUTES.forEach((attr) => {\n        attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n      });\n\n      constantBuffer = gl.createBuffer();\n      if (constantBuffer === null) throw new Error(\"Program: error while creating the WebGL constant buffer.\");\n    }\n\n    return {\n      name,\n      program,\n      gl,\n      frameBuffer,\n      buffer,\n      constantBuffer: constantBuffer || ({} as WebGLBuffer),\n      uniformLocations,\n      attributeLocations,\n      isPicking: name === \"pick\",\n    };\n  }\n\n  protected bindProgram(program: ProgramInfo): void {\n    let offset = 0;\n\n    const { gl, buffer } = program;\n    if (!this.isInstanced) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n      offset = 0;\n      this.ATTRIBUTES.forEach((attr) => (offset += this.bindAttribute(attr, program, offset)));\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    } else {\n      // Handle constant data (things that remain unchanged for all items):\n      gl.bindBuffer(gl.ARRAY_BUFFER, program.constantBuffer);\n\n      offset = 0;\n      this.CONSTANT_ATTRIBUTES.forEach((attr) => (offset += this.bindAttribute(attr, program, offset, false)));\n      gl.bufferData(gl.ARRAY_BUFFER, this.constantArray, gl.STATIC_DRAW);\n\n      // Handle \"instance specific\" data (things that vary for each item):\n      gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);\n\n      offset = 0;\n      this.ATTRIBUTES.forEach((attr) => (offset += this.bindAttribute(attr, program, offset, true)));\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  }\n\n  protected unbindProgram(program: ProgramInfo): void {\n    if (!this.isInstanced) {\n      this.ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program));\n    } else {\n      this.CONSTANT_ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program, false));\n      this.ATTRIBUTES.forEach((attr) => this.unbindAttribute(attr, program, true));\n    }\n  }\n\n  protected bindAttribute(\n    attr: ProgramAttributeSpecification,\n    program: ProgramInfo,\n    offset: number,\n    setDivisor?: boolean,\n  ): number {\n    const sizeFactor = SIZE_FACTOR_PER_ATTRIBUTE_TYPE[attr.type];\n    if (typeof sizeFactor !== \"number\") throw new Error(`Program.bind: yet unsupported attribute type \"${attr.type}\"`);\n\n    const location = program.attributeLocations[attr.name];\n    const gl = program.gl;\n\n    if (location !== -1) {\n      gl.enableVertexAttribArray(location);\n\n      const stride = !this.isInstanced\n        ? this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT\n        : (setDivisor ? this.ATTRIBUTES_ITEMS_COUNT : getAttributesItemsCount(this.CONSTANT_ATTRIBUTES)) *\n          Float32Array.BYTES_PER_ELEMENT;\n\n      gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized || false, stride, offset);\n\n      if (this.isInstanced && setDivisor) {\n        if (gl instanceof WebGL2RenderingContext) {\n          gl.vertexAttribDivisor(location, 1);\n        } else {\n          const ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n          if (ext) ext.vertexAttribDivisorANGLE(location, 1);\n        }\n      }\n    }\n\n    return attr.size * sizeFactor;\n  }\n\n  protected unbindAttribute(attr: ProgramAttributeSpecification, program: ProgramInfo, unsetDivisor?: boolean) {\n    const location = program.attributeLocations[attr.name];\n    const gl = program.gl;\n\n    if (location !== -1) {\n      gl.disableVertexAttribArray(location);\n\n      if (this.isInstanced && unsetDivisor) {\n        if (gl instanceof WebGL2RenderingContext) {\n          gl.vertexAttribDivisor(location, 0);\n        } else {\n          const ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n          if (ext) ext.vertexAttribDivisorANGLE(location, 0);\n        }\n      }\n    }\n  }\n\n  reallocate(capacity: number): void {\n    // If desired capacity has not changed we do nothing\n    // NOTE: it's possible here to implement more subtle reallocation schemes\n    // when the number of rendered items increase or decrease\n    if (capacity === this.capacity) return;\n\n    this.capacity = capacity;\n    this.verticesCount = this.VERTICES * capacity;\n    this.array = new Float32Array(\n      !this.isInstanced\n        ? this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT\n        : this.capacity * this.ATTRIBUTES_ITEMS_COUNT,\n    );\n  }\n\n  hasNothingToRender(): boolean {\n    return this.verticesCount === 0;\n  }\n\n  abstract setUniforms(params: RenderParams, programInfo: ProgramInfo): void;\n\n  protected renderProgram(params: RenderParams, programInfo: ProgramInfo): void {\n    const { gl, program } = programInfo;\n\n    // With the current fix for #1397, the alpha blending is enabled for the\n    // picking layer:\n    gl.enable(gl.BLEND);\n\n    // Original code:\n    // if (!isPicking) gl.enable(gl.BLEND);\n    // else gl.disable(gl.BLEND);\n\n    gl.useProgram(program);\n    this.setUniforms(params, programInfo);\n    this.drawWebGL(this.METHOD, programInfo);\n  }\n\n  render(params: RenderParams): void {\n    if (this.hasNothingToRender()) return;\n\n    if (this.pickProgram) {\n      this.pickProgram.gl.viewport(\n        0,\n        0,\n        (params.width * params.pixelRatio) / params.downSizingRatio,\n        (params.height * params.pixelRatio) / params.downSizingRatio,\n      );\n      this.bindProgram(this.pickProgram);\n      this.renderProgram({ ...params, pixelRatio: params.pixelRatio / params.downSizingRatio }, this.pickProgram);\n      this.unbindProgram(this.pickProgram);\n    }\n\n    this.normalProgram.gl.viewport(0, 0, params.width * params.pixelRatio, params.height * params.pixelRatio);\n    this.bindProgram(this.normalProgram);\n    this.renderProgram(params, this.normalProgram);\n    this.unbindProgram(this.normalProgram);\n  }\n\n  drawWebGL(method: GLenum, { gl, frameBuffer }: ProgramInfo): void {\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n\n    if (!this.isInstanced) {\n      gl.drawArrays(method, 0, this.verticesCount);\n    } else {\n      if (gl instanceof WebGL2RenderingContext) {\n        gl.drawArraysInstanced(method, 0, this.VERTICES, this.capacity);\n      } else {\n        const ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n        if (ext) ext.drawArraysInstancedANGLE(method, 0, this.VERTICES, this.capacity);\n      }\n    }\n  }\n}\n","/**\n * Sigma.js WebGL Abstract Node Program\n * =====================================\n *\n * @module\n */\nimport Sigma from \"../sigma\";\nimport { AbstractProgram, Program } from \"./program\";\nimport { NodeDisplayData, NonEmptyArray, RenderParams } from \"../types\";\nimport { NodeLabelDrawingFunction } from \"./node-labels\";\nimport { NodeHoverDrawingFunction } from \"./node-hover\";\nimport { indexToColor } from \"../utils\";\n\nexport abstract class AbstractNodeProgram extends AbstractProgram {\n  static drawLabel: NodeLabelDrawingFunction | undefined;\n  static drawHover: NodeHoverDrawingFunction | undefined;\n  abstract process(nodeIndex: number, offset: number, data: NodeDisplayData): void;\n}\n\nexport abstract class NodeProgram<Uniform extends string = string>\n  extends Program<Uniform>\n  implements AbstractNodeProgram\n{\n  static drawLabel: NodeLabelDrawingFunction | undefined = undefined;\n  static drawHover: NodeHoverDrawingFunction | undefined = undefined;\n\n  process(nodeIndex: number, offset: number, data: NodeDisplayData): void {\n    let i = offset * this.STRIDE;\n    // NOTE: dealing with hidden items automatically\n    if (data.hidden) {\n      for (let l = i + this.STRIDE; i < l; i++) {\n        this.array[i] = 0;\n      }\n      return;\n    }\n\n    return this.processVisibleItem(indexToColor(nodeIndex), i, data);\n  }\n\n  abstract processVisibleItem(nodeIndex: number, i: number, data: NodeDisplayData): void;\n}\n\nclass NodeImageClass implements AbstractNodeProgram {\n  static drawLabel: NodeLabelDrawingFunction | undefined = undefined;\n  static drawHover: NodeHoverDrawingFunction | undefined = undefined;\n\n  constructor(_gl: WebGLRenderingContext, _pickingBuffer: WebGLFramebuffer | null, _renderer: Sigma) {\n    return this;\n  }\n  reallocate(_capacity: number): void {\n    return undefined;\n  }\n  process(_nodeIndex: number, _offset: number, _data: NodeDisplayData): void {\n    return undefined;\n  }\n  render(_params: RenderParams): void {\n    return undefined;\n  }\n}\nexport type NodeProgramType = typeof NodeImageClass;\n\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional node \"draw label\" function.\n * @param  {function} drawHover - An optional node \"draw hover\" function.\n * @return {function}\n */\nexport function createNodeCompoundProgram(\n  programClasses: NonEmptyArray<NodeProgramType>,\n  drawLabel?: NodeLabelDrawingFunction,\n  drawHover?: NodeLabelDrawingFunction,\n): NodeProgramType {\n  return class NodeCompoundProgram implements AbstractNodeProgram {\n    static drawLabel = drawLabel;\n    static drawHover = drawHover;\n\n    programs: NonEmptyArray<AbstractNodeProgram>;\n\n    constructor(gl: WebGLRenderingContext, pickingBuffer: WebGLFramebuffer | null, renderer: Sigma) {\n      this.programs = programClasses.map((Program) => {\n        return new Program(gl, pickingBuffer, renderer);\n      }) as unknown as NonEmptyArray<AbstractNodeProgram>;\n    }\n\n    reallocate(capacity: number): void {\n      this.programs.forEach((program) => program.reallocate(capacity));\n    }\n\n    process(nodeIndex: number, offset: number, data: NodeDisplayData): void {\n      this.programs.forEach((program) => program.process(nodeIndex, offset, data));\n    }\n\n    render(params: RenderParams): void {\n      this.programs.forEach((program) => program.render(params));\n    }\n  };\n}\n","attribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_position;\nattribute float a_size;\n\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\n\n  v_border = (0.5 / a_size) * u_sizeRatio;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n","precision mediump float;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float radius = 0.5;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\n  float dist = radius - length(m);\n\n  // No antialiasing for picking mode:\n  #ifdef PICKING_MODE\n  if (dist > v_border)\n    gl_FragColor = v_color;\n  else\n    gl_FragColor = transparent;\n\n  #else\n  float t = 0.0;\n  if (dist > v_border)\n    t = 1.0;\n  else if (dist > 0.0)\n    t = dist / v_border;\n\n  gl_FragColor = mix(transparent, v_color, t);\n  #endif\n}\n","/**\n * Sigma.js WebGL Renderer Node Program\n * =====================================\n *\n * Simple program rendering nodes using GL_POINTS. This is faster than the\n * three triangle option but has some quirks and is not supported equally by\n * every GPU.\n * @module\n */\nimport { NodeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { NodeProgram } from \"../../node\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport { ProgramInfo } from \"../../program\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\"u_sizeRatio\", \"u_pixelRatio\", \"u_matrix\"] as const;\n\nexport default class NodePointProgram extends NodeProgram<(typeof UNIFORMS)[number]> {\n  getDefinition() {\n    return {\n      VERTICES: 1,\n      VERTEX_SHADER_SOURCE,\n      FRAGMENT_SHADER_SOURCE,\n      METHOD: WebGLRenderingContext.POINTS,\n      UNIFORMS,\n      ATTRIBUTES: [\n        { name: \"a_position\", size: 2, type: FLOAT },\n        { name: \"a_size\", size: 1, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n      ],\n    };\n  }\n\n  processVisibleItem(nodeIndex: number, startIndex: number, data: NodeDisplayData) {\n    const array = this.array;\n\n    array[startIndex++] = data.x;\n    array[startIndex++] = data.y;\n    array[startIndex++] = data.size;\n    array[startIndex++] = floatColor(data.color);\n    array[startIndex++] = nodeIndex;\n  }\n\n  setUniforms({ sizeRatio, pixelRatio, matrix }: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n    const { u_sizeRatio, u_pixelRatio, u_matrix } = uniformLocations;\n\n    gl.uniform1f(u_pixelRatio, pixelRatio);\n    gl.uniform1f(u_sizeRatio, sizeRatio);\n    gl.uniformMatrix3fv(u_matrix, false, matrix);\n  }\n}\n","/**\n * Sigma.js WebGL Abstract Edge Program\n * =====================================\n *\n * @module\n */\nimport Sigma from \"../sigma\";\nimport { AbstractProgram, Program } from \"./program\";\nimport { NodeDisplayData, EdgeDisplayData, RenderParams } from \"../types\";\nimport { EdgeLabelDrawingFunction } from \"./edge-labels\";\nimport { indexToColor } from \"../utils\";\n\nexport abstract class AbstractEdgeProgram extends AbstractProgram {\n  static drawLabel: EdgeLabelDrawingFunction | undefined;\n\n  abstract process(\n    edgeIndex: number,\n    offset: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ): void;\n}\n\nexport abstract class EdgeProgram<Uniform extends string = string>\n  extends Program<Uniform>\n  implements AbstractEdgeProgram\n{\n  static drawLabel: EdgeLabelDrawingFunction | undefined = undefined;\n\n  process(\n    edgeIndex: number,\n    offset: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ): void {\n    let i = offset * this.STRIDE;\n    // NOTE: dealing with hidden items automatically\n    if (data.hidden || sourceData.hidden || targetData.hidden) {\n      for (let l = i + this.STRIDE; i < l; i++) {\n        this.array[i] = 0;\n      }\n      return;\n    }\n\n    return this.processVisibleItem(indexToColor(edgeIndex), i, sourceData, targetData, data);\n  }\n\n  abstract processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ): void;\n}\n\nclass EdgeImageClass implements AbstractEdgeProgram {\n  static drawLabel: EdgeLabelDrawingFunction | undefined = undefined;\n\n  constructor(_gl: WebGLRenderingContext, _pickingBuffer: WebGLFramebuffer | null, _renderer: Sigma) {\n    return this;\n  }\n  reallocate(_capacity: number): void {\n    return undefined;\n  }\n  process(\n    _edgeIndex: number,\n    _offset: number,\n    _sourceData: NodeDisplayData,\n    _targetData: NodeDisplayData,\n    _data: EdgeDisplayData,\n  ): void {\n    return undefined;\n  }\n  render(_params: RenderParams): void {\n    return undefined;\n  }\n}\nexport type EdgeProgramType = typeof EdgeImageClass;\n\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional edge \"draw label\" function.\n * @return {function}\n */\nexport function createEdgeCompoundProgram(\n  programClasses: Array<EdgeProgramType>,\n  drawLabel?: EdgeLabelDrawingFunction,\n): EdgeProgramType {\n  return class EdgeCompoundProgram implements AbstractEdgeProgram {\n    static drawLabel = drawLabel;\n\n    programs: Array<AbstractEdgeProgram>;\n\n    constructor(gl: WebGLRenderingContext, pickingBuffer: WebGLFramebuffer | null, renderer: Sigma) {\n      this.programs = programClasses.map((Program) => {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n\n    reallocate(capacity: number): void {\n      this.programs.forEach((program) => program.reallocate(capacity));\n    }\n\n    process(\n      edgeIndex: number,\n      offset: number,\n      sourceData: NodeDisplayData,\n      targetData: NodeDisplayData,\n      data: EdgeDisplayData,\n    ): void {\n      this.programs.forEach((program) => program.process(edgeIndex, offset, sourceData, targetData, data));\n    }\n\n    render(params: RenderParams): void {\n      this.programs.forEach((program) => program.render(params));\n    }\n  };\n}\n","attribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_zoomRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n\n  // We require edges to be at least `minThickness` pixels thick *on screen*\n  // (so we need to compensate the size ratio):\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\n  // referential (in a ([0, 1], [0, 1]) space), using our \"magic\" correction\n  // ratio:\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\n\n  // For the fragment shader though, we need a thickness that takes the \"magic\"\n  // correction ratio into account (as in webGLThickness), but so that the\n  // antialiasing effect does not depend on the zoom level. So here's yet\n  // another thickness version:\n  v_thickness = webGLThickness / u_zoomRatio;\n\n  v_normal = unitNormal;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n","precision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float feather = 0.001;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  // We only handle antialiasing for normal mode:\n  #ifdef PICKING_MODE\n  gl_FragColor = v_color;\n  #else\n  float dist = length(v_normal) * v_thickness;\n\n  float t = smoothstep(\n    v_thickness - feather,\n    v_thickness,\n    dist\n  );\n\n  gl_FragColor = mix(v_color, transparent, t);\n  #endif\n}\n","/**\n * Sigma.js WebGL Renderer Edge Program\n * =====================================\n *\n * Program rendering edges as thick lines using four points translated\n * orthogonally from the source & target's centers by half thickness.\n *\n * Rendering two triangles by using only four points is made possible through\n * the use of indices.\n *\n * This method should be faster than the 6 points / 2 triangles approach and\n * should handle thickness better than with gl.LINES.\n *\n * This version of the shader balances geometry computation evenly between\n * the CPU & GPU (normals are computed on the CPU side).\n * @module\n */\nimport { NodeDisplayData, EdgeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { EdgeProgram } from \"../../edge\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport { ProgramInfo } from \"../../program\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\"] as const;\n\nexport default class EdgeRectangleProgram extends EdgeProgram<(typeof UNIFORMS)[number]> {\n  getDefinition() {\n    return {\n      VERTICES: 6,\n      VERTEX_SHADER_SOURCE,\n      FRAGMENT_SHADER_SOURCE,\n      METHOD: WebGLRenderingContext.TRIANGLES,\n      UNIFORMS,\n      ATTRIBUTES: [\n        { name: \"a_positionStart\", size: 2, type: FLOAT },\n        { name: \"a_positionEnd\", size: 2, type: FLOAT },\n        { name: \"a_normal\", size: 2, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n      ],\n      CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 2, then position will be a_positionEnd\n        { name: \"a_positionCoef\", size: 1, type: FLOAT },\n        { name: \"a_normalCoef\", size: 1, type: FLOAT },\n      ],\n      CONSTANT_DATA: [\n        [0, 1],\n        [0, -1],\n        [1, 1],\n        [1, 1],\n        [0, -1],\n        [1, -1],\n      ],\n    };\n  }\n\n  processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ) {\n    const thickness = data.size || 1;\n    const x1 = sourceData.x;\n    const y1 = sourceData.y;\n    const x2 = targetData.x;\n    const y2 = targetData.y;\n    const color = floatColor(data.color);\n\n    // Computing normals\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n\n    let len = dx * dx + dy * dy;\n    let n1 = 0;\n    let n2 = 0;\n\n    if (len) {\n      len = 1 / Math.sqrt(len);\n\n      n1 = -dy * len * thickness;\n      n2 = dx * len * thickness;\n    }\n\n    const array = this.array;\n\n    array[startIndex++] = x1;\n    array[startIndex++] = y1;\n    array[startIndex++] = x2;\n    array[startIndex++] = y2;\n    array[startIndex++] = n1;\n    array[startIndex++] = n2;\n    array[startIndex++] = color;\n    array[startIndex++] = edgeIndex;\n  }\n\n  setUniforms(params: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n    const { u_matrix, u_zoomRatio, u_correctionRatio, u_sizeRatio } = uniformLocations;\n\n    gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    gl.uniform1f(u_zoomRatio, params.zoomRatio);\n    gl.uniform1f(u_sizeRatio, params.sizeRatio);\n    gl.uniform1f(u_correctionRatio, params.correctionRatio);\n  }\n}\n","attribute vec2 a_position;\nattribute vec2 a_normal;\nattribute float a_radius;\nattribute vec3 a_barycentric;\n\n#ifdef PICKING_MODE\nattribute vec4 a_id;\n#else\nattribute vec4 a_color;\n#endif\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\nconst float arrowHeadWidthLengthRatio = 0.66;\nconst float arrowHeadLengthThicknessRatio = 2.5;\n\nvoid main() {\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl and\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\n  // happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\n  float webGLArrowHeadHalfWidth = webGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;\n\n  float da = a_barycentric.x;\n  float db = a_barycentric.y;\n  float dc = a_barycentric.z;\n\n  vec2 delta = vec2(\n      da * (webGLNodeRadius * unitNormal.y)\n    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadHalfWidth * unitNormal.x)\n    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadHalfWidth * unitNormal.x),\n\n      da * (-webGLNodeRadius * unitNormal.x)\n    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadHalfWidth * unitNormal.y)\n    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadHalfWidth * unitNormal.y)\n  );\n\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\n\n  gl_Position = vec4(position, 0, 1);\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n","precision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n","/**\n * Sigma.js WebGL Renderer Arrow Program\n * ======================================\n *\n * Program rendering direction arrows as a simple triangle.\n * @module\n */\nimport { NodeDisplayData, EdgeDisplayData, RenderParams } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\nimport { EdgeProgram } from \"../../edge\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\nimport FRAGMENT_SHADER_SOURCE from \"./frag.glsl\";\nimport { ProgramInfo } from \"../../program\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nconst UNIFORMS = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\"] as const;\n\nexport default class EdgeArrowHeadProgram extends EdgeProgram<(typeof UNIFORMS)[number]> {\n  getDefinition() {\n    return {\n      VERTICES: 3,\n      VERTEX_SHADER_SOURCE,\n      FRAGMENT_SHADER_SOURCE,\n      METHOD: WebGLRenderingContext.TRIANGLES,\n      UNIFORMS,\n      ATTRIBUTES: [\n        { name: \"a_position\", size: 2, type: FLOAT },\n        { name: \"a_normal\", size: 2, type: FLOAT },\n        { name: \"a_radius\", size: 1, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n      ],\n      CONSTANT_ATTRIBUTES: [{ name: \"a_barycentric\", size: 3, type: FLOAT }],\n      CONSTANT_DATA: [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n      ],\n    };\n  }\n\n  processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ) {\n    const thickness = data.size || 1;\n    const radius = targetData.size || 1;\n    const x1 = sourceData.x;\n    const y1 = sourceData.y;\n    const x2 = targetData.x;\n    const y2 = targetData.y;\n    const color = floatColor(data.color);\n\n    // Computing normals\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n\n    let len = dx * dx + dy * dy;\n    let n1 = 0;\n    let n2 = 0;\n\n    if (len) {\n      len = 1 / Math.sqrt(len);\n\n      n1 = -dy * len * thickness;\n      n2 = dx * len * thickness;\n    }\n\n    const array = this.array;\n\n    array[startIndex++] = x2;\n    array[startIndex++] = y2;\n    array[startIndex++] = -n1;\n    array[startIndex++] = -n2;\n    array[startIndex++] = radius;\n    array[startIndex++] = color;\n    array[startIndex++] = edgeIndex;\n  }\n\n  setUniforms(params: RenderParams, { gl, uniformLocations }: ProgramInfo): void {\n    const { u_matrix, u_sizeRatio, u_correctionRatio } = uniformLocations;\n\n    gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    gl.uniform1f(u_sizeRatio, params.sizeRatio);\n    gl.uniform1f(u_correctionRatio, params.correctionRatio);\n  }\n}\n","attribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\nattribute float a_radius;\nattribute float a_radiusCoef;\n\nuniform mat3 u_matrix;\nuniform float u_zoomRatio;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\nconst float arrowHeadLengthThicknessRatio = 2.5;\n\nvoid main() {\n  float radius = a_radius * a_radiusCoef;\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl. Please read it to\n  // get better comments on what's happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  // Here, we move the point to leave space for the arrow head:\n  float direction = sign(radius);\n  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\n\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);\n\n  v_thickness = webGLThickness / u_zoomRatio;\n\n  v_normal = unitNormal;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n","/**\n * Sigma.js WebGL Renderer Edge Program\n * =====================================\n *\n * Program rendering edges as thick lines but with a twist: the end of edge\n * does not sit in the middle of target node but instead stays by some margin.\n *\n * This is useful when combined with arrows to draw directed edges.\n * @module\n */\nimport EdgeRectangleProgram from \"../edge-rectangle\";\nimport VERTEX_SHADER_SOURCE from \"./vert.glsl\";\nimport { EdgeDisplayData, NodeDisplayData } from \"../../../types\";\nimport { floatColor } from \"../../../utils\";\n\nconst { UNSIGNED_BYTE, FLOAT } = WebGLRenderingContext;\n\nexport default class EdgeClampedProgram extends EdgeRectangleProgram {\n  getDefinition() {\n    return {\n      ...super.getDefinition(),\n      VERTEX_SHADER_SOURCE,\n      ATTRIBUTES: [\n        { name: \"a_positionStart\", size: 2, type: FLOAT },\n        { name: \"a_positionEnd\", size: 2, type: FLOAT },\n        { name: \"a_normal\", size: 2, type: FLOAT },\n        { name: \"a_color\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_id\", size: 4, type: UNSIGNED_BYTE, normalized: true },\n        { name: \"a_radius\", size: 1, type: FLOAT },\n      ],\n      CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 1, then position will be a_positionEnd\n        { name: \"a_positionCoef\", size: 1, type: FLOAT },\n        { name: \"a_normalCoef\", size: 1, type: FLOAT },\n        { name: \"a_radiusCoef\", size: 1, type: FLOAT },\n      ],\n      CONSTANT_DATA: [\n        [0, 1, 0],\n        [0, -1, 0],\n        [1, 1, 1],\n        [1, 1, 1],\n        [0, -1, 0],\n        [1, -1, -1],\n      ],\n    };\n  }\n\n  processVisibleItem(\n    edgeIndex: number,\n    startIndex: number,\n    sourceData: NodeDisplayData,\n    targetData: NodeDisplayData,\n    data: EdgeDisplayData,\n  ) {\n    const thickness = data.size || 1;\n    const x1 = sourceData.x;\n    const y1 = sourceData.y;\n    const x2 = targetData.x;\n    const y2 = targetData.y;\n    const color = floatColor(data.color);\n\n    // Computing normals\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n\n    const radius = targetData.size || 1;\n\n    let len = dx * dx + dy * dy;\n    let n1 = 0;\n    let n2 = 0;\n\n    if (len) {\n      len = 1 / Math.sqrt(len);\n\n      n1 = -dy * len * thickness;\n      n2 = dx * len * thickness;\n    }\n\n    const array = this.array;\n\n    array[startIndex++] = x1;\n    array[startIndex++] = y1;\n    array[startIndex++] = x2;\n    array[startIndex++] = y2;\n    array[startIndex++] = n1;\n    array[startIndex++] = n2;\n    array[startIndex++] = color;\n    array[startIndex++] = edgeIndex;\n    array[startIndex++] = radius;\n  }\n}\n","/**\n * Sigma.js WebGL Renderer Edge Arrow Program\n * ===========================================\n *\n * Compound program rendering edges as an arrow from the source to the target.\n * @module\n */\nimport { createEdgeCompoundProgram } from \"../../edge\";\nimport EdgeArrowHeadProgram from \"../edge-arrow-head\";\nimport EdgeClampedProgram from \"../edge-clamped\";\n\nconst EdgeArrowProgram = createEdgeCompoundProgram([EdgeClampedProgram, EdgeArrowHeadProgram]);\n\nexport default EdgeArrowProgram;\n","import { EdgeDisplayData, NodeDisplayData, PartialButFor } from \"../types\";\nimport { Settings } from \"../settings\";\n\nexport type EdgeLabelDrawingFunction = (\n  context: CanvasRenderingContext2D,\n  edgeData: PartialButFor<EdgeDisplayData, \"label\" | \"color\" | \"size\">,\n  sourceData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  targetData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  settings: Settings,\n) => void;\n\nexport function drawStraightEdgeLabel(\n  context: CanvasRenderingContext2D,\n  edgeData: PartialButFor<EdgeDisplayData, \"label\" | \"color\" | \"size\">,\n  sourceData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  targetData: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\">,\n  settings: Settings,\n): void {\n  const size = settings.edgeLabelSize,\n    font = settings.edgeLabelFont,\n    weight = settings.edgeLabelWeight,\n    color = settings.edgeLabelColor.attribute\n      ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\"\n      : settings.edgeLabelColor.color;\n\n  let label = edgeData.label;\n\n  if (!label) return;\n\n  context.fillStyle = color;\n  context.font = `${weight} ${size}px ${font}`;\n\n  // Computing positions without considering nodes sizes:\n  const sSize = sourceData.size;\n  const tSize = targetData.size;\n  let sx = sourceData.x;\n  let sy = sourceData.y;\n  let tx = targetData.x;\n  let ty = targetData.y;\n  let cx = (sx + tx) / 2;\n  let cy = (sy + ty) / 2;\n  let dx = tx - sx;\n  let dy = ty - sy;\n  let d = Math.sqrt(dx * dx + dy * dy);\n\n  if (d < sSize + tSize) return;\n\n  // Adding nodes sizes:\n  sx += (dx * sSize) / d;\n  sy += (dy * sSize) / d;\n  tx -= (dx * tSize) / d;\n  ty -= (dy * tSize) / d;\n  cx = (sx + tx) / 2;\n  cy = (sy + ty) / 2;\n  dx = tx - sx;\n  dy = ty - sy;\n  d = Math.sqrt(dx * dx + dy * dy);\n\n  // Handling ellipsis\n  let textLength = context.measureText(label).width;\n\n  if (textLength > d) {\n    const ellipsis = \"…\";\n    label = label + ellipsis;\n    textLength = context.measureText(label).width;\n\n    while (textLength > d && label.length > 1) {\n      label = label.slice(0, -2) + ellipsis;\n      textLength = context.measureText(label).width;\n    }\n\n    if (label.length < 4) return;\n  }\n\n  let angle;\n  if (dx > 0) {\n    if (dy > 0) angle = Math.acos(dx / d);\n    else angle = Math.asin(dy / d);\n  } else {\n    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;\n    else angle = Math.asin(dx / d) + Math.PI / 2;\n  }\n\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n\n  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);\n\n  context.restore();\n}\n","import { NodeDisplayData, PartialButFor } from \"../types\";\nimport { Settings } from \"../settings\";\n\nexport type NodeLabelDrawingFunction = (\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings,\n) => void;\n\nexport function drawDiscNodeLabel(\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings,\n): void {\n  if (!data.label) return;\n\n  const size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight,\n    color = settings.labelColor.attribute\n      ? data[settings.labelColor.attribute] || settings.labelColor.color || \"#000\"\n      : settings.labelColor.color;\n\n  context.fillStyle = color;\n  context.font = `${weight} ${size}px ${font}`;\n\n  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}\n","import { Settings } from \"../settings\";\nimport { NodeDisplayData, PartialButFor } from \"../types\";\nimport { drawDiscNodeLabel } from \"./node-labels\";\n\nexport type NodeHoverDrawingFunction = (\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings,\n) => void;\n\n/**\n * Draw an hovered node.\n * - if there is no label => display a shadow on the node\n * - if the label box is bigger than node size => display a label box that contains the node with a shadow\n * - else node with shadow and the label box\n */\nexport function drawDiscNodeHover(\n  context: CanvasRenderingContext2D,\n  data: PartialButFor<NodeDisplayData, \"x\" | \"y\" | \"size\" | \"label\" | \"color\">,\n  settings: Settings,\n): void {\n  const size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight;\n\n  context.font = `${weight} ${size}px ${font}`;\n\n  // Then we draw the label background\n  context.fillStyle = \"#FFF\";\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 8;\n  context.shadowColor = \"#000\";\n\n  const PADDING = 2;\n\n  if (typeof data.label === \"string\") {\n    const textWidth = context.measureText(data.label).width,\n      boxWidth = Math.round(textWidth + 5),\n      boxHeight = Math.round(size + 2 * PADDING),\n      radius = Math.max(data.size, size / 2) + PADDING;\n\n    const angleRadian = Math.asin(boxHeight / 2 / radius);\n    const xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));\n\n    context.beginPath();\n    context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);\n    context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);\n    context.arc(data.x, data.y, radius, angleRadian, -angleRadian);\n    context.closePath();\n    context.fill();\n  } else {\n    context.beginPath();\n    context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);\n    context.closePath();\n    context.fill();\n  }\n\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 0;\n\n  // And finally we draw the label\n  drawDiscNodeLabel(context, data, settings);\n}\n","/**\n * Sigma.js Settings\n * =================================\n *\n * The list of settings and some handy functions.\n * @module\n */\nimport { Attributes } from \"graphology-types\";\n\nimport { assign } from \"./utils\";\nimport { EdgeDisplayData, NodeDisplayData } from \"./types\";\nimport NodePointProgram from \"./rendering/programs/node-point\";\nimport EdgeRectangleProgram from \"./rendering/programs/edge-rectangle\";\nimport EdgeArrowProgram from \"./rendering/programs/edge-arrow\";\nimport { EdgeProgramType } from \"./rendering\";\nimport { NodeProgramType } from \"./rendering\";\nimport { drawStraightEdgeLabel, EdgeLabelDrawingFunction } from \"./rendering/edge-labels\";\nimport { drawDiscNodeLabel, NodeLabelDrawingFunction } from \"./rendering/node-labels\";\nimport { drawDiscNodeHover, NodeHoverDrawingFunction } from \"./rendering/node-hover\";\n\n/**\n * Sigma.js settings\n * =================================\n */\nexport interface Settings {\n  // Performance\n  hideEdgesOnMove: boolean;\n  hideLabelsOnMove: boolean;\n  renderLabels: boolean;\n  renderEdgeLabels: boolean;\n  enableEdgeEvents: boolean;\n  // Component rendering\n  defaultNodeColor: string;\n  defaultNodeType: string;\n  defaultEdgeColor: string;\n  defaultEdgeType: string;\n  labelFont: string;\n  labelSize: number;\n  labelWeight: string;\n  labelColor: { attribute: string; color?: string } | { color: string; attribute?: undefined };\n  edgeLabelFont: string;\n  edgeLabelSize: number;\n  edgeLabelWeight: string;\n  edgeLabelColor: { attribute: string; color?: string } | { color: string; attribute?: undefined };\n  stagePadding: number;\n  zoomToSizeRatioFunction: (ratio: number) => number;\n  itemSizesReference: \"screen\" | \"positions\";\n  defaultDrawEdgeLabel: EdgeLabelDrawingFunction;\n  defaultDrawNodeLabel: NodeLabelDrawingFunction;\n  defaultDrawNodeHover: NodeHoverDrawingFunction;\n\n  // Labels\n  labelDensity: number;\n  labelGridCellSize: number;\n  labelRenderedSizeThreshold: number;\n\n  // Reducers\n  nodeReducer: null | ((node: string, data: Attributes) => Partial<NodeDisplayData>);\n  edgeReducer: null | ((edge: string, data: Attributes) => Partial<EdgeDisplayData>);\n\n  // Features\n  zIndex: boolean;\n  minCameraRatio: null | number;\n  maxCameraRatio: null | number;\n\n  // Lifecycle\n  allowInvalidContainer: boolean;\n\n  // Program classes\n  nodeProgramClasses: { [type: string]: NodeProgramType };\n  nodeHoverProgramClasses: { [type: string]: NodeProgramType };\n  edgeProgramClasses: { [type: string]: EdgeProgramType };\n}\n\nexport const DEFAULT_SETTINGS: Settings = {\n  // Performance\n  hideEdgesOnMove: false,\n  hideLabelsOnMove: false,\n  renderLabels: true,\n  renderEdgeLabels: false,\n  enableEdgeEvents: false,\n\n  // Component rendering\n  defaultNodeColor: \"#999\",\n  defaultNodeType: \"circle\",\n  defaultEdgeColor: \"#ccc\",\n  defaultEdgeType: \"line\",\n  labelFont: \"Arial\",\n  labelSize: 14,\n  labelWeight: \"normal\",\n  labelColor: { color: \"#000\" },\n  edgeLabelFont: \"Arial\",\n  edgeLabelSize: 14,\n  edgeLabelWeight: \"normal\",\n  edgeLabelColor: { attribute: \"color\" },\n  stagePadding: 30,\n  zoomToSizeRatioFunction: Math.sqrt,\n  itemSizesReference: \"screen\",\n  defaultDrawEdgeLabel: drawStraightEdgeLabel,\n  defaultDrawNodeLabel: drawDiscNodeLabel,\n  defaultDrawNodeHover: drawDiscNodeHover,\n\n  // Labels\n  labelDensity: 1,\n  labelGridCellSize: 100,\n  labelRenderedSizeThreshold: 6,\n\n  // Reducers\n  nodeReducer: null,\n  edgeReducer: null,\n\n  // Features\n  zIndex: false,\n  minCameraRatio: null,\n  maxCameraRatio: null,\n\n  // Lifecycle\n  allowInvalidContainer: false,\n\n  // Program classes\n  nodeProgramClasses: {},\n  nodeHoverProgramClasses: {},\n  edgeProgramClasses: {},\n};\n\nexport const DEFAULT_NODE_PROGRAM_CLASSES: Record<string, NodeProgramType> = {\n  circle: NodePointProgram,\n};\n\nexport const DEFAULT_EDGE_PROGRAM_CLASSES: Record<string, EdgeProgramType> = {\n  arrow: EdgeArrowProgram,\n  line: EdgeRectangleProgram,\n};\n\nexport function validateSettings(settings: Settings): void {\n  if (typeof settings.labelDensity !== \"number\" || settings.labelDensity < 0) {\n    throw new Error(\"Settings: invalid `labelDensity`. Expecting a positive number.\");\n  }\n\n  const { minCameraRatio, maxCameraRatio } = settings;\n  if (typeof minCameraRatio === \"number\" && typeof maxCameraRatio === \"number\" && maxCameraRatio < minCameraRatio) {\n    throw new Error(\n      \"Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`.\",\n    );\n  }\n}\n\nexport function resolveSettings(settings: Partial<Settings>): Settings {\n  const resolvedSettings = assign({}, DEFAULT_SETTINGS, settings);\n\n  resolvedSettings.nodeProgramClasses = assign({}, DEFAULT_NODE_PROGRAM_CLASSES, resolvedSettings.nodeProgramClasses);\n  resolvedSettings.edgeProgramClasses = assign({}, DEFAULT_EDGE_PROGRAM_CLASSES, resolvedSettings.edgeProgramClasses);\n\n  return resolvedSettings;\n}\n","/**\n * Sigma.js Touch Captor\n * ======================\n *\n * Sigma's captor dealing with touch.\n * @module\n */\nimport { CameraState, Coordinates, Dimensions, TouchCoords } from \"../../types\";\nimport Captor, { getPosition, getTouchCoords, getTouchesArray } from \"./captor\";\nimport Sigma from \"../../sigma\";\n\nconst DRAG_TIMEOUT = 200;\nconst TOUCH_INERTIA_RATIO = 3;\nconst TOUCH_INERTIA_DURATION = 200;\n\nexport type FakeSigmaMouseEvent = MouseEvent & { isFakeSigmaMouseEvent?: true };\n\n/**\n * Event types.\n */\nexport type TouchCaptorEvents = {\n  touchdown(coordinates: TouchCoords): void;\n  touchup(coordinates: TouchCoords): void;\n  touchmove(coordinates: TouchCoords): void;\n};\n\n/**\n * Touch captor class.\n *\n * @constructor\n */\nexport default class TouchCaptor extends Captor<TouchCaptorEvents> {\n  enabled = true;\n  isMoving = false;\n  hasMoved = false;\n  startCameraState?: CameraState;\n  touchMode = 0; // number of touches down\n  movingTimeout?: number;\n\n  startTouchesAngle?: number;\n  startTouchesDistance?: number;\n  startTouchesPositions: Coordinates[] = [];\n  lastTouchesPositions?: Coordinates[];\n  lastTouches?: Touch[];\n\n  constructor(container: HTMLElement, renderer: Sigma) {\n    super(container, renderer);\n\n    // Binding methods:\n    this.handleStart = this.handleStart.bind(this);\n    this.handleLeave = this.handleLeave.bind(this);\n    this.handleMove = this.handleMove.bind(this);\n\n    // Binding events\n    container.addEventListener(\"touchstart\", this.handleStart, false);\n    container.addEventListener(\"touchend\", this.handleLeave, false);\n    container.addEventListener(\"touchcancel\", this.handleLeave, false);\n    container.addEventListener(\"touchmove\", this.handleMove, false);\n  }\n\n  kill(): void {\n    const container = this.container;\n\n    container.removeEventListener(\"touchstart\", this.handleStart);\n    container.removeEventListener(\"touchend\", this.handleLeave);\n    container.removeEventListener(\"touchcancel\", this.handleLeave);\n    container.removeEventListener(\"touchmove\", this.handleMove);\n  }\n\n  getDimensions(): Dimensions {\n    return {\n      width: this.container.offsetWidth,\n      height: this.container.offsetHeight,\n    };\n  }\n\n  dispatchRelatedMouseEvent(type: string, e: TouchEvent, touch?: Touch, emitter?: EventTarget): void {\n    const mousePosition = touch || e.touches[0];\n    const mouseEvent = new MouseEvent(type, {\n      clientX: mousePosition.clientX,\n      clientY: mousePosition.clientY,\n      altKey: e.altKey,\n      ctrlKey: e.ctrlKey,\n    });\n\n    (mouseEvent as FakeSigmaMouseEvent).isFakeSigmaMouseEvent = true;\n\n    (emitter || this.container).dispatchEvent(mouseEvent);\n  }\n\n  handleStart(e: TouchEvent): void {\n    if (!this.enabled) return;\n\n    // Prevent default to avoid default browser behaviors...\n    e.preventDefault();\n    // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n    if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousedown\", e);\n\n    const touches = getTouchesArray(e.touches);\n    this.touchMode = touches.length;\n\n    this.startCameraState = this.renderer.getCamera().getState();\n    this.startTouchesPositions = touches.map((touch) => getPosition(touch, this.container));\n    this.lastTouches = touches;\n    this.lastTouchesPositions = this.startTouchesPositions;\n\n    // When there are two touches down, let's record distance and angle as well:\n    if (this.touchMode === 2) {\n      const [{ x: x0, y: y0 }, { x: x1, y: y1 }] = this.startTouchesPositions;\n      this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n      this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n    }\n\n    this.emit(\"touchdown\", getTouchCoords(e, this.container));\n  }\n\n  handleLeave(e: TouchEvent): void {\n    if (!this.enabled) return;\n\n    // Prevent default to avoid default browser behaviors...\n    e.preventDefault();\n    // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n    if (e.touches.length === 0 && this.lastTouches && this.lastTouches.length) {\n      this.dispatchRelatedMouseEvent(\"mouseup\", e, this.lastTouches[0], document);\n      // ... and only click if no move was made\n      if (!this.hasMoved) {\n        this.dispatchRelatedMouseEvent(\"click\", e, this.lastTouches[0]);\n      }\n    }\n\n    if (this.movingTimeout) {\n      this.isMoving = false;\n      clearTimeout(this.movingTimeout);\n    }\n\n    switch (this.touchMode) {\n      case 2:\n        if (e.touches.length === 1) {\n          this.handleStart(e);\n\n          e.preventDefault();\n          break;\n        }\n      /* falls through */\n      case 1:\n        // TODO\n        // Dispatch event\n\n        if (this.isMoving) {\n          const camera = this.renderer.getCamera();\n          const cameraState = camera.getState(),\n            previousCameraState = camera.getPreviousState() || { x: 0, y: 0 };\n\n          camera.animate(\n            {\n              x: cameraState.x + TOUCH_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + TOUCH_INERTIA_RATIO * (cameraState.y - previousCameraState.y),\n            },\n            {\n              duration: TOUCH_INERTIA_DURATION,\n              easing: \"quadraticOut\",\n            },\n          );\n        }\n\n        this.hasMoved = false;\n        this.isMoving = false;\n        this.touchMode = 0;\n        break;\n    }\n\n    this.emit(\"touchup\", getTouchCoords(e, this.container));\n  }\n\n  handleMove(e: TouchEvent): void {\n    if (!this.enabled) return;\n\n    // Prevent default to avoid default browser behaviors...\n    e.preventDefault();\n    // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n    if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousemove\", e);\n\n    const touches = getTouchesArray(e.touches);\n    const touchesPositions = touches.map((touch) => getPosition(touch, this.container));\n    this.lastTouches = touches;\n    this.lastTouchesPositions = touchesPositions;\n\n    // If a move was initiated at some point and we get back to startpoint,\n    // we should still consider that we did move (which also happens after a\n    // multiple touch when only one touch remains in which case handleStart\n    // is recalled within handleLeave).\n    // Now, some mobile browsers report zero-distance moves so we also check that\n    // one of the touches did actually move from the origin position.\n    this.hasMoved ||= touchesPositions.some((position, idx) => {\n      const startPosition = this.startTouchesPositions[idx];\n\n      return position.x !== startPosition.x || position.y !== startPosition.y;\n    });\n\n    // If there was no move, do not trigger touch moves behavior\n    if (!this.hasMoved) {\n      return;\n    }\n\n    this.isMoving = true;\n\n    if (this.movingTimeout) clearTimeout(this.movingTimeout);\n\n    this.movingTimeout = window.setTimeout(() => {\n      this.isMoving = false;\n    }, DRAG_TIMEOUT);\n\n    const camera = this.renderer.getCamera();\n    const startCameraState = this.startCameraState as CameraState;\n\n    switch (this.touchMode) {\n      case 1: {\n        const { x: xStart, y: yStart } = this.renderer.viewportToFramedGraph(\n          (this.startTouchesPositions || [])[0] as Coordinates,\n        );\n        const { x, y } = this.renderer.viewportToFramedGraph(touchesPositions[0]);\n\n        camera.setState({\n          x: startCameraState.x + xStart - x,\n          y: startCameraState.y + yStart - y,\n        });\n        break;\n      }\n      case 2: {\n        /**\n         * Here is the thinking here:\n         *\n         * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n         *    of the d'n'd and now\n         *\n         * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n         *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n         *    position of this same touch now\n         */\n        const newCameraState: Partial<CameraState> = {};\n\n        const { x: x0, y: y0 } = touchesPositions[0];\n        const { x: x1, y: y1 } = touchesPositions[1];\n\n        const angleDiff = Math.atan2(y1 - y0, x1 - x0) - (this.startTouchesAngle as number);\n        const ratioDiff = Math.hypot(y1 - y0, x1 - x0) / (this.startTouchesDistance as number);\n\n        // 1.\n        const newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n        newCameraState.ratio = newRatio;\n        newCameraState.angle = startCameraState.angle + angleDiff;\n\n        // 2.\n        const dimensions = this.getDimensions();\n        const touchGraphPosition = this.renderer.viewportToFramedGraph(\n          (this.startTouchesPositions || [])[0] as Coordinates,\n          { cameraState: startCameraState },\n        );\n        const smallestDimension = Math.min(dimensions.width, dimensions.height);\n\n        const dx = smallestDimension / dimensions.width;\n        const dy = smallestDimension / dimensions.height;\n        const ratio = newRatio / smallestDimension;\n\n        // Align with center of the graph:\n        let x = x0 - smallestDimension / 2 / dx;\n        let y = y0 - smallestDimension / 2 / dy;\n\n        // Rotate:\n        [x, y] = [\n          x * Math.cos(-newCameraState.angle) - y * Math.sin(-newCameraState.angle),\n          y * Math.cos(-newCameraState.angle) + x * Math.sin(-newCameraState.angle),\n        ];\n\n        newCameraState.x = touchGraphPosition.x - x * ratio;\n        newCameraState.y = touchGraphPosition.y + y * ratio;\n\n        camera.setState(newCameraState);\n\n        break;\n      }\n    }\n\n    this.emit(\"touchmove\", getTouchCoords(e, this.container));\n  }\n}\n","/**\n * Extend function\n * ================\n *\n * Function used to push a bunch of values into an array at once.\n * Freely inspired by @Yomguithereal/helpers/extend.\n */\n\n/**\n * Extends the target array with the given values.\n *\n * @param  {array} array  - Target array.\n * @param  {array} values - A set of the values to add.\n */\nexport function extend<T>(array: T[], values: Set<T>): void {\n  const l2 = values.size;\n\n  if (l2 === 0) return;\n\n  const l1 = array.length;\n\n  array.length += l2;\n\n  let i = 0;\n  values.forEach((value) => {\n    array[l1 + i] = value;\n    i++;\n  });\n}\n","export function getPixelColor(\n  gl: WebGLRenderingContext,\n  frameBuffer: WebGLBuffer | null,\n  x: number,\n  y: number,\n  pixelRatio: number,\n  downSizingRatio: number,\n): [number, number, number, number] {\n  const bufferX = Math.floor((x / downSizingRatio) * pixelRatio);\n  const bufferY = Math.floor(gl.drawingBufferHeight / downSizingRatio - (y / downSizingRatio) * pixelRatio);\n\n  const pixel = new Uint8Array(4);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.readPixels(bufferX, bufferY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n  const [r, g, b, a] = pixel;\n  return [r, g, b, a];\n}\n","/**\n * Sigma.js\n * ========\n * @module\n */\nimport Graph from \"graphology-types\";\n\nimport Camera from \"./core/camera\";\nimport MouseCaptor from \"./core/captors/mouse\";\nimport {\n  CameraState,\n  Coordinates,\n  Dimensions,\n  EdgeDisplayData,\n  Extent,\n  Listener,\n  MouseCoords,\n  NodeDisplayData,\n  PlainObject,\n  CoordinateConversionOverride,\n  TypedEventEmitter,\n  MouseInteraction,\n  RenderParams,\n} from \"./types\";\nimport {\n  createElement,\n  getPixelRatio,\n  createNormalizationFunction,\n  NormalizationFunction,\n  cancelFrame,\n  matrixFromCamera,\n  requestFrame,\n  validateGraph,\n  zIndexOrdering,\n  getMatrixImpact,\n  graphExtent,\n  colorToIndex,\n} from \"./utils\";\nimport { edgeLabelsToDisplayFromNodes, LabelGrid } from \"./core/labels\";\nimport { Settings, validateSettings, resolveSettings } from \"./settings\";\nimport { AbstractNodeProgram } from \"./rendering/node\";\nimport { AbstractEdgeProgram } from \"./rendering/edge\";\nimport TouchCaptor, { FakeSigmaMouseEvent } from \"./core/captors/touch\";\nimport { identity, multiplyVec2 } from \"./utils/matrices\";\nimport { extend } from \"./utils/array\";\nimport { getPixelColor } from \"./utils/picking\";\n\n/**\n * Constants.\n */\nconst X_LABEL_MARGIN = 150;\nconst Y_LABEL_MARGIN = 50;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings: Settings, key: string, data: Partial<NodeDisplayData>): NodeDisplayData {\n  if (!data.hasOwnProperty(\"x\") || !data.hasOwnProperty(\"y\"))\n    throw new Error(\n      `Sigma: could not find a valid position (x, y) for node \"${key}\". All your nodes must have a number \"x\" and \"y\". Maybe your forgot to apply a layout or your \"nodeReducer\" is not returning the correct data?`,\n    );\n\n  if (!data.color) data.color = settings.defaultNodeColor;\n\n  if (!data.label && data.label !== \"\") data.label = null;\n\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;\n  else data.label = null;\n\n  if (!data.size) data.size = 2;\n\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n\n  if (!data.hasOwnProperty(\"highlighted\")) data.highlighted = false;\n\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n\n  if (!data.zIndex) data.zIndex = 0;\n\n  return data as NodeDisplayData;\n}\n\nfunction applyEdgeDefaults(settings: Settings, _key: string, data: Partial<EdgeDisplayData>): EdgeDisplayData {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n\n  if (!data.label) data.label = \"\";\n\n  if (!data.size) data.size = 0.5;\n\n  if (!data.hasOwnProperty(\"hidden\")) data.hidden = false;\n\n  if (!data.hasOwnProperty(\"forceLabel\")) data.forceLabel = false;\n\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n\n  if (!data.zIndex) data.zIndex = 0;\n\n  return data as EdgeDisplayData;\n}\n\n/**\n * Event types.\n */\nexport interface SigmaEventPayload {\n  event: MouseCoords;\n  preventSigmaDefault(): void;\n}\n\nexport interface SigmaStageEventPayload extends SigmaEventPayload {}\nexport interface SigmaNodeEventPayload extends SigmaEventPayload {\n  node: string;\n}\nexport interface SigmaEdgeEventPayload extends SigmaEventPayload {\n  edge: string;\n}\n\nexport type SigmaStageEvents = {\n  [E in MouseInteraction as `${E}Stage`]: (payload: SigmaStageEventPayload) => void;\n};\n\nexport type SigmaNodeEvents = {\n  [E in MouseInteraction as `${E}Node`]: (payload: SigmaNodeEventPayload) => void;\n};\n\nexport type SigmaEdgeEvents = {\n  [E in MouseInteraction as `${E}Edge`]: (payload: SigmaEdgeEventPayload) => void;\n};\n\nexport type SigmaAdditionalEvents = {\n  // Lifecycle events\n  beforeRender(): void;\n  afterRender(): void;\n  resize(): void;\n  kill(): void;\n\n  // Additional node events\n  enterNode(payload: SigmaNodeEventPayload): void;\n  leaveNode(payload: SigmaNodeEventPayload): void;\n\n  // Additional edge events\n  enterEdge(payload: SigmaEdgeEventPayload): void;\n  leaveEdge(payload: SigmaEdgeEventPayload): void;\n};\n\nexport type SigmaEvents = SigmaStageEvents & SigmaNodeEvents & SigmaEdgeEvents & SigmaAdditionalEvents;\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nexport default class Sigma<GraphType extends Graph = Graph> extends TypedEventEmitter<SigmaEvents> {\n  private settings: Settings;\n  private graph: GraphType;\n  private mouseCaptor: MouseCaptor;\n  private touchCaptor: TouchCaptor;\n  private container: HTMLElement;\n  private elements: PlainObject<HTMLCanvasElement> = {};\n  private canvasContexts: PlainObject<CanvasRenderingContext2D> = {};\n  private webGLContexts: PlainObject<WebGLRenderingContext> = {};\n  private pickingLayers: Set<string> = new Set();\n  private textures: PlainObject<WebGLTexture> = {};\n  private frameBuffers: PlainObject<WebGLFramebuffer> = {};\n  private activeListeners: PlainObject<Listener> = {};\n  private labelGrid: LabelGrid = new LabelGrid();\n  private nodeDataCache: Record<string, NodeDisplayData> = {};\n  private edgeDataCache: Record<string, EdgeDisplayData> = {};\n\n  // Indices to keep track of the index of the item inside programs\n  private nodeProgramIndex: Record<string, number> = {};\n  private edgeProgramIndex: Record<string, number> = {};\n  private nodesWithForcedLabels: Set<string> = new Set<string>();\n  private edgesWithForcedLabels: Set<string> = new Set<string>();\n  private nodeExtent: { x: Extent; y: Extent } = { x: [0, 1], y: [0, 1] };\n  private nodeZExtent: [number, number] = [Infinity, -Infinity];\n  private edgeZExtent: [number, number] = [Infinity, -Infinity];\n\n  private matrix: Float32Array = identity();\n  private invMatrix: Float32Array = identity();\n  private correctionRatio = 1;\n  private customBBox: { x: Extent; y: Extent } | null = null;\n  private normalizationFunction: NormalizationFunction = createNormalizationFunction({\n    x: [0, 1],\n    y: [0, 1],\n  });\n\n  // Cache:\n  private graphToViewportRatio = 1;\n  private itemIDsIndex: Record<number, { type: \"node\" | \"edge\"; id: string }> = {};\n  private nodeIndices: Record<string, number> = {};\n  private edgeIndices: Record<string, number> = {};\n\n  // Starting dimensions and pixel ratio\n  private width = 0;\n  private height = 0;\n  private pixelRatio = getPixelRatio();\n  private pickingDownSizingRatio = 2 * this.pixelRatio;\n\n  // Graph State\n  private displayedNodeLabels: Set<string> = new Set();\n  private displayedEdgeLabels: Set<string> = new Set();\n  private highlightedNodes: Set<string> = new Set();\n  private hoveredNode: string | null = null;\n  private hoveredEdge: string | null = null;\n\n  // Internal states\n  private renderFrame: number | null = null;\n  private renderHighlightedNodesFrame: number | null = null;\n  private needToProcess = false;\n  private checkEdgesEventsFrame: number | null = null;\n\n  // Programs\n  private nodePrograms: { [key: string]: AbstractNodeProgram } = {};\n  private nodeHoverPrograms: { [key: string]: AbstractNodeProgram } = {};\n  private edgePrograms: { [key: string]: AbstractEdgeProgram } = {};\n\n  private camera: Camera;\n\n  constructor(graph: GraphType, container: HTMLElement, settings: Partial<Settings> = {}) {\n    super();\n\n    // Resolving settings\n    this.settings = resolveSettings(settings);\n\n    // Validating\n    validateSettings(this.settings);\n    validateGraph(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    this.graph = graph;\n    this.container = container;\n\n    // Initializing contexts\n    this.createWebGLContext(\"edges\", { picking: settings.enableEdgeEvents });\n    this.createCanvasContext(\"edgeLabels\");\n    this.createWebGLContext(\"nodes\", { picking: true });\n    this.createCanvasContext(\"labels\");\n    this.createCanvasContext(\"hovers\");\n    this.createWebGLContext(\"hoverNodes\");\n    this.createCanvasContext(\"mouse\");\n\n    // Initial resize\n    this.resize();\n\n    // Loading programs\n    for (const type in this.settings.nodeProgramClasses) {\n      const NodeProgramClass = this.settings.nodeProgramClasses[type];\n      this.nodePrograms[type] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);\n\n      let NodeHoverProgram = NodeProgramClass;\n      if (type in this.settings.nodeHoverProgramClasses) {\n        NodeHoverProgram = this.settings.nodeHoverProgramClasses[type];\n      }\n\n      this.nodeHoverPrograms[type] = new NodeHoverProgram(this.webGLContexts.hoverNodes, null, this);\n    }\n\n    for (const type in this.settings.edgeProgramClasses) {\n      const EdgeProgramClass = this.settings.edgeProgramClasses[type];\n      this.edgePrograms[type] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);\n    }\n\n    // Initializing the camera\n    this.camera = new Camera();\n\n    // Binding camera events\n    this.bindCameraHandlers();\n\n    // Initializing captors\n    this.mouseCaptor = new MouseCaptor(this.elements.mouse, this);\n    this.touchCaptor = new TouchCaptor(this.elements.mouse, this);\n\n    // Binding event handlers\n    this.bindEventHandlers();\n\n    // Binding graph handlers\n    this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    this.refresh();\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to create a canvas element.\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  private createCanvas(id: string): HTMLCanvasElement {\n    const canvas: HTMLCanvasElement = createElement<HTMLCanvasElement>(\n      \"canvas\",\n      {\n        position: \"absolute\",\n      },\n      {\n        class: `sigma-${id}`,\n      },\n    );\n\n    this.elements[id] = canvas;\n    this.container.appendChild(canvas);\n\n    return canvas;\n  }\n\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  private createCanvasContext(id: string): this {\n    const canvas = this.createCanvas(id);\n\n    const contextOptions = {\n      preserveDrawingBuffer: false,\n      antialias: false,\n    };\n\n    this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions) as CanvasRenderingContext2D;\n\n    return this;\n  }\n\n  /**\n   * Internal function used to create a WebGL context and add the relevant DOM\n   * elements.\n   *\n   * @param  {string}  id      - Context's id.\n   * @param  {object?} options - #getContext params to override (optional)\n   * @return {Sigma}\n   */\n  private createWebGLContext(\n    id: string,\n    options?: { preserveDrawingBuffer?: boolean; antialias?: boolean; hidden?: boolean; picking?: boolean },\n  ): this {\n    const canvas = this.createCanvas(id);\n    if (options?.hidden) canvas.remove();\n\n    const contextOptions = {\n      preserveDrawingBuffer: false,\n      antialias: false,\n      ...(options || {}),\n    };\n\n    let context;\n\n    // First we try webgl2 for an easy performance boost\n    context = canvas.getContext(\"webgl2\", contextOptions);\n\n    // Else we fall back to webgl\n    if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n    // Edge, I am looking right at you...\n    if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n\n    const gl = context as WebGLRenderingContext;\n    this.webGLContexts[id] = gl;\n\n    // Blending:\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n    // Prepare frame buffer for picking layers:\n    if (options?.picking) {\n      this.pickingLayers.add(id);\n      const newFrameBuffer = gl.createFramebuffer();\n      if (!newFrameBuffer) throw new Error(`Sigma: cannot create a new frame buffer for layer ${id}`);\n      this.frameBuffers[id] = newFrameBuffer;\n    }\n\n    return this;\n  }\n\n  /**\n   * Method (re)binding WebGL texture (for picking).\n   *\n   * @return {Sigma}\n   */\n  private resetWebGLTexture(id: string): this {\n    const gl = this.webGLContexts[id] as WebGLRenderingContext;\n\n    const frameBuffer = this.frameBuffers[id];\n    const currentTexture = this.textures[id];\n    if (currentTexture) gl.deleteTexture(currentTexture);\n\n    const pickingTexture = gl.createTexture();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n\n    this.textures[id] = pickingTexture as WebGLTexture;\n\n    return this;\n  }\n\n  /**\n   * Method binding camera handlers.\n   *\n   * @return {Sigma}\n   */\n  private bindCameraHandlers(): this {\n    this.activeListeners.camera = () => {\n      this.scheduleRender();\n    };\n\n    this.camera.on(\"updated\", this.activeListeners.camera);\n\n    return this;\n  }\n\n  /**\n   * Method unbinding camera handlers.\n   *\n   * @return {Sigma}\n   */\n  private unbindCameraHandlers(): this {\n    this.camera.removeListener(\"updated\", this.activeListeners.camera);\n    return this;\n  }\n\n  /**\n   * Method that returns the closest node to a given position.\n   */\n  private getNodeAtPosition(position: Coordinates): string | null {\n    const { x, y } = position;\n    const color = getPixelColor(\n      this.webGLContexts.nodes,\n      this.frameBuffers.nodes,\n      x,\n      y,\n      this.pixelRatio,\n      this.pickingDownSizingRatio,\n    );\n    const index = colorToIndex(...color);\n    const itemAt = this.itemIDsIndex[index];\n\n    return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n  }\n\n  /**\n   * Method binding event handlers.\n   *\n   * @return {Sigma}\n   */\n  private bindEventHandlers(): this {\n    // Handling window resize\n    this.activeListeners.handleResize = () => {\n      // need to call a refresh to rebuild the labelgrid\n      this.scheduleRefresh();\n    };\n\n    window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n    // Handling mouse move\n    this.activeListeners.handleMove = (e: MouseCoords): void => {\n      const baseEvent = {\n        event: e,\n        preventSigmaDefault(): void {\n          e.preventSigmaDefault();\n        },\n      };\n\n      const nodeToHover = this.getNodeAtPosition(e);\n      if (nodeToHover && this.hoveredNode !== nodeToHover && !this.nodeDataCache[nodeToHover].hidden) {\n        // Handling passing from one node to the other directly\n        if (this.hoveredNode) this.emit(\"leaveNode\", { ...baseEvent, node: this.hoveredNode });\n\n        this.hoveredNode = nodeToHover;\n        this.emit(\"enterNode\", { ...baseEvent, node: nodeToHover });\n        this.scheduleHighlightedNodesRender();\n        return;\n      }\n\n      // Checking if the hovered node is still hovered\n      if (this.hoveredNode) {\n        if (this.getNodeAtPosition(e) !== this.hoveredNode) {\n          const node = this.hoveredNode;\n          this.hoveredNode = null;\n\n          this.emit(\"leaveNode\", { ...baseEvent, node });\n          this.scheduleHighlightedNodesRender();\n          return;\n        }\n      }\n\n      if (this.settings.enableEdgeEvents) {\n        this.checkEdgeHoverEvents(baseEvent);\n      }\n    };\n\n    // Handling click\n    const createMouseListener = (eventType: MouseInteraction): ((e: MouseCoords) => void) => {\n      return (e) => {\n        const baseEvent = {\n          event: e,\n          preventSigmaDefault(): void {\n            e.preventSigmaDefault();\n          },\n        };\n\n        const isFakeSigmaMouseEvent = (e.original as FakeSigmaMouseEvent).isFakeSigmaMouseEvent;\n        const nodeAtPosition = isFakeSigmaMouseEvent ? this.getNodeAtPosition(e) : this.hoveredNode;\n\n        if (nodeAtPosition)\n          return this.emit(`${eventType}Node`, {\n            ...baseEvent,\n            node: nodeAtPosition,\n          });\n\n        if (this.settings.enableEdgeEvents) {\n          const edge = this.getEdgeAtPoint(e.x, e.y);\n          if (edge) return this.emit(`${eventType}Edge`, { ...baseEvent, edge });\n        }\n\n        return this.emit(`${eventType}Stage`, baseEvent);\n      };\n    };\n\n    this.activeListeners.handleClick = createMouseListener(\"click\");\n    this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n    this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n    this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n    this.activeListeners.handleDown = createMouseListener(\"down\");\n\n    this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n    this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n    this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n    this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n    this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n    this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n\n    // TODO\n    // Deal with Touch captor events\n\n    return this;\n  }\n\n  /**\n   * Method binding graph handlers\n   *\n   * @return {Sigma}\n   */\n  private bindGraphHandlers(): this {\n    const graph = this.graph;\n\n    const LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n    this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = (e: { hints?: { attributes?: string[] } }) => {\n      const updatedFields = e.hints?.attributes;\n      // we process all nodes\n      this.graph.forEachNode((node) => this.updateNode(node));\n\n      // if coord, type or zIndex have changed, we need to schedule a render\n      // (zIndex for the programIndex)\n      const layoutChanged = !updatedFields || updatedFields.some((f) => LAYOUT_IMPACTING_FIELDS.has(f));\n      this.refresh({ partialGraph: { nodes: graph.nodes() }, skipIndexation: !layoutChanged, schedule: true });\n    };\n\n    this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = (e: { hints?: { attributes?: string[] } }) => {\n      const updatedFields = e.hints?.attributes;\n      // we process all edges\n      this.graph.forEachEdge((edge) => this.updateEdge(edge));\n      const layoutChanged = updatedFields && [\"zIndex\", \"type\"].some((f) => updatedFields?.includes(f));\n      this.refresh({ partialGraph: { edges: graph.edges() }, skipIndexation: !layoutChanged, schedule: true });\n    };\n\n    // On add node, we add the node in indices and then call for a render\n    this.activeListeners.addNodeGraphUpdate = (payload: { key: string }): void => {\n      const node = payload.key;\n      // we process the node\n      this.addNode(node);\n      // schedule a render for the node\n      this.refresh({ partialGraph: { nodes: [node] }, skipIndexation: false, schedule: true });\n    };\n\n    // On update node, we update indices and then call for a render\n    this.activeListeners.updateNodeGraphUpdate = (payload: { key: string }): void => {\n      const node = payload.key;\n      // schedule a render for the node\n      this.refresh({ partialGraph: { nodes: [node] }, skipIndexation: false, schedule: true });\n    };\n\n    // On drop node, we remove the node from indices and then call for a refresh\n    this.activeListeners.dropNodeGraphUpdate = (payload: { key: string }): void => {\n      const node = payload.key;\n      // we process the node\n      this.removeNode(node);\n      // schedule a render for everything\n      this.refresh({ schedule: true });\n    };\n\n    // On add edge, we remove the edge from indices and then call for a refresh\n    this.activeListeners.addEdgeGraphUpdate = (payload: { key: string }): void => {\n      const edge = payload.key;\n      // we process the edge\n      this.addEdge(edge);\n      // schedule a render for the edge\n      this.refresh({ partialGraph: { edges: [edge] }, schedule: true });\n    };\n\n    // On update edge, we update indices and then call for a refresh\n    this.activeListeners.updateEdgeGraphUpdate = (payload: { key: string }): void => {\n      const edge = payload.key;\n      // schedule a repaint for the edge\n      this.refresh({ partialGraph: { edges: [edge] }, skipIndexation: false, schedule: true });\n    };\n\n    // On drop edge, we remove the edge from indices and then call for a refresh\n    this.activeListeners.dropEdgeGraphUpdate = (payload: { key: string }): void => {\n      const edge = payload.key;\n      // we process the edge\n      this.removeEdge(edge);\n      // schedule a render for all edges\n      this.refresh({ schedule: true });\n    };\n\n    // On clear edges, we clear the edge indices and then call for a refresh\n    this.activeListeners.clearEdgesGraphUpdate = (): void => {\n      // we clear the edge data structures\n      this.clearEdgeState();\n      this.clearEdgeIndices();\n      // schedule a render for all edges\n      this.refresh({ schedule: true });\n    };\n\n    // On graph clear, we clear indices and then call for a refresh\n    this.activeListeners.clearGraphUpdate = (): void => {\n      // clear graph state\n      this.clearEdgeState();\n      this.clearNodeState();\n\n      // clear graph indices\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n\n      // schedule a render for all\n      this.refresh({ schedule: true });\n    };\n\n    graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n    graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n    graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n    graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n    graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n    graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n    graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n    graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n\n    return this;\n  }\n\n  /**\n   * Method used to unbind handlers from the graph.\n   *\n   * @return {undefined}\n   */\n  private unbindGraphHandlers() {\n    const graph = this.graph;\n\n    graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n    graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n    graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n    graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n    graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n    graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n    graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n    graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n    graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n    graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n  }\n\n  /**\n   * Method dealing with \"leaveEdge\" and \"enterEdge\" events.\n   *\n   * @return {Sigma}\n   */\n  private checkEdgeHoverEvents(payload: SigmaEventPayload): this {\n    const edgeToHover = this.hoveredNode ? null : this.getEdgeAtPoint(payload.event.x, payload.event.y);\n\n    if (edgeToHover !== this.hoveredEdge) {\n      if (this.hoveredEdge) this.emit(\"leaveEdge\", { ...payload, edge: this.hoveredEdge });\n      if (edgeToHover) this.emit(\"enterEdge\", { ...payload, edge: edgeToHover });\n      this.hoveredEdge = edgeToHover;\n    }\n\n    return this;\n  }\n\n  /**\n   * Method looking for an edge colliding with a given point at (x, y). Returns\n   * the key of the edge if any, or null else.\n   */\n  private getEdgeAtPoint(x: number, y: number): string | null {\n    const color = getPixelColor(\n      this.webGLContexts.edges,\n      this.frameBuffers.edges,\n      x,\n      y,\n      this.pixelRatio,\n      this.pickingDownSizingRatio,\n    );\n    const index = colorToIndex(...color);\n    const itemAt = this.itemIDsIndex[index];\n\n    return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n  }\n\n  /**\n   * Method used to process the whole graph's data.\n   *  - extent\n   *  - normalizationFunction\n   *  - compute node's coordinate\n   *  - labelgrid\n   *  - program data allocation\n   * @return {Sigma}\n   */\n  private process(): this {\n    const graph = this.graph;\n    const settings = this.settings;\n    const dimensions = this.getDimensions();\n\n    //\n    // NODES\n    //\n    this.nodeExtent = graphExtent(this.graph);\n    this.normalizationFunction = createNormalizationFunction(this.customBBox || this.nodeExtent);\n\n    // NOTE: it is important to compute this matrix after computing the node's extent\n    // because #.getGraphDimensions relies on it\n    const nullCamera = new Camera();\n    const nullCameraMatrix = matrixFromCamera(\n      nullCamera.getState(),\n      dimensions,\n      this.getGraphDimensions(),\n      this.getSetting(\"stagePadding\") || 0,\n    );\n    // Resetting the label grid\n    // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n    this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n\n    const nodesPerPrograms: Record<string, number> = {};\n    const nodeIndices: typeof this.nodeIndices = {};\n    const edgeIndices: typeof this.edgeIndices = {};\n    const itemIDsIndex: typeof this.itemIDsIndex = {};\n    let incrID = 1;\n\n    let nodes = graph.nodes();\n\n    // Do some indexation on the whole graph\n    for (let i = 0, l = nodes.length; i < l; i++) {\n      const node = nodes[i];\n      const data = this.nodeDataCache[node];\n\n      // Get initial coordinates\n      const attrs = graph.getNodeAttributes(node);\n      data.x = attrs.x;\n      data.y = attrs.y;\n      this.normalizationFunction.applyTo(data);\n\n      // labelgrid\n      if (typeof data.label === \"string\" && !data.hidden)\n        this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, { matrix: nullCameraMatrix }));\n\n      // update count per program\n      nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n    }\n    this.labelGrid.organize();\n\n    // Allocate memory to programs\n    for (const type in this.nodePrograms) {\n      if (!this.nodePrograms.hasOwnProperty(type)) {\n        throw new Error(`Sigma: could not find a suitable program for node type \"${type}\"!`);\n      }\n      this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      nodesPerPrograms[type] = 0;\n    }\n\n    // Order nodes by zIndex before to add them to program\n    if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1])\n      nodes = zIndexOrdering<string>(\n        this.nodeZExtent,\n        (node: string): number => this.nodeDataCache[node].zIndex,\n        nodes,\n      );\n\n    // Add data to programs\n    for (let i = 0, l = nodes.length; i < l; i++) {\n      const node = nodes[i];\n\n      nodeIndices[node] = incrID;\n      itemIDsIndex[nodeIndices[node]] = { type: \"node\", id: node };\n      incrID++;\n\n      const data = this.nodeDataCache[node];\n      this.addNodeToProgram(node, nodeIndices[node], nodesPerPrograms[data.type]++);\n    }\n\n    //\n    // EDGES\n    //\n\n    const edgesPerPrograms: Record<string, number> = {};\n    let edges = graph.edges();\n\n    // Allocate memory to programs\n    for (let i = 0, l = edges.length; i < l; i++) {\n      const edge = edges[i];\n      const data = this.edgeDataCache[edge];\n      edgesPerPrograms[data.type] = (edgesPerPrograms[data.type] || 0) + 1;\n    }\n\n    // Order edges by zIndex before to add them to program\n    if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1])\n      edges = zIndexOrdering<string>(\n        this.edgeZExtent,\n        (edge: string): number => this.edgeDataCache[edge].zIndex,\n        edges,\n      );\n\n    for (const type in this.edgePrograms) {\n      if (!this.edgePrograms.hasOwnProperty(type)) {\n        throw new Error(`Sigma: could not find a suitable program for edge type \"${type}\"!`);\n      }\n      this.edgePrograms[type].reallocate(edgesPerPrograms[type] || 0);\n      // We reset that count here, so that we can reuse it while calling the Program#process methods:\n      edgesPerPrograms[type] = 0;\n    }\n\n    // Add data to programs\n    for (let i = 0, l = edges.length; i < l; i++) {\n      const edge = edges[i];\n\n      edgeIndices[edge] = incrID;\n      itemIDsIndex[edgeIndices[edge]] = { type: \"edge\", id: edge };\n      incrID++;\n\n      const data = this.edgeDataCache[edge];\n      this.addEdgeToProgram(edge, edgeIndices[edge], edgesPerPrograms[data.type]++);\n    }\n\n    this.itemIDsIndex = itemIDsIndex;\n    this.nodeIndices = nodeIndices;\n    this.edgeIndices = edgeIndices;\n\n    return this;\n  }\n\n  /**\n   * Method that backports potential settings updates where it's needed.\n   * @private\n   */\n  private handleSettingsUpdate(): this {\n    this.camera.minRatio = this.settings.minCameraRatio;\n    this.camera.maxRatio = this.settings.maxCameraRatio;\n    this.camera.setState(this.camera.validateState(this.camera.getState()));\n\n    return this;\n  }\n\n  /**\n   * Method used to render labels.\n   *\n   * @return {Sigma}\n   */\n  private renderLabels(): this {\n    if (!this.settings.renderLabels) return this;\n\n    const cameraState = this.camera.getState();\n\n    // Selecting labels to draw\n    const labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n    extend(labelsToDisplay, this.nodesWithForcedLabels);\n\n    this.displayedNodeLabels = new Set();\n\n    // Drawing labels\n    const context = this.canvasContexts.labels;\n\n    for (let i = 0, l = labelsToDisplay.length; i < l; i++) {\n      const node = labelsToDisplay[i];\n      const data = this.nodeDataCache[node];\n\n      // If the node was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      // NOTE: we can do better probably\n      if (this.displayedNodeLabels.has(node)) continue;\n\n      // If the node is hidden, we don't need to display its label obviously\n      if (data.hidden) continue;\n\n      const { x, y } = this.framedGraphToViewport(data);\n\n      // NOTE: we can cache the labels we need to render until the camera's ratio changes\n      const size = this.scaleSize(data.size);\n\n      // Is node big enough?\n      if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n      // Is node actually on screen (with some margin)\n      // NOTE: we used to rely on the quadtree for this, but the coordinates\n      // conversion make it unreliable and at that point we already converted\n      // to viewport coordinates and since the label grid already culls the\n      // number of potential labels to display this looks like a good\n      // performance compromise.\n      // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n      // considering cells obviously outside of the range of the current\n      // view rectangle.\n      if (\n        x < -X_LABEL_MARGIN ||\n        x > this.width + X_LABEL_MARGIN ||\n        y < -Y_LABEL_MARGIN ||\n        y > this.height + Y_LABEL_MARGIN\n      )\n        continue;\n\n      // Because displayed edge labels depend directly on actually rendered node\n      // labels, we need to only add to this.displayedNodeLabels nodes whose label\n      // is rendered.\n      // This makes this.displayedNodeLabels depend on viewport, which might become\n      // an issue once we start memoizing getLabelsToDisplay.\n      this.displayedNodeLabels.add(node);\n\n      const { nodeProgramClasses, defaultDrawNodeLabel } = this.settings;\n      const drawLabel = nodeProgramClasses[data.type].drawLabel || defaultDrawNodeLabel;\n      drawLabel(\n        context,\n        {\n          key: node,\n          ...data,\n          size,\n          x,\n          y,\n        },\n        this.settings,\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to render edge labels, based on which node labels were\n   * rendered.\n   *\n   * @return {Sigma}\n   */\n  private renderEdgeLabels(): this {\n    if (!this.settings.renderEdgeLabels) return this;\n\n    const context = this.canvasContexts.edgeLabels;\n\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n\n    const edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n      graph: this.graph,\n      hoveredNode: this.hoveredNode,\n      displayedNodeLabels: this.displayedNodeLabels,\n      highlightedNodes: this.highlightedNodes,\n    });\n    extend(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n\n    const displayedLabels = new Set<string>();\n    for (let i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n      const edge = edgeLabelsToDisplay[i],\n        extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]],\n        edgeData = this.edgeDataCache[edge];\n\n      // If the edge was already drawn (like if it is eligible AND has\n      // `forceLabel`), we don't want to draw it again\n      if (displayedLabels.has(edge)) continue;\n\n      // If the edge is hidden we don't need to display its label\n      // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n      if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n        continue;\n      }\n\n      const { edgeProgramClasses, defaultDrawEdgeLabel } = this.settings;\n      const drawLabel = edgeProgramClasses[edgeData.type].drawLabel || defaultDrawEdgeLabel;\n      drawLabel(\n        context,\n        {\n          key: edge,\n          ...edgeData,\n          size: this.scaleSize(edgeData.size),\n        },\n        {\n          key: extremities[0],\n          ...sourceData,\n          ...this.framedGraphToViewport(sourceData),\n          size: this.scaleSize(sourceData.size),\n        },\n        {\n          key: extremities[1],\n          ...targetData,\n          ...this.framedGraphToViewport(targetData),\n          size: this.scaleSize(targetData.size),\n        },\n        this.settings,\n      );\n      displayedLabels.add(edge);\n    }\n\n    this.displayedEdgeLabels = displayedLabels;\n\n    return this;\n  }\n\n  /**\n   * Method used to render the highlighted nodes.\n   *\n   * @return {Sigma}\n   */\n  private renderHighlightedNodes(): void {\n    const context = this.canvasContexts.hovers;\n\n    // Clearing\n    context.clearRect(0, 0, this.width, this.height);\n\n    // Rendering\n    const render = (node: string): void => {\n      const data = this.nodeDataCache[node];\n\n      const { x, y } = this.framedGraphToViewport(data);\n\n      const size = this.scaleSize(data.size);\n\n      const { nodeProgramClasses, defaultDrawNodeHover } = this.settings;\n      const drawHover = nodeProgramClasses[data.type].drawHover || defaultDrawNodeHover;\n      drawHover(\n        context,\n        {\n          key: node,\n          ...data,\n          size,\n          x,\n          y,\n        },\n        this.settings,\n      );\n    };\n\n    const nodesToRender: string[] = [];\n\n    if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n      nodesToRender.push(this.hoveredNode);\n    }\n\n    this.highlightedNodes.forEach((node) => {\n      // The hovered node has already been highlighted\n      if (node !== this.hoveredNode) nodesToRender.push(node);\n    });\n\n    // Draw labels:\n    nodesToRender.forEach((node) => render(node));\n\n    // Draw WebGL nodes on top of the labels:\n    const nodesPerPrograms: Record<string, number> = {};\n\n    // 1. Count nodes per type:\n    nodesToRender.forEach((node) => {\n      const type = this.nodeDataCache[node].type;\n      nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n    });\n    // 2. Allocate for each type for the proper number of nodes\n    for (const type in this.nodeHoverPrograms) {\n      this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n      // Also reset count, to use when rendering:\n      nodesPerPrograms[type] = 0;\n    }\n    // 3. Process all nodes to render:\n    nodesToRender.forEach((node) => {\n      const data = this.nodeDataCache[node];\n      this.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n    });\n    // 4. Clear hovered nodes layer:\n    this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n    // 5. Render:\n    for (const type in this.nodeHoverPrograms) {\n      const program = this.nodeHoverPrograms[type];\n\n      program.render({\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio,\n        downSizingRatio: this.pickingDownSizingRatio,\n      });\n    }\n  }\n\n  /**\n   * Method used to schedule a hover render.\n   *\n   */\n  private scheduleHighlightedNodesRender(): void {\n    if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n\n    this.renderHighlightedNodesFrame = requestFrame(() => {\n      // Resetting state\n      this.renderHighlightedNodesFrame = null;\n\n      // Rendering\n      this.renderHighlightedNodes();\n      this.renderEdgeLabels();\n    });\n  }\n\n  /**\n   * Method used to render.\n   *\n   * @return {Sigma}\n   */\n  private render(): this {\n    this.emit(\"beforeRender\");\n\n    const exitRender = () => {\n      this.emit(\"afterRender\");\n      return this;\n    };\n\n    // If a render was scheduled, we cancel it\n    if (this.renderFrame) {\n      cancelFrame(this.renderFrame);\n      this.renderFrame = null;\n    }\n\n    // First we need to resize\n    this.resize();\n\n    // Do we need to reprocess data?\n    if (this.needToProcess) this.process();\n    this.needToProcess = false;\n\n    // Clearing the canvases\n    this.clear();\n\n    // Prepare the textures\n    this.pickingLayers.forEach((layer) => this.resetWebGLTexture(layer));\n\n    // If we have no nodes we can stop right there\n    if (!this.graph.order) return exitRender();\n\n    // TODO: improve this heuristic or move to the captor itself?\n    // TODO: deal with the touch captor here as well\n    const mouseCaptor = this.mouseCaptor;\n    const moving =\n      this.camera.isAnimated() ||\n      mouseCaptor.isMoving ||\n      mouseCaptor.draggedEvents ||\n      mouseCaptor.currentWheelDirection;\n\n    // Then we need to extract a matrix from the camera\n    const cameraState = this.camera.getState();\n    const viewportDimensions = this.getDimensions();\n    const graphDimensions = this.getGraphDimensions();\n    const padding = this.getSetting(\"stagePadding\") || 0;\n    this.matrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding);\n    this.invMatrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding, true);\n    this.correctionRatio = getMatrixImpact(this.matrix, cameraState, viewportDimensions);\n    this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n    // [jacomyal]\n    // This comment is related to the one above the `getMatrixImpact` definition:\n    // - `this.correctionRatio` is somehow not completely explained\n    // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n    //   graph\n    // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n    // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n    // when I change the graph, the viewport or the camera. It might be useful later so I prefer to let this comment:\n    // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n    const params: RenderParams = {\n      matrix: this.matrix,\n      width: this.width,\n      height: this.height,\n      pixelRatio: this.pixelRatio,\n      zoomRatio: this.camera.ratio,\n      sizeRatio: 1 / this.scaleSize(),\n      correctionRatio: this.correctionRatio,\n      downSizingRatio: this.pickingDownSizingRatio,\n    };\n\n    // Drawing nodes\n    for (const type in this.nodePrograms) {\n      const program = this.nodePrograms[type];\n      program.render(params);\n    }\n\n    // Drawing edges\n    if (!this.settings.hideEdgesOnMove || !moving) {\n      for (const type in this.edgePrograms) {\n        const program = this.edgePrograms[type];\n        program.render(params);\n      }\n    }\n\n    // Do not display labels on move per setting\n    if (this.settings.hideLabelsOnMove && moving) return exitRender();\n\n    this.renderLabels();\n    this.renderEdgeLabels();\n    this.renderHighlightedNodes();\n\n    return exitRender();\n  }\n\n  /**\n   * Add a node in the internal data structures.\n   * @private\n   * @param key The node's graphology ID\n   */\n  private addNode(key: string): void {\n    // Node display data resolution:\n    //  1. First we get the node's attributes\n    //  2. We optionally reduce them using the function provided by the user\n    //     Note that this function must return a total object and won't be merged\n    //  3. We apply our defaults, while running some vital checks\n    //  4. We apply the normalization function\n    // We shallow copy node data to avoid dangerous behaviors from reducers\n    let attr = Object.assign({}, this.graph.getNodeAttributes(key));\n    if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);\n    const data = applyNodeDefaults(this.settings, key, attr);\n    this.nodeDataCache[key] = data;\n\n    // Label:\n    // We delete and add if needed because this function is also used from\n    // update\n    this.nodesWithForcedLabels.delete(key);\n    if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n    // Highlighted:\n    // We remove and re add if needed because this function is also used from\n    // update\n    this.highlightedNodes.delete(key);\n    if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n    // zIndex\n    if (this.settings.zIndex) {\n      if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n      if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n    }\n  }\n\n  /**\n   * Update a node the internal data structures.\n   * @private\n   * @param key The node's graphology ID\n   */\n  private updateNode(key: string): void {\n    this.addNode(key);\n\n    // Re-apply normalization on the node\n    const data = this.nodeDataCache[key];\n    this.normalizationFunction.applyTo(data);\n  }\n\n  /**\n   * Remove a node from the internal data structures.\n   * @private\n   * @param key The node's graphology ID\n   */\n  private removeNode(key: string): void {\n    // Remove from node cache\n    delete this.nodeDataCache[key];\n    // Remove from node program index\n    delete this.nodeProgramIndex[key];\n    // Remove from higlighted nodes\n    this.highlightedNodes.delete(key);\n    // Remove from hovered\n    if (this.hoveredNode === key) this.hoveredNode = null;\n    // Remove from forced label\n    this.nodesWithForcedLabels.delete(key);\n  }\n\n  /**\n   * Add an edge into the internal data structures.\n   * @private\n   * @param key The edge's graphology ID\n   */\n  private addEdge(key: string): void {\n    // Edge display data resolution:\n    //  1. First we get the edge's attributes\n    //  2. We optionally reduce them using the function provided by the user\n    //  3. Note that this function must return a total object and won't be merged\n    //  4. We apply our defaults, while running some vital checks\n    // We shallow copy edge data to avoid dangerous behaviors from reducers\n    let attr = Object.assign({}, this.graph.getEdgeAttributes(key));\n    if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);\n    const data = applyEdgeDefaults(this.settings, key, attr);\n    this.edgeDataCache[key] = data;\n\n    // Forced label\n    // we filter and re push if needed because this function is also used from\n    // update\n    this.edgesWithForcedLabels.delete(key);\n    if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n    // Check zIndex\n    if (this.settings.zIndex) {\n      if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n      if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n    }\n  }\n\n  /**\n   * Update an edge in the internal data structures.\n   * @private\n   * @param key The edge's graphology ID\n   */\n  private updateEdge(key: string): void {\n    this.addEdge(key);\n  }\n\n  /**\n   * Remove an edge from the internal data structures.\n   * @private\n   * @param key The edge's graphology ID\n   */\n  private removeEdge(key: string): void {\n    // Remove from edge cache\n    delete this.edgeDataCache[key];\n    // Remove from programId index\n    delete this.edgeProgramIndex[key];\n    // Remove from hovered\n    if (this.hoveredEdge === key) this.hoveredEdge = null;\n    // Remove from forced label\n    this.edgesWithForcedLabels.delete(key);\n  }\n\n  /**\n   * Clear all indices related to nodes.\n   * @private\n   */\n  private clearNodeIndices(): void {\n    // LabelGrid & nodeExtent are only manage/populated in the process function\n    this.labelGrid = new LabelGrid();\n    this.nodeExtent = { x: [0, 1], y: [0, 1] };\n    this.nodeDataCache = {};\n    this.edgeProgramIndex = {};\n    this.nodesWithForcedLabels = new Set<string>();\n    this.nodeZExtent = [Infinity, -Infinity];\n  }\n\n  /**\n   * Clear all indices related to edges.\n   * @private\n   */\n  private clearEdgeIndices(): void {\n    this.edgeDataCache = {};\n    this.edgeProgramIndex = {};\n    this.edgesWithForcedLabels = new Set<string>();\n    this.edgeZExtent = [Infinity, -Infinity];\n  }\n\n  /**\n   * Clear all indices.\n   * @private\n   */\n  private clearIndices(): void {\n    this.clearEdgeIndices();\n    this.clearNodeIndices();\n  }\n\n  /**\n   * Clear all graph state related to nodes.\n   * @private\n   */\n  private clearNodeState(): void {\n    this.displayedNodeLabels = new Set();\n    this.highlightedNodes = new Set();\n    this.hoveredNode = null;\n  }\n\n  /**\n   * Clear all graph state related to edges.\n   * @private\n   */\n  private clearEdgeState(): void {\n    this.displayedEdgeLabels = new Set();\n    this.highlightedNodes = new Set();\n    this.hoveredEdge = null;\n  }\n\n  /**\n   * Clear all graph state.\n   * @private\n   */\n  private clearState(): void {\n    this.clearEdgeState();\n    this.clearNodeState();\n  }\n\n  /**\n   * Add the node data to its program.\n   * @private\n   * @param node The node's graphology ID\n   * @param fingerprint A fingerprint used to identity the node with picking\n   * @param position The index where to place the node in the program\n   */\n  private addNodeToProgram(node: string, fingerprint: number, position: number): void {\n    const data = this.nodeDataCache[node];\n    const nodeProgram = this.nodePrograms[data.type];\n    if (!nodeProgram) throw new Error(`Sigma: could not find a suitable program for node type \"${data.type}\"!`);\n    nodeProgram.process(fingerprint, position, data);\n    // Saving program index\n    this.nodeProgramIndex[node] = position;\n  }\n\n  /**\n   * Add the edge data to its program.\n   * @private\n   * @param edge The edge's graphology ID\n   * @param fingerprint A fingerprint used to identity the edge with picking\n   * @param position The index where to place the edge in the program\n   */\n  private addEdgeToProgram(edge: string, fingerprint: number, position: number): void {\n    const data = this.edgeDataCache[edge];\n    const edgeProgram = this.edgePrograms[data.type];\n    if (!edgeProgram) throw new Error(`Sigma: could not find a suitable program for edge type \"${data.type}\"!`);\n    const extremities = this.graph.extremities(edge),\n      sourceData = this.nodeDataCache[extremities[0]],\n      targetData = this.nodeDataCache[extremities[1]];\n    edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n    // Saving program index\n    this.edgeProgramIndex[edge] = position;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Public API.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the renderer's camera.\n   *\n   * @return {Camera}\n   */\n  getCamera(): Camera {\n    return this.camera;\n  }\n\n  /**\n   * Method setting the renderer's camera.\n   *\n   * @param  {Camera} camera - New camera.\n   * @return {Sigma}\n   */\n  setCamera(camera: Camera): void {\n    this.unbindCameraHandlers();\n    this.camera = camera;\n    this.bindCameraHandlers();\n  }\n\n  /**\n   * Method returning the container DOM element.\n   *\n   * @return {HTMLElement}\n   */\n  getContainer(): HTMLElement {\n    return this.container;\n  }\n\n  /**\n   * Method returning the renderer's graph.\n   *\n   * @return {Graph}\n   */\n  getGraph(): GraphType {\n    return this.graph;\n  }\n\n  /**\n   * Method used to set the renderer's graph.\n   *\n   * @return {Graph}\n   */\n  setGraph(graph: GraphType): void {\n    if (graph === this.graph) return;\n\n    // Unbinding handlers on the current graph\n    this.unbindGraphHandlers();\n\n    if (this.checkEdgesEventsFrame !== null) {\n      cancelFrame(this.checkEdgesEventsFrame);\n      this.checkEdgesEventsFrame = null;\n    }\n\n    // Installing new graph\n    this.graph = graph;\n\n    // Binding new handlers\n    this.bindGraphHandlers();\n\n    // Re-rendering now to avoid discrepancies from now to next frame\n    this.refresh();\n  }\n\n  /**\n   * Method returning the mouse captor.\n   *\n   * @return {MouseCaptor}\n   */\n  getMouseCaptor(): MouseCaptor {\n    return this.mouseCaptor;\n  }\n\n  /**\n   * Method returning the touch captor.\n   *\n   * @return {TouchCaptor}\n   */\n  getTouchCaptor(): TouchCaptor {\n    return this.touchCaptor;\n  }\n\n  /**\n   * Method returning the current renderer's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  getDimensions(): Dimensions {\n    return { width: this.width, height: this.height };\n  }\n\n  /**\n   * Method returning the current graph's dimensions.\n   *\n   * @return {Dimensions}\n   */\n  getGraphDimensions(): Dimensions {\n    const extent = this.customBBox || this.nodeExtent;\n\n    return {\n      width: extent.x[1] - extent.x[0] || 1,\n      height: extent.y[1] - extent.y[0] || 1,\n    };\n  }\n\n  /**\n   * Method used to get all the sigma node attributes.\n   * It's usefull for example to get the position of a node\n   * and to get values that are set by the nodeReducer\n   *\n   * @param  {string} key - The node's key.\n   * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n   */\n  getNodeDisplayData(key: unknown): NodeDisplayData | undefined {\n    const node = this.nodeDataCache[key as string];\n    return node ? Object.assign({}, node) : undefined;\n  }\n\n  /**\n   * Method used to get all the sigma edge attributes.\n   * It's useful for example to get values that are set by the edgeReducer.\n   *\n   * @param  {string} key - The edge's key.\n   * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n   */\n  getEdgeDisplayData(key: unknown): EdgeDisplayData | undefined {\n    const edge = this.edgeDataCache[key as string];\n    return edge ? Object.assign({}, edge) : undefined;\n  }\n\n  /**\n   * Method used to get the set of currently displayed node labels.\n   *\n   * @return {Set<string>} A set of node keys whose label is displayed.\n   */\n  getNodeDisplayedLabels(): Set<string> {\n    return new Set(this.displayedNodeLabels);\n  }\n\n  /**\n   * Method used to get the set of currently displayed edge labels.\n   *\n   * @return {Set<string>} A set of edge keys whose label is displayed.\n   */\n  getEdgeDisplayedLabels(): Set<string> {\n    return new Set(this.displayedEdgeLabels);\n  }\n\n  /**\n   * Method returning a copy of the settings collection.\n   *\n   * @return {Settings} A copy of the settings collection.\n   */\n  getSettings(): Settings {\n    return { ...this.settings };\n  }\n\n  /**\n   * Method returning the current value for a given setting key.\n   *\n   * @param  {string} key - The setting key to get.\n   * @return {any} The value attached to this setting key or undefined if not found\n   */\n  getSetting<K extends keyof Settings>(key: K): Settings[K] | undefined {\n    return this.settings[key];\n  }\n\n  /**\n   * Method setting the value of a given setting key. Note that this will schedule\n   * a new render next frame.\n   *\n   * @param  {string} key - The setting key to set.\n   * @param  {any}    value - The value to set.\n   * @return {Sigma}\n   */\n  setSetting<K extends keyof Settings>(key: K, value: Settings[K]): this {\n    this.settings[key] = value;\n    validateSettings(this.settings);\n    this.handleSettingsUpdate();\n    this.refresh();\n    return this;\n  }\n\n  /**\n   * Method updating the value of a given setting key using the provided function.\n   * Note that this will schedule a new render next frame.\n   *\n   * @param  {string}   key     - The setting key to set.\n   * @param  {function} updater - The update function.\n   * @return {Sigma}\n   */\n  updateSetting<K extends keyof Settings>(key: K, updater: (value: Settings[K]) => Settings[K]): this {\n    this.settings[key] = updater(this.settings[key]);\n    validateSettings(this.settings);\n    this.handleSettingsUpdate();\n    this.scheduleRefresh();\n    return this;\n  }\n\n  /**\n   * Method used to resize the renderer.\n   *\n   * @return {Sigma}\n   */\n  resize(): this {\n    const previousWidth = this.width,\n      previousHeight = this.height;\n\n    this.width = this.container.offsetWidth;\n    this.height = this.container.offsetHeight;\n    this.pixelRatio = getPixelRatio();\n\n    if (this.width === 0) {\n      if (this.settings.allowInvalidContainer) this.width = 1;\n      else\n        throw new Error(\n          \"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\",\n        );\n    }\n\n    if (this.height === 0) {\n      if (this.settings.allowInvalidContainer) this.height = 1;\n      else\n        throw new Error(\n          \"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\",\n        );\n    }\n\n    // If nothing has changed, we can stop right here\n    if (previousWidth === this.width && previousHeight === this.height) return this;\n\n    this.emit(\"resize\");\n\n    // Sizing dom elements\n    for (const id in this.elements) {\n      const element = this.elements[id];\n\n      element.style.width = this.width + \"px\";\n      element.style.height = this.height + \"px\";\n    }\n\n    // Sizing canvas contexts\n    for (const id in this.canvasContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n\n      if (this.pixelRatio !== 1) this.canvasContexts[id].scale(this.pixelRatio, this.pixelRatio);\n    }\n\n    // Sizing WebGL contexts\n    for (const id in this.webGLContexts) {\n      this.elements[id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n      this.elements[id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n\n      const gl = this.webGLContexts[id];\n      gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n      // Clear picking texture if needed\n      if (this.pickingLayers.has(id)) {\n        const currentTexture = this.textures[id];\n        if (currentTexture) gl.deleteTexture(currentTexture);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to clear all the canvases.\n   *\n   * @return {Sigma}\n   */\n  clear(): this {\n    this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n    this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n    this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n    this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n    this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n    this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n    this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n\n    return this;\n  }\n\n  /**\n   * Method used to refresh, i.e. force the renderer to reprocess graph\n   * data and render, but keep the state.\n   * - if a partialGraph is provided, we only reprocess those nodes & edges.\n   * - if schedule is TRUE, we schedule a render instead of sync render\n   * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n   *\n   * @return {Sigma}\n   */\n  refresh(opts?: {\n    partialGraph?: { nodes?: string[]; edges?: string[] };\n    schedule?: boolean;\n    skipIndexation?: boolean;\n  }): this {\n    const skipIndexation = opts?.skipIndexation !== undefined ? opts?.skipIndexation : false;\n    const schedule = opts?.schedule !== undefined ? opts.schedule : false;\n    const fullRefresh = !opts || !opts.partialGraph;\n\n    if (fullRefresh) {\n      // Re-index graph data\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n      this.graph.forEachNode((node) => this.addNode(node));\n      this.graph.forEachEdge((edge) => this.addEdge(edge));\n    } else {\n      const nodes = opts.partialGraph?.nodes || [];\n      for (let i = 0, l = nodes?.length || 0; i < l; i++) {\n        const node = nodes[i];\n        // Recompute node's data (ie. apply reducer)\n        this.updateNode(node);\n        // Add node to the program if layout is unchanged.\n        // otherwise it will be done in the process function\n        if (skipIndexation) {\n          const programIndex = this.nodeProgramIndex[node];\n          if (programIndex === undefined) throw new Error(`Sigma: node \"${node}\" can't be repaint`);\n          this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n        }\n      }\n\n      const edges = opts?.partialGraph?.edges || [];\n      for (let i = 0, l = edges.length; i < l; i++) {\n        const edge = edges[i];\n        // Recompute edge's data (ie. apply reducer)\n        this.updateEdge(edge);\n        // Add edge to the program\n        // otherwise it will be done in the process function\n        if (skipIndexation) {\n          const programIndex = this.edgeProgramIndex[edge];\n          if (programIndex === undefined) throw new Error(`Sigma: edge \"${edge}\" can't be repaint`);\n          this.addEdgeToProgram(edge, this.edgeIndices[edge], programIndex);\n        }\n      }\n    }\n\n    // Do we need to call the process function ?\n    if (fullRefresh || !skipIndexation) this.needToProcess = true;\n\n    if (schedule) this.scheduleRender();\n    else this.render();\n\n    return this;\n  }\n\n  /**\n   * Method used to schedule a render at the next available frame.\n   * This method can be safely called on a same frame because it basically\n   * debounces refresh to the next frame.\n   *\n   * @return {Sigma}\n   */\n  scheduleRender(): this {\n    if (!this.renderFrame) {\n      this.renderFrame = requestFrame(() => {\n        this.render();\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n   * at the next available frame.\n   * This method can be safely called on a same frame because it basically\n   * debounces refresh to the next frame.\n   *\n   * @return {Sigma}\n   */\n  scheduleRefresh(opts?: { partialGraph?: { nodes?: string[]; edges?: string[] }; layoutUnchange?: boolean }): this {\n    return this.refresh({ ...opts, schedule: true });\n  }\n\n  /**\n   * Method used to (un)zoom, while preserving the position of a viewport point.\n   * Used for instance to zoom \"on the mouse cursor\".\n   *\n   * @param viewportTarget\n   * @param newRatio\n   * @return {CameraState}\n   */\n  getViewportZoomedState(viewportTarget: Coordinates, newRatio: number): CameraState {\n    const { ratio, angle, x, y } = this.camera.getState();\n\n    // TODO: handle max zoom\n    const ratioDiff = newRatio / ratio;\n\n    const center = {\n      x: this.width / 2,\n      y: this.height / 2,\n    };\n\n    const graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n    const graphCenterPosition = this.viewportToFramedGraph(center);\n\n    return {\n      angle,\n      x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n      y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n      ratio: newRatio,\n    };\n  }\n\n  /**\n   * Method returning the abstract rectangle containing the graph according\n   * to the camera's state.\n   *\n   * @return {object} - The view's rectangle.\n   */\n  viewRectangle(): {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    height: number;\n  } {\n    // TODO: reduce relative margin?\n    const marginX = (0 * this.width) / 8,\n      marginY = (0 * this.height) / 8;\n\n    const p1 = this.viewportToFramedGraph({ x: 0 - marginX, y: 0 - marginY }),\n      p2 = this.viewportToFramedGraph({ x: this.width + marginX, y: 0 - marginY }),\n      h = this.viewportToFramedGraph({ x: 0, y: this.height + marginY });\n\n    return {\n      x1: p1.x,\n      y1: p1.y,\n      x2: p2.x,\n      y2: p2.y,\n      height: p2.y - h.y,\n    };\n  }\n\n  /**\n   * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  framedGraphToViewport(coordinates: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    const recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n    const matrix = override.matrix\n      ? override.matrix\n      : recomputeMatrix\n        ? matrixFromCamera(\n            override.cameraState || this.camera.getState(),\n            override.viewportDimensions || this.getDimensions(),\n            override.graphDimensions || this.getGraphDimensions(),\n            override.padding || this.getSetting(\"stagePadding\") || 0,\n          )\n        : this.matrix;\n\n    const viewportPos = multiplyVec2(matrix, coordinates);\n\n    return {\n      x: ((1 + viewportPos.x) * this.width) / 2,\n      y: ((1 - viewportPos.y) * this.height) / 2,\n    };\n  }\n\n  /**\n   * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n   * overriding anything that is used to get the translation matrix, or even the matrix itself.\n   *\n   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n   * of computations.\n   */\n  viewportToFramedGraph(coordinates: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    const recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n    const invMatrix = override.matrix\n      ? override.matrix\n      : recomputeMatrix\n        ? matrixFromCamera(\n            override.cameraState || this.camera.getState(),\n            override.viewportDimensions || this.getDimensions(),\n            override.graphDimensions || this.getGraphDimensions(),\n            override.padding || this.getSetting(\"stagePadding\") || 0,\n            true,\n          )\n        : this.invMatrix;\n\n    const res = multiplyVec2(invMatrix, {\n      x: (coordinates.x / this.width) * 2 - 1,\n      y: 1 - (coordinates.y / this.height) * 2,\n    });\n\n    if (isNaN(res.x)) res.x = 0;\n    if (isNaN(res.y)) res.y = 0;\n\n    return res;\n  }\n\n  /**\n   * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n   * stage) to the graph system (the reference system of data as they are in the given graph instance).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  viewportPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  viewportToGraph(viewportPoint: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n  }\n\n  /**\n   * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n   * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n   *\n   * This method accepts an optional camera which can be useful if you need to translate coordinates\n   * based on a different view than the one being currently being displayed on screen.\n   *\n   * @param {Coordinates}                  graphPoint\n   * @param {CoordinateConversionOverride} override\n   */\n  graphToViewport(graphPoint: Coordinates, override: CoordinateConversionOverride = {}): Coordinates {\n    return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n  }\n\n  /**\n   * Method returning the distance multiplier between the graph system and the\n   * viewport system.\n   */\n  getGraphToViewportRatio(): number {\n    const graphP1 = { x: 0, y: 0 };\n    const graphP2 = { x: 1, y: 1 };\n    const graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n\n    const viewportP1 = this.graphToViewport(graphP1);\n    const viewportP2 = this.graphToViewport(graphP2);\n    const viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n\n    return viewportD / graphD;\n  }\n\n  /**\n   * Method returning the graph's bounding box.\n   *\n   * @return {{ x: Extent, y: Extent }}\n   */\n  getBBox(): { x: Extent; y: Extent } {\n    return this.nodeExtent;\n  }\n\n  /**\n   * Method returning the graph's custom bounding box, if any.\n   *\n   * @return {{ x: Extent, y: Extent } | null}\n   */\n  getCustomBBox(): { x: Extent; y: Extent } | null {\n    return this.customBBox;\n  }\n\n  /**\n   * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n   *\n   * @return {Sigma}\n   */\n  setCustomBBox(customBBox: { x: Extent; y: Extent } | null): this {\n    this.customBBox = customBBox;\n    this.scheduleRender();\n    return this;\n  }\n\n  /**\n   * Method used to shut the container & release event listeners.\n   *\n   * @return {undefined}\n   */\n  kill(): void {\n    // Emitting \"kill\" events so that plugins and such can cleanup\n    this.emit(\"kill\");\n\n    // Releasing events\n    this.removeAllListeners();\n\n    // Releasing camera handlers\n    this.unbindCameraHandlers();\n\n    // Releasing DOM events & captors\n    window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n    this.mouseCaptor.kill();\n    this.touchCaptor.kill();\n\n    // Releasing graph handlers\n    this.unbindGraphHandlers();\n\n    // Releasing cache & state\n    this.clearIndices();\n    this.clearState();\n\n    this.nodeDataCache = {};\n    this.edgeDataCache = {};\n\n    this.highlightedNodes.clear();\n\n    // Clearing frames\n    if (this.renderFrame) {\n      cancelFrame(this.renderFrame);\n      this.renderFrame = null;\n    }\n\n    if (this.renderHighlightedNodesFrame) {\n      cancelFrame(this.renderHighlightedNodesFrame);\n      this.renderHighlightedNodesFrame = null;\n    }\n\n    // Destroying WebGL contexts\n    for (const id in this.webGLContexts) {\n      const context = this.webGLContexts[id];\n      context.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    }\n\n    // Destroying canvases\n    const container = this.container;\n\n    while (container.firstChild) container.removeChild(container.firstChild);\n\n    // Destroying remaining collections\n    this.canvasContexts = {};\n    this.webGLContexts = {};\n    this.elements = {};\n\n    this.nodePrograms = {};\n    this.nodeHoverPrograms = {};\n    this.edgePrograms = {};\n  }\n\n  /**\n   * Method used to scale the given size according to the camera's ratio, i.e.\n   * zooming state.\n   *\n   * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n   * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n   * @return {number}              - The scaled size.\n   */\n  scaleSize(size = 1, cameraRatio = this.camera.ratio): number {\n    return (\n      (size / this.settings.zoomToSizeRatioFunction(cameraRatio)) *\n      (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1)\n    );\n  }\n\n  /**\n   * Method that returns the collection of all used canvases.\n   * At the moment, the instantiated canvases are the following, and in the\n   * following order in the DOM:\n   * - `edges`\n   * - `nodes`\n   * - `edgeLabels`\n   * - `labels`\n   * - `hovers`\n   * - `hoverNodes`\n   * - `mouse`\n   *\n   * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n   */\n  getCanvases(): PlainObject<HTMLCanvasElement> {\n    return { ...this.elements };\n  }\n}\n"],"names":["isGraph","value","identity","scale","m","x","y","rotate","r","s","c","translate","multiply","a","b","a00","a01","a02","a10","a11","a12","a20","a21","a22","b00","b01","b02","b10","b11","b12","b20","b21","b22","multiplyVec2","z","b0","b1","HTML_COLORS","assign","target","objects","i","l","o","requestFrame","callback","cancelFrame","requestID","createElement","tag","style","attributes","element","k","getPixelRatio","graphExtent","graph","xMin","xMax","yMin","yMax","_","attr","createNormalizationFunction","extent","minX","maxX","minY","maxY","ratio","dX","dY","fn","data","zIndexOrdering","_extent","getter","elements","zA","zB","INT8","INT32","FLOAT32","RGBA_TEST_REGEX","RGBA_EXTRACT_REGEX","parseColor","val","g","match","FLOAT_COLOR_CACHE","htmlColor","floatColor","rgbaToFloat","masking","parsed","color","FLOAT_INDEX_CACHE","indexToColor","index","colorToIndex","_a","getCorrectionRatio","viewportDimensions","graphDimensions","viewportRatio","graphRatio","matrixFromCamera","state","padding","inverse","angle","width","height","matrix","smallestDimension","correctionRatio","getMatrixImpact","cameraState","validateGraph","key","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","easings","ANIMATE_DEFAULTS","R","ReflectApply","receiver","args","ReflectOwnKeys","ProcessEmitWarning","warning","NumberIsNaN","EventEmitter","eventsModule","once","defaultMaxListeners","checkListener","listener","arg","n","_getMaxListeners","that","type","doError","events","er","err","handler","len","listeners","arrayClone","_addListener","prepend","existing","w","onceWrapper","_onceWrap","wrapped","list","position","originalListener","spliceOne","keys","_listeners","unwrap","evlistener","unwrapListeners","emitter","listenerCount","arr","copy","ret","name","resolve","reject","errorListener","resolver","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","wrapListener","TypedEventEmitter","DEFAULT_ZOOMING_RATIO","Camera","validatedState","validState","updater","opts","options","easing","start","initialState","t","coefficient","newState","factorOrOptions","getPosition","e","dom","bbox","getMouseCoords","res","getWheelCoords","getWheelDelta","MAX_TOUCHES","getTouchesArray","touches","getTouchCoords","touch","Captor","container","renderer","DRAG_TIMEOUT","DRAGGED_EVENTS_TOLERANCE","MOUSE_INERTIA_DURATION","MOUSE_INERTIA_RATIO","MOUSE_ZOOM_DURATION","ZOOMING_RATIO","DOUBLE_CLICK_TIMEOUT","DOUBLE_CLICK_ZOOMING_RATIO","DOUBLE_CLICK_ZOOMING_DURATION","MouseCaptor","mouseCoords","camera","newRatio","previousCameraState","shouldRefresh","eX","eY","lastMouse","mouse","offsetX","offsetY","delta","wheelCoords","ratioDiff","wheelDirection","now","LabelCandidate","size","first","second","LabelGrid","dimensions","cellSize","pos","xIndex","candidate","cell","density","cellArea","scaledDensity","labelsToDisplayPerCell","labels","edgeLabelsToDisplayFromNodes","params","hoveredNode","highlightedNodes","displayedNodeLabels","worthyEdges","edge","source","loadShader","gl","glType","shader","infoLog","loadVertexShader","loadFragmentShader","loadProgram","shaders","program","PICKING_PREFIX","SIZE_FACTOR_PER_ATTRIBUTE_TYPE","getAttributeItemsCount","getAttributesItemsCount","attrs","Program","pickingBuffer","def","constantAttributesItemsCount","vector","j","vertexShaderSource","fragmentShaderSource","frameBuffer","buffer","vertexShader","fragmentShader","uniformLocations","uniformName","location","attributeLocations","constantBuffer","offset","setDivisor","sizeFactor","stride","ext","unsetDivisor","capacity","programInfo","method","_NodeProgram","nodeIndex","NodeProgram","_NodeImageClass","_gl","_pickingBuffer","_renderer","_capacity","_nodeIndex","_offset","_data","_params","NodeImageClass","vert_default","frag_default","UNSIGNED_BYTE","FLOAT","UNIFORMS","NodePointProgram","VERTEX_SHADER_SOURCE","FRAGMENT_SHADER_SOURCE","startIndex","array","sizeRatio","pixelRatio","u_sizeRatio","u_pixelRatio","u_matrix","_EdgeProgram","edgeIndex","sourceData","targetData","EdgeProgram","_EdgeImageClass","_edgeIndex","_sourceData","_targetData","EdgeImageClass","createEdgeCompoundProgram","programClasses","drawLabel","EdgeRectangleProgram","thickness","x1","y1","x2","y2","dx","dy","n1","n2","u_zoomRatio","u_correctionRatio","EdgeArrowHeadProgram","radius","EdgeClampedProgram","EdgeArrowProgram","drawStraightEdgeLabel","context","edgeData","settings","font","weight","label","sSize","tSize","sx","sy","tx","ty","cx","cy","d","textLength","ellipsis","drawDiscNodeLabel","drawDiscNodeHover","PADDING","textWidth","boxWidth","boxHeight","angleRadian","xDeltaCoord","DEFAULT_SETTINGS","DEFAULT_NODE_PROGRAM_CLASSES","DEFAULT_EDGE_PROGRAM_CLASSES","validateSettings","minCameraRatio","maxCameraRatio","resolveSettings","resolvedSettings","TOUCH_INERTIA_RATIO","TOUCH_INERTIA_DURATION","TouchCaptor","mousePosition","mouseEvent","x0","y0","touchesPositions","idx","startPosition","startCameraState","xStart","yStart","newCameraState","angleDiff","touchGraphPosition","extend","values","l2","l1","getPixelColor","downSizingRatio","bufferX","bufferY","pixel","X_LABEL_MARGIN","Y_LABEL_MARGIN","applyNodeDefaults","applyEdgeDefaults","_key","Sigma","NodeProgramClass","NodeHoverProgram","EdgeProgramClass","id","canvas","contextOptions","newFrameBuffer","currentTexture","pickingTexture","itemAt","baseEvent","nodeToHover","node","createMouseListener","eventType","nodeAtPosition","LAYOUT_IMPACTING_FIELDS","updatedFields","layoutChanged","f","payload","edgeToHover","nullCamera","nullCameraMatrix","nodesPerPrograms","nodeIndices","edgeIndices","itemIDsIndex","incrID","nodes","edgesPerPrograms","edges","labelsToDisplay","nodeProgramClasses","defaultDrawNodeLabel","edgeLabelsToDisplay","displayedLabels","extremities","edgeProgramClasses","defaultDrawEdgeLabel","render","defaultDrawNodeHover","nodesToRender","exitRender","layer","mouseCaptor","moving","fingerprint","nodeProgram","edgeProgram","previousWidth","previousHeight","skipIndexation","schedule","fullRefresh","programIndex","_b","viewportTarget","center","graphMousePosition","graphCenterPosition","marginX","marginY","p1","p2","h","coordinates","override","recomputeMatrix","viewportPos","invMatrix","viewportPoint","graphPoint","graphP1","graphP2","graphD","viewportP1","viewportP2","customBBox","cameraRatio"],"mappings":"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","x_google_ignoreList":[0,6]}