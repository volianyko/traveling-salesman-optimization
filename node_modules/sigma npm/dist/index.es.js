function Ze(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var je = function(e) {
  return e !== null && typeof e == "object" && typeof e.addUndirectedEdgeWithKey == "function" && typeof e.dropNode == "function" && typeof e.multi == "boolean";
};
const Ke = /* @__PURE__ */ Ze(je);
function x() {
  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);
}
function P(i, e, t) {
  return i[0] = e, i[4] = typeof t == "number" ? t : e, i;
}
function oe(i, e) {
  const t = Math.sin(e), n = Math.cos(e);
  return i[0] = n, i[1] = t, i[3] = -t, i[4] = n, i;
}
function ae(i, e, t) {
  return i[6] = e, i[7] = t, i;
}
function _(i, e) {
  const t = i[0], n = i[1], s = i[2], r = i[3], o = i[4], a = i[5], d = i[6], h = i[7], l = i[8], u = e[0], f = e[1], g = e[2], c = e[3], v = e[4], m = e[5], p = e[6], E = e[7], y = e[8];
  return i[0] = u * t + f * r + g * d, i[1] = u * n + f * o + g * h, i[2] = u * s + f * a + g * l, i[3] = c * t + v * r + m * d, i[4] = c * n + v * o + m * h, i[5] = c * s + v * a + m * l, i[6] = p * t + E * r + y * d, i[7] = p * n + E * o + y * h, i[8] = p * s + E * a + y * l, i;
}
function J(i, e, t = 1) {
  const n = i[0], s = i[1], r = i[3], o = i[4], a = i[6], d = i[7], h = e.x, l = e.y;
  return { x: h * n + l * r + a * t, y: h * s + l * o + d * t };
}
const Y = {
  black: "#000000",
  silver: "#C0C0C0",
  gray: "#808080",
  grey: "#808080",
  white: "#FFFFFF",
  maroon: "#800000",
  red: "#FF0000",
  purple: "#800080",
  fuchsia: "#FF00FF",
  green: "#008000",
  lime: "#00FF00",
  olive: "#808000",
  yellow: "#FFFF00",
  navy: "#000080",
  blue: "#0000FF",
  teal: "#008080",
  aqua: "#00FFFF",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  darkgreen: "#006400",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  springgreen: "#00FF7F",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  rebeccapurple: "#663399",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  dimgrey: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  slategrey: "#708090",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370DB",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  darkgrey: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgray: "#D3D3D3",
  lightgrey: "#D3D3D3",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  palevioletred: "#DB7093",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0"
};
function $(i, ...e) {
  i = i || {};
  for (let t = 0, n = e.length; t < n; t++) {
    const s = e[t];
    s && Object.assign(i, s);
  }
  return i;
}
const B = typeof requestAnimationFrame < "u" ? (i) => requestAnimationFrame(i) : (i) => setTimeout(i, 0), I = typeof cancelAnimationFrame < "u" ? (i) => cancelAnimationFrame(i) : (i) => clearTimeout(i);
function Je(i, e, t) {
  const n = document.createElement(i);
  if (e)
    for (const s in e)
      n.style[s] = e[s];
  if (t)
    for (const s in t)
      n.setAttribute(s, t[s]);
  return n;
}
function he() {
  return typeof window.devicePixelRatio < "u" ? window.devicePixelRatio : 1;
}
function Qe(i) {
  if (!i.order)
    return { x: [0, 1], y: [0, 1] };
  let e = 1 / 0, t = -1 / 0, n = 1 / 0, s = -1 / 0;
  return i.forEachNode((r, o) => {
    const { x: a, y: d } = o;
    a < e && (e = a), a > t && (t = a), d < n && (n = d), d > s && (s = d);
  }), { x: [e, t], y: [n, s] };
}
function de(i) {
  const {
    x: [e, t],
    y: [n, s]
  } = i;
  let r = Math.max(t - e, s - n), o = (t + e) / 2, a = (s + n) / 2;
  (r === 0 || Math.abs(r) === 1 / 0 || isNaN(r)) && (r = 1), isNaN(o) && (o = 0), isNaN(a) && (a = 0);
  const d = (h) => ({
    x: 0.5 + (h.x - o) / r,
    y: 0.5 + (h.y - a) / r
  });
  return d.applyTo = (h) => {
    h.x = 0.5 + (h.x - o) / r, h.y = 0.5 + (h.y - a) / r;
  }, d.inverse = (h) => ({
    x: o + r * (h.x - 0.5),
    y: a + r * (h.y - 0.5)
  }), d.ratio = r, d;
}
function le(i, e, t) {
  return t.sort(function(n, s) {
    const r = e(n) || 0, o = e(s) || 0;
    return r < o ? -1 : r > o ? 1 : 0;
  });
}
const De = new Int8Array(4), X = new Int32Array(De.buffer, 0, 1), et = new Float32Array(De.buffer, 0, 1), tt = /^\s*rgba?\s*\(/, it = /^\s*rgba?\s*\(\s*([0-9]*)\s*,\s*([0-9]*)\s*,\s*([0-9]*)(?:\s*,\s*(.*)?)?\)\s*$/;
function nt(i) {
  let e = 0, t = 0, n = 0, s = 1;
  if (i[0] === "#")
    i.length === 4 ? (e = parseInt(i.charAt(1) + i.charAt(1), 16), t = parseInt(i.charAt(2) + i.charAt(2), 16), n = parseInt(i.charAt(3) + i.charAt(3), 16)) : (e = parseInt(i.charAt(1) + i.charAt(2), 16), t = parseInt(i.charAt(3) + i.charAt(4), 16), n = parseInt(i.charAt(5) + i.charAt(6), 16)), i.length === 9 && (s = parseInt(i.charAt(7) + i.charAt(8), 16) / 255);
  else if (tt.test(i)) {
    const r = i.match(it);
    r && (e = +r[1], t = +r[2], n = +r[3], r[4] && (s = +r[4]));
  }
  return { r: e, g: t, b: n, a: s };
}
const A = {};
for (const i in Y)
  A[i] = M(Y[i]), A[Y[i]] = A[i];
function Ie(i, e, t, n, s) {
  return X[0] = n << 24 | t << 16 | e << 8 | i, s && (X[0] = X[0] & 4278190079), et[0];
}
function M(i) {
  if (i = i.toLowerCase(), typeof A[i] < "u")
    return A[i];
  const e = nt(i), { r: t, g: n, b: s } = e;
  let { a: r } = e;
  r = r * 255 | 0;
  const o = Ie(t, n, s, r, !0);
  return A[i] = o, o;
}
const q = {};
function Ge(i) {
  if (typeof q[i] < "u")
    return q[i];
  const e = (i & 16711680) >>> 16, t = (i & 65280) >>> 8, n = i & 255, r = Ie(e, t, n, 255, !0);
  return q[i] = r, r;
}
function ce(i, e, t, n) {
  return t + (e << 8) + (i << 16);
}
function st(i, e) {
  const t = i.height / i.width, n = e.height / e.width;
  return t < 1 && n > 1 || t > 1 && n < 1 ? 1 : Math.min(Math.max(n, 1 / n), Math.max(1 / t, t));
}
function N(i, e, t, n, s) {
  const { angle: r, ratio: o, x: a, y: d } = i, { width: h, height: l } = e, u = x(), f = Math.min(h, l) - 2 * n, g = st(e, t);
  return s ? (_(u, ae(x(), a, d)), _(u, P(x(), o)), _(u, oe(x(), r)), _(
    u,
    P(
      x(),
      h / f / 2 / g,
      l / f / 2 / g
    )
  )) : (_(
    u,
    P(
      x(),
      2 * (f / h) * g,
      2 * (f / l) * g
    )
  ), _(u, oe(x(), -r)), _(u, P(x(), 1 / o)), _(u, ae(x(), -a, -d))), u;
}
function rt(i, e, t) {
  const { x: n, y: s } = J(i, { x: Math.cos(e.angle), y: Math.sin(e.angle) }, 0);
  return 1 / Math.sqrt(Math.pow(n, 2) + Math.pow(s, 2)) / t.width;
}
function ot(i) {
  if (!Ke(i))
    throw new Error("Sigma: invalid graph instance.");
  i.forEachNode((e, t) => {
    if (!Number.isFinite(t.x) || !Number.isFinite(t.y))
      throw new Error(
        `Sigma: Coordinates of node ${e} are invalid. A node must have a numeric 'x' and 'y' attribute.`
      );
  });
}
const at = (i) => i, ht = (i) => i * i, dt = (i) => i * (2 - i), lt = (i) => (i *= 2) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1), ct = (i) => i * i * i, ut = (i) => --i * i * i + 1, ft = (i) => (i *= 2) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2), gt = {
  linear: at,
  quadraticIn: ht,
  quadraticOut: dt,
  quadraticInOut: lt,
  cubicIn: ct,
  cubicOut: ut,
  cubicInOut: ft
}, mt = {
  easing: "quadraticInOut",
  duration: 150
};
var te = { exports: {} }, S = typeof Reflect == "object" ? Reflect : null, ue = S && typeof S.apply == "function" ? S.apply : function(e, t, n) {
  return Function.prototype.apply.call(e, t, n);
}, U;
S && typeof S.ownKeys == "function" ? U = S.ownKeys : Object.getOwnPropertySymbols ? U = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : U = function(e) {
  return Object.getOwnPropertyNames(e);
};
function pt(i) {
  console && console.warn && console.warn(i);
}
var Me = Number.isNaN || function(e) {
  return e !== e;
};
function b() {
  b.init.call(this);
}
te.exports = b;
te.exports.once = yt;
b.EventEmitter = b;
b.prototype._events = void 0;
b.prototype._eventsCount = 0;
b.prototype._maxListeners = void 0;
var fe = 10;
function V(i) {
  if (typeof i != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof i);
}
Object.defineProperty(b, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return fe;
  },
  set: function(i) {
    if (typeof i != "number" || i < 0 || Me(i))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + i + ".");
    fe = i;
  }
});
b.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
b.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || Me(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function Pe(i) {
  return i._maxListeners === void 0 ? b.defaultMaxListeners : i._maxListeners;
}
b.prototype.getMaxListeners = function() {
  return Pe(this);
};
b.prototype.emit = function(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t.push(arguments[n]);
  var s = e === "error", r = this._events;
  if (r !== void 0)
    s = s && r.error === void 0;
  else if (!s)
    return !1;
  if (s) {
    var o;
    if (t.length > 0 && (o = t[0]), o instanceof Error)
      throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a;
  }
  var d = r[e];
  if (d === void 0)
    return !1;
  if (typeof d == "function")
    ue(d, this, t);
  else
    for (var h = d.length, l = ke(d, h), n = 0; n < h; ++n)
      ue(l[n], this, t);
  return !0;
};
function ze(i, e, t, n) {
  var s, r, o;
  if (V(t), r = i._events, r === void 0 ? (r = i._events = /* @__PURE__ */ Object.create(null), i._eventsCount = 0) : (r.newListener !== void 0 && (i.emit(
    "newListener",
    e,
    t.listener ? t.listener : t
  ), r = i._events), o = r[e]), o === void 0)
    o = r[e] = t, ++i._eventsCount;
  else if (typeof o == "function" ? o = r[e] = n ? [t, o] : [o, t] : n ? o.unshift(t) : o.push(t), s = Pe(i), s > 0 && o.length > s && !o.warned) {
    o.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = i, a.type = e, a.count = o.length, pt(a);
  }
  return i;
}
b.prototype.addListener = function(e, t) {
  return ze(this, e, t, !1);
};
b.prototype.on = b.prototype.addListener;
b.prototype.prependListener = function(e, t) {
  return ze(this, e, t, !0);
};
function vt() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function Oe(i, e, t) {
  var n = { fired: !1, wrapFn: void 0, target: i, type: e, listener: t }, s = vt.bind(n);
  return s.listener = t, n.wrapFn = s, s;
}
b.prototype.once = function(e, t) {
  return V(t), this.on(e, Oe(this, e, t)), this;
};
b.prototype.prependOnceListener = function(e, t) {
  return V(t), this.prependListener(e, Oe(this, e, t)), this;
};
b.prototype.removeListener = function(e, t) {
  var n, s, r, o, a;
  if (V(t), s = this._events, s === void 0)
    return this;
  if (n = s[e], n === void 0)
    return this;
  if (n === t || n.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete s[e], s.removeListener && this.emit("removeListener", e, n.listener || t));
  else if (typeof n != "function") {
    for (r = -1, o = n.length - 1; o >= 0; o--)
      if (n[o] === t || n[o].listener === t) {
        a = n[o].listener, r = o;
        break;
      }
    if (r < 0)
      return this;
    r === 0 ? n.shift() : Et(n, r), n.length === 1 && (s[e] = n[0]), s.removeListener !== void 0 && this.emit("removeListener", e, a || t);
  }
  return this;
};
b.prototype.off = b.prototype.removeListener;
b.prototype.removeAllListeners = function(e) {
  var t, n, s;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var r = Object.keys(n), o;
    for (s = 0; s < r.length; ++s)
      o = r[s], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = n[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (s = t.length - 1; s >= 0; s--)
      this.removeListener(e, t[s]);
  return this;
};
function Ue(i, e, t) {
  var n = i._events;
  if (n === void 0)
    return [];
  var s = n[e];
  return s === void 0 ? [] : typeof s == "function" ? t ? [s.listener || s] : [s] : t ? bt(s) : ke(s, s.length);
}
b.prototype.listeners = function(e) {
  return Ue(this, e, !0);
};
b.prototype.rawListeners = function(e) {
  return Ue(this, e, !1);
};
b.listenerCount = function(i, e) {
  return typeof i.listenerCount == "function" ? i.listenerCount(e) : Be.call(i, e);
};
b.prototype.listenerCount = Be;
function Be(i) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[i];
    if (typeof t == "function")
      return 1;
    if (t !== void 0)
      return t.length;
  }
  return 0;
}
b.prototype.eventNames = function() {
  return this._eventsCount > 0 ? U(this._events) : [];
};
function ke(i, e) {
  for (var t = new Array(e), n = 0; n < e; ++n)
    t[n] = i[n];
  return t;
}
function Et(i, e) {
  for (; e + 1 < i.length; e++)
    i[e] = i[e + 1];
  i.pop();
}
function bt(i) {
  for (var e = new Array(i.length), t = 0; t < e.length; ++t)
    e[t] = i[t].listener || i[t];
  return e;
}
function yt(i, e) {
  return new Promise(function(t, n) {
    function s(o) {
      i.removeListener(e, r), n(o);
    }
    function r() {
      typeof i.removeListener == "function" && i.removeListener("error", s), t([].slice.call(arguments));
    }
    He(i, e, r, { once: !0 }), e !== "error" && Tt(i, s, { once: !0 });
  });
}
function Tt(i, e, t) {
  typeof i.on == "function" && He(i, "error", e, t);
}
function He(i, e, t, n) {
  if (typeof i.on == "function")
    n.once ? i.once(e, t) : i.on(e, t);
  else if (typeof i.addEventListener == "function")
    i.addEventListener(e, function s(r) {
      n.once && i.removeEventListener(e, s), t(r);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof i);
}
var xt = te.exports;
class ie extends xt.EventEmitter {
  constructor() {
    super(), this.rawEmitter = this;
  }
}
const z = 1.5;
class G extends ie {
  constructor() {
    super(), this.x = 0.5, this.y = 0.5, this.angle = 0, this.ratio = 1, this.minRatio = null, this.maxRatio = null, this.nextFrame = null, this.previousState = null, this.enabled = !0, this.previousState = this.getState();
  }
  /**
   * Static method used to create a Camera object with a given state.
   *
   * @param state
   * @return {Camera}
   */
  static from(e) {
    return new G().setState(e);
  }
  /**
   * Method used to enable the camera.
   *
   * @return {Camera}
   */
  enable() {
    return this.enabled = !0, this;
  }
  /**
   * Method used to disable the camera.
   *
   * @return {Camera}
   */
  disable() {
    return this.enabled = !1, this;
  }
  /**
   * Method used to retrieve the camera's current state.
   *
   * @return {object}
   */
  getState() {
    return {
      x: this.x,
      y: this.y,
      angle: this.angle,
      ratio: this.ratio
    };
  }
  /**
   * Method used to check whether the camera has the given state.
   *
   * @return {object}
   */
  hasState(e) {
    return this.x === e.x && this.y === e.y && this.ratio === e.ratio && this.angle === e.angle;
  }
  /**
   * Method used to retrieve the camera's previous state.
   *
   * @return {object}
   */
  getPreviousState() {
    const e = this.previousState;
    return e ? {
      x: e.x,
      y: e.y,
      angle: e.angle,
      ratio: e.ratio
    } : null;
  }
  /**
   * Method used to check minRatio and maxRatio values.
   *
   * @param ratio
   * @return {number}
   */
  getBoundedRatio(e) {
    let t = e;
    return typeof this.minRatio == "number" && (t = Math.max(t, this.minRatio)), typeof this.maxRatio == "number" && (t = Math.min(t, this.maxRatio)), t;
  }
  /**
   * Method used to check various things to return a legit state candidate.
   *
   * @param state
   * @return {object}
   */
  validateState(e) {
    const t = {};
    return typeof e.x == "number" && (t.x = e.x), typeof e.y == "number" && (t.y = e.y), typeof e.angle == "number" && (t.angle = e.angle), typeof e.ratio == "number" && (t.ratio = this.getBoundedRatio(e.ratio)), t;
  }
  /**
   * Method used to check whether the camera is currently being animated.
   *
   * @return {boolean}
   */
  isAnimated() {
    return !!this.nextFrame;
  }
  /**
   * Method used to set the camera's state.
   *
   * @param  {object} state - New state.
   * @return {Camera}
   */
  setState(e) {
    if (!this.enabled)
      return this;
    this.previousState = this.getState();
    const t = this.validateState(e);
    return typeof t.x == "number" && (this.x = t.x), typeof t.y == "number" && (this.y = t.y), typeof t.angle == "number" && (this.angle = t.angle), typeof t.ratio == "number" && (this.ratio = t.ratio), this.hasState(this.previousState) || this.emit("updated", this.getState()), this;
  }
  /**
   * Method used to update the camera's state using a function.
   *
   * @param  {function} updater - Updated function taking current state and
   *                              returning next state.
   * @return {Camera}
   */
  updateState(e) {
    return this.setState(e(this.getState())), this;
  }
  /**
   * Method used to animate the camera.
   *
   * @param  {object}                    state      - State to reach eventually.
   * @param  {object}                    opts       - Options:
   * @param  {number}                      duration - Duration of the animation.
   * @param  {string | number => number}   easing   - Easing function or name of an existing one
   * @param  {function}                  callback   - Callback
   */
  animate(e, t, n) {
    if (!this.enabled)
      return;
    const s = Object.assign({}, mt, t), r = this.validateState(e), o = typeof s.easing == "function" ? s.easing : gt[s.easing], a = Date.now(), d = this.getState(), h = () => {
      const l = (Date.now() - a) / s.duration;
      if (l >= 1) {
        this.nextFrame = null, this.setState(r), this.animationCallback && (this.animationCallback.call(null), this.animationCallback = void 0);
        return;
      }
      const u = o(l), f = {};
      typeof r.x == "number" && (f.x = d.x + (r.x - d.x) * u), typeof r.y == "number" && (f.y = d.y + (r.y - d.y) * u), typeof r.angle == "number" && (f.angle = d.angle + (r.angle - d.angle) * u), typeof r.ratio == "number" && (f.ratio = d.ratio + (r.ratio - d.ratio) * u), this.setState(f), this.nextFrame = B(h);
    };
    this.nextFrame ? (I(this.nextFrame), this.animationCallback && this.animationCallback.call(null), this.nextFrame = B(h)) : h(), this.animationCallback = n;
  }
  /**
   * Method used to zoom the camera.
   *
   * @param  {number|object} factorOrOptions - Factor or options.
   * @return {function}
   */
  animatedZoom(e) {
    if (!e)
      this.animate({ ratio: this.ratio / z });
    else {
      if (typeof e == "number")
        return this.animate({ ratio: this.ratio / e });
      this.animate(
        {
          ratio: this.ratio / (e.factor || z)
        },
        e
      );
    }
  }
  /**
   * Method used to unzoom the camera.
   *
   * @param  {number|object} factorOrOptions - Factor or options.
   */
  animatedUnzoom(e) {
    if (!e)
      this.animate({ ratio: this.ratio * z });
    else {
      if (typeof e == "number")
        return this.animate({ ratio: this.ratio * e });
      this.animate(
        {
          ratio: this.ratio * (e.factor || z)
        },
        e
      );
    }
  }
  /**
   * Method used to reset the camera.
   *
   * @param  {object} options - Options.
   */
  animatedReset(e) {
    this.animate(
      {
        x: 0.5,
        y: 0.5,
        ratio: 1,
        angle: 0
      },
      e
    );
  }
  /**
   * Returns a new Camera instance, with the same state as the current camera.
   *
   * @return {Camera}
   */
  copy() {
    return G.from(this.getState());
  }
}
function w(i, e) {
  const t = e.getBoundingClientRect();
  return {
    x: i.clientX - t.left,
    y: i.clientY - t.top
  };
}
function L(i, e) {
  const t = {
    ...w(i, e),
    sigmaDefaultPrevented: !1,
    preventSigmaDefault() {
      t.sigmaDefaultPrevented = !0;
    },
    original: i
  };
  return t;
}
function Ct(i, e) {
  return {
    ...L(i, e),
    delta: We(i)
  };
}
const wt = 2;
function Q(i) {
  const e = [];
  for (let t = 0, n = Math.min(i.length, wt); t < n; t++)
    e.push(i[t]);
  return e;
}
function Z(i, e) {
  return {
    touches: Q(i.touches).map((t) => w(t, e)),
    original: i
  };
}
function We(i) {
  if (typeof i.deltaY < "u")
    return i.deltaY * -3 / 360;
  if (typeof i.detail < "u")
    return i.detail / -9;
  throw new Error("Captor: could not extract delta from event.");
}
class Ve extends ie {
  constructor(e, t) {
    super(), this.container = e, this.renderer = t;
  }
}
const _t = 100, Rt = 3, Lt = 200, ge = 3, me = 250, pe = 1.7, At = 300, St = 2.2, Ft = 200;
class Nt extends Ve {
  constructor(e, t) {
    super(e, t), this.enabled = !0, this.draggedEvents = 0, this.downStartTime = null, this.lastMouseX = null, this.lastMouseY = null, this.isMouseDown = !1, this.isMoving = !1, this.movingTimeout = null, this.startCameraState = null, this.clicks = 0, this.doubleClickTimeout = null, this.currentWheelDirection = 0, this.handleClick = this.handleClick.bind(this), this.handleRightClick = this.handleRightClick.bind(this), this.handleDown = this.handleDown.bind(this), this.handleUp = this.handleUp.bind(this), this.handleMove = this.handleMove.bind(this), this.handleWheel = this.handleWheel.bind(this), this.handleOut = this.handleOut.bind(this), e.addEventListener("click", this.handleClick, !1), e.addEventListener("contextmenu", this.handleRightClick, !1), e.addEventListener("mousedown", this.handleDown, !1), e.addEventListener("wheel", this.handleWheel, !1), e.addEventListener("mouseout", this.handleOut, !1), document.addEventListener("mousemove", this.handleMove, !1), document.addEventListener("mouseup", this.handleUp, !1);
  }
  kill() {
    const e = this.container;
    e.removeEventListener("click", this.handleClick), e.removeEventListener("contextmenu", this.handleRightClick), e.removeEventListener("mousedown", this.handleDown), e.removeEventListener("wheel", this.handleWheel), e.removeEventListener("mouseout", this.handleOut), document.removeEventListener("mousemove", this.handleMove), document.removeEventListener("mouseup", this.handleUp);
  }
  handleClick(e) {
    if (this.enabled) {
      if (this.clicks++, this.clicks === 2)
        return this.clicks = 0, typeof this.doubleClickTimeout == "number" && (clearTimeout(this.doubleClickTimeout), this.doubleClickTimeout = null), this.handleDoubleClick(e);
      setTimeout(() => {
        this.clicks = 0, this.doubleClickTimeout = null;
      }, At), this.draggedEvents < Rt && this.emit("click", L(e, this.container));
    }
  }
  handleRightClick(e) {
    this.enabled && this.emit("rightClick", L(e, this.container));
  }
  handleDoubleClick(e) {
    if (!this.enabled)
      return;
    e.preventDefault(), e.stopPropagation();
    const t = L(e, this.container);
    if (this.emit("doubleClick", t), t.sigmaDefaultPrevented)
      return;
    const n = this.renderer.getCamera(), s = n.getBoundedRatio(n.getState().ratio / St);
    n.animate(this.renderer.getViewportZoomedState(w(e, this.container), s), {
      easing: "quadraticInOut",
      duration: Ft
    });
  }
  handleDown(e) {
    if (this.enabled) {
      if (e.button === 0) {
        this.startCameraState = this.renderer.getCamera().getState();
        const { x: t, y: n } = w(e, this.container);
        this.lastMouseX = t, this.lastMouseY = n, this.draggedEvents = 0, this.downStartTime = Date.now(), this.isMouseDown = !0;
      }
      this.emit("mousedown", L(e, this.container));
    }
  }
  handleUp(e) {
    if (!this.enabled || !this.isMouseDown)
      return;
    const t = this.renderer.getCamera();
    this.isMouseDown = !1, typeof this.movingTimeout == "number" && (clearTimeout(this.movingTimeout), this.movingTimeout = null);
    const { x: n, y: s } = w(e, this.container), r = t.getState(), o = t.getPreviousState() || { x: 0, y: 0 };
    this.isMoving ? t.animate(
      {
        x: r.x + ge * (r.x - o.x),
        y: r.y + ge * (r.y - o.y)
      },
      {
        duration: Lt,
        easing: "quadraticOut"
      }
    ) : (this.lastMouseX !== n || this.lastMouseY !== s) && t.setState({
      x: r.x,
      y: r.y
    }), this.isMoving = !1, setTimeout(() => {
      const a = this.draggedEvents > 0;
      this.draggedEvents = 0, a && this.renderer.refresh();
    }, 0), this.emit("mouseup", L(e, this.container));
  }
  handleMove(e) {
    if (!this.enabled)
      return;
    const t = L(e, this.container);
    if (this.emit("mousemovebody", t), e.target === this.container && this.emit("mousemove", t), !t.sigmaDefaultPrevented && this.isMouseDown) {
      this.isMoving = !0, this.draggedEvents++, typeof this.movingTimeout == "number" && clearTimeout(this.movingTimeout), this.movingTimeout = window.setTimeout(() => {
        this.movingTimeout = null, this.isMoving = !1;
      }, _t);
      const n = this.renderer.getCamera(), { x: s, y: r } = w(e, this.container), o = this.renderer.viewportToFramedGraph({
        x: this.lastMouseX,
        y: this.lastMouseY
      }), a = this.renderer.viewportToFramedGraph({ x: s, y: r }), d = o.x - a.x, h = o.y - a.y, l = n.getState(), u = l.x + d, f = l.y + h;
      n.setState({ x: u, y: f }), this.lastMouseX = s, this.lastMouseY = r, e.preventDefault(), e.stopPropagation();
    }
  }
  handleWheel(e) {
    if (!this.enabled)
      return;
    e.preventDefault(), e.stopPropagation();
    const t = We(e);
    if (!t)
      return;
    const n = Ct(e, this.container);
    if (this.emit("wheel", n), n.sigmaDefaultPrevented)
      return;
    const s = t > 0 ? 1 / pe : pe, r = this.renderer.getCamera(), o = r.getBoundedRatio(r.getState().ratio * s), a = t > 0 ? 1 : -1, d = Date.now();
    this.currentWheelDirection === a && this.lastWheelTriggerTime && d - this.lastWheelTriggerTime < me / 5 || (r.animate(
      this.renderer.getViewportZoomedState(w(e, this.container), o),
      {
        easing: "quadraticOut",
        duration: me
      },
      () => {
        this.currentWheelDirection = 0;
      }
    ), this.currentWheelDirection = a, this.lastWheelTriggerTime = d);
  }
  handleOut() {
  }
}
class ve {
  constructor(e, t) {
    this.key = e, this.size = t;
  }
  static compare(e, t) {
    return e.size > t.size ? -1 : e.size < t.size || e.key > t.key ? 1 : -1;
  }
}
class Ee {
  constructor() {
    this.width = 0, this.height = 0, this.cellSize = 0, this.columns = 0, this.rows = 0, this.cells = {};
  }
  resizeAndClear(e, t) {
    this.width = e.width, this.height = e.height, this.cellSize = t, this.columns = Math.ceil(e.width / t), this.rows = Math.ceil(e.height / t), this.cells = {};
  }
  getIndex(e) {
    const t = Math.floor(e.x / this.cellSize);
    return Math.floor(e.y / this.cellSize) * this.columns + t;
  }
  add(e, t, n) {
    const s = new ve(e, t), r = this.getIndex(n);
    let o = this.cells[r];
    o || (o = [], this.cells[r] = o), o.push(s);
  }
  organize() {
    for (const e in this.cells)
      this.cells[e].sort(ve.compare);
  }
  getLabelsToDisplay(e, t) {
    const n = this.cellSize * this.cellSize, r = n / e / e * t / n, o = Math.ceil(r), a = [];
    for (const d in this.cells) {
      const h = this.cells[d];
      for (let l = 0; l < Math.min(o, h.length); l++)
        a.push(h[l].key);
    }
    return a;
  }
}
function Dt(i) {
  const { graph: e, hoveredNode: t, highlightedNodes: n, displayedNodeLabels: s } = i, r = [];
  return e.forEachEdge((o, a, d, h) => {
    (d === t || h === t || n.has(d) || n.has(h) || s.has(d) && s.has(h)) && r.push(o);
  }), r;
}
function Ye(i, e, t) {
  const n = i === "VERTEX" ? e.VERTEX_SHADER : e.FRAGMENT_SHADER, s = e.createShader(n);
  if (s === null)
    throw new Error("loadShader: error while creating the shader");
  if (e.shaderSource(s, t), e.compileShader(s), !e.getShaderParameter(s, e.COMPILE_STATUS)) {
    const o = e.getShaderInfoLog(s);
    throw e.deleteShader(s), new Error(`loadShader: error while compiling the shader:
${o}
${t}`);
  }
  return s;
}
function It(i, e) {
  return Ye("VERTEX", i, e);
}
function Gt(i, e) {
  return Ye("FRAGMENT", i, e);
}
function Mt(i, e) {
  const t = i.createProgram();
  if (t === null)
    throw new Error("loadProgram: error while creating the program.");
  let n, s;
  for (n = 0, s = e.length; n < s; n++)
    i.attachShader(t, e[n]);
  if (i.linkProgram(t), !i.getProgramParameter(t, i.LINK_STATUS))
    throw i.deleteProgram(t), new Error("loadProgram: error while linking the program.");
  return t;
}
const be = `#define PICKING_MODE
`, Pt = {
  [WebGL2RenderingContext.BOOL]: 1,
  [WebGL2RenderingContext.BYTE]: 1,
  [WebGL2RenderingContext.UNSIGNED_BYTE]: 1,
  [WebGL2RenderingContext.SHORT]: 2,
  [WebGL2RenderingContext.UNSIGNED_SHORT]: 2,
  [WebGL2RenderingContext.INT]: 4,
  [WebGL2RenderingContext.UNSIGNED_INT]: 4,
  [WebGL2RenderingContext.FLOAT]: 4
};
function zt(i) {
  return i.normalized ? 1 : i.size;
}
function j(i) {
  let e = 0;
  return i.forEach((t) => e += zt(t)), e;
}
class $e {
  constructor(e, t, n) {
    this.array = new Float32Array(), this.constantArray = new Float32Array(), this.capacity = 0, this.verticesCount = 0;
    const s = this.getDefinition();
    if (this.VERTICES = s.VERTICES, this.VERTEX_SHADER_SOURCE = s.VERTEX_SHADER_SOURCE, this.FRAGMENT_SHADER_SOURCE = s.FRAGMENT_SHADER_SOURCE, this.UNIFORMS = s.UNIFORMS, this.ATTRIBUTES = s.ATTRIBUTES, this.METHOD = s.METHOD, this.CONSTANT_ATTRIBUTES = "CONSTANT_ATTRIBUTES" in s ? s.CONSTANT_ATTRIBUTES : [], this.CONSTANT_DATA = "CONSTANT_DATA" in s ? s.CONSTANT_DATA : [], this.isInstanced = "CONSTANT_ATTRIBUTES" in s, this.ATTRIBUTES_ITEMS_COUNT = j(this.ATTRIBUTES), this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT, this.renderer = n, this.normalProgram = this.getProgramInfo("normal", e, s.VERTEX_SHADER_SOURCE, s.FRAGMENT_SHADER_SOURCE, null), this.pickProgram = t ? this.getProgramInfo(
      "pick",
      e,
      be + s.VERTEX_SHADER_SOURCE,
      be + s.FRAGMENT_SHADER_SOURCE,
      t
    ) : null, this.isInstanced) {
      const r = j(this.CONSTANT_ATTRIBUTES);
      if (this.CONSTANT_DATA.length !== this.VERTICES)
        throw new Error(
          `Program: error while getting constant data (expected ${this.VERTICES} items, received ${this.CONSTANT_DATA.length} instead)`
        );
      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * r);
      for (let o = 0; o < this.CONSTANT_DATA.length; o++) {
        const a = this.CONSTANT_DATA[o];
        if (a.length !== r)
          throw new Error(
            `Program: error while getting constant data (one vector has ${a.length} items instead of ${r})`
          );
        for (let d = 0; d < a.length; d++)
          this.constantArray[o * r + d] = a[d];
      }
      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;
    }
  }
  getProgramInfo(e, t, n, s, r) {
    const o = this.getDefinition(), a = t.createBuffer();
    if (a === null)
      throw new Error("Program: error while creating the WebGL buffer.");
    const d = It(t, n), h = Gt(t, s), l = Mt(t, [d, h]), u = {};
    o.UNIFORMS.forEach((c) => {
      const v = t.getUniformLocation(l, c);
      v && (u[c] = v);
    });
    const f = {};
    o.ATTRIBUTES.forEach((c) => {
      f[c.name] = t.getAttribLocation(l, c.name);
    });
    let g;
    if ("CONSTANT_ATTRIBUTES" in o && (o.CONSTANT_ATTRIBUTES.forEach((c) => {
      f[c.name] = t.getAttribLocation(l, c.name);
    }), g = t.createBuffer(), g === null))
      throw new Error("Program: error while creating the WebGL constant buffer.");
    return {
      name: e,
      program: l,
      gl: t,
      frameBuffer: r,
      buffer: a,
      constantBuffer: g || {},
      uniformLocations: u,
      attributeLocations: f,
      isPicking: e === "pick"
    };
  }
  bindProgram(e) {
    let t = 0;
    const { gl: n, buffer: s } = e;
    this.isInstanced ? (n.bindBuffer(n.ARRAY_BUFFER, e.constantBuffer), t = 0, this.CONSTANT_ATTRIBUTES.forEach((r) => t += this.bindAttribute(r, e, t, !1)), n.bufferData(n.ARRAY_BUFFER, this.constantArray, n.STATIC_DRAW), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), t = 0, this.ATTRIBUTES.forEach((r) => t += this.bindAttribute(r, e, t, !0)), n.bufferData(n.ARRAY_BUFFER, this.array, n.DYNAMIC_DRAW)) : (n.bindBuffer(n.ARRAY_BUFFER, s), t = 0, this.ATTRIBUTES.forEach((r) => t += this.bindAttribute(r, e, t)), n.bufferData(n.ARRAY_BUFFER, this.array, n.DYNAMIC_DRAW)), n.bindBuffer(n.ARRAY_BUFFER, null);
  }
  unbindProgram(e) {
    this.isInstanced ? (this.CONSTANT_ATTRIBUTES.forEach((t) => this.unbindAttribute(t, e, !1)), this.ATTRIBUTES.forEach((t) => this.unbindAttribute(t, e, !0))) : this.ATTRIBUTES.forEach((t) => this.unbindAttribute(t, e));
  }
  bindAttribute(e, t, n, s) {
    const r = Pt[e.type];
    if (typeof r != "number")
      throw new Error(`Program.bind: yet unsupported attribute type "${e.type}"`);
    const o = t.attributeLocations[e.name], a = t.gl;
    if (o !== -1) {
      a.enableVertexAttribArray(o);
      const d = this.isInstanced ? (s ? this.ATTRIBUTES_ITEMS_COUNT : j(this.CONSTANT_ATTRIBUTES)) * Float32Array.BYTES_PER_ELEMENT : this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT;
      if (a.vertexAttribPointer(o, e.size, e.type, e.normalized || !1, d, n), this.isInstanced && s)
        if (a instanceof WebGL2RenderingContext)
          a.vertexAttribDivisor(o, 1);
        else {
          const h = a.getExtension("ANGLE_instanced_arrays");
          h && h.vertexAttribDivisorANGLE(o, 1);
        }
    }
    return e.size * r;
  }
  unbindAttribute(e, t, n) {
    const s = t.attributeLocations[e.name], r = t.gl;
    if (s !== -1 && (r.disableVertexAttribArray(s), this.isInstanced && n))
      if (r instanceof WebGL2RenderingContext)
        r.vertexAttribDivisor(s, 0);
      else {
        const o = r.getExtension("ANGLE_instanced_arrays");
        o && o.vertexAttribDivisorANGLE(s, 0);
      }
  }
  reallocate(e) {
    e !== this.capacity && (this.capacity = e, this.verticesCount = this.VERTICES * e, this.array = new Float32Array(
      this.isInstanced ? this.capacity * this.ATTRIBUTES_ITEMS_COUNT : this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT
    ));
  }
  hasNothingToRender() {
    return this.verticesCount === 0;
  }
  renderProgram(e, t) {
    const { gl: n, program: s } = t;
    n.enable(n.BLEND), n.useProgram(s), this.setUniforms(e, t), this.drawWebGL(this.METHOD, t);
  }
  render(e) {
    this.hasNothingToRender() || (this.pickProgram && (this.pickProgram.gl.viewport(
      0,
      0,
      e.width * e.pixelRatio / e.downSizingRatio,
      e.height * e.pixelRatio / e.downSizingRatio
    ), this.bindProgram(this.pickProgram), this.renderProgram({ ...e, pixelRatio: e.pixelRatio / e.downSizingRatio }, this.pickProgram), this.unbindProgram(this.pickProgram)), this.normalProgram.gl.viewport(0, 0, e.width * e.pixelRatio, e.height * e.pixelRatio), this.bindProgram(this.normalProgram), this.renderProgram(e, this.normalProgram), this.unbindProgram(this.normalProgram));
  }
  drawWebGL(e, { gl: t, frameBuffer: n }) {
    if (t.bindFramebuffer(t.FRAMEBUFFER, n), !this.isInstanced)
      t.drawArrays(e, 0, this.verticesCount);
    else if (t instanceof WebGL2RenderingContext)
      t.drawArraysInstanced(e, 0, this.VERTICES, this.capacity);
    else {
      const s = t.getExtension("ANGLE_instanced_arrays");
      s && s.drawArraysInstancedANGLE(e, 0, this.VERTICES, this.capacity);
    }
  }
}
const H = class H extends $e {
  process(e, t, n) {
    let s = t * this.STRIDE;
    if (n.hidden) {
      for (let r = s + this.STRIDE; s < r; s++)
        this.array[s] = 0;
      return;
    }
    return this.processVisibleItem(Ge(e), s, n);
  }
};
H.drawLabel = void 0, H.drawHover = void 0;
let ee = H;
const W = class W {
  constructor(e, t, n) {
    return this;
  }
  reallocate(e) {
  }
  process(e, t, n) {
  }
  render(e) {
  }
};
W.drawLabel = void 0, W.drawHover = void 0;
let ye = W;
var Ot = `attribute vec4 a_id;
attribute vec4 a_color;
attribute vec2 a_position;
attribute float a_size;

uniform float u_sizeRatio;
uniform float u_pixelRatio;
uniform mat3 u_matrix;

varying vec4 v_color;
varying float v_border;

const float bias = 255.0 / 254.0;

void main() {
  gl_Position = vec4(
    (u_matrix * vec3(a_position, 1)).xy,
    0,
    1
  );

  
  
  
  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;

  v_border = (0.5 / a_size) * u_sizeRatio;

  #ifdef PICKING_MODE
  
  v_color = a_id;
  #else
  
  v_color = a_color;
  #endif

  v_color.a *= bias;
}`, Ut = `precision mediump float;

varying vec4 v_color;
varying float v_border;

const float radius = 0.5;
const vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);

void main(void) {
  vec2 m = gl_PointCoord - vec2(0.5, 0.5);
  float dist = radius - length(m);

  
  #ifdef PICKING_MODE
  if (dist > v_border)
    gl_FragColor = v_color;
  else
    gl_FragColor = transparent;

  #else
  float t = 0.0;
  if (dist > v_border)
    t = 1.0;
  else if (dist > 0.0)
    t = dist / v_border;

  gl_FragColor = mix(transparent, v_color, t);
  #endif
}`;
const { UNSIGNED_BYTE: Te, FLOAT: xe } = WebGLRenderingContext, Bt = ["u_sizeRatio", "u_pixelRatio", "u_matrix"];
class kt extends ee {
  getDefinition() {
    return {
      VERTICES: 1,
      VERTEX_SHADER_SOURCE: Ot,
      FRAGMENT_SHADER_SOURCE: Ut,
      METHOD: WebGLRenderingContext.POINTS,
      UNIFORMS: Bt,
      ATTRIBUTES: [
        { name: "a_position", size: 2, type: xe },
        { name: "a_size", size: 1, type: xe },
        { name: "a_color", size: 4, type: Te, normalized: !0 },
        { name: "a_id", size: 4, type: Te, normalized: !0 }
      ]
    };
  }
  processVisibleItem(e, t, n) {
    const s = this.array;
    s[t++] = n.x, s[t++] = n.y, s[t++] = n.size, s[t++] = M(n.color), s[t++] = e;
  }
  setUniforms({ sizeRatio: e, pixelRatio: t, matrix: n }, { gl: s, uniformLocations: r }) {
    const { u_sizeRatio: o, u_pixelRatio: a, u_matrix: d } = r;
    s.uniform1f(a, t), s.uniform1f(o, e), s.uniformMatrix3fv(d, !1, n);
  }
}
const ne = class ne extends $e {
  process(e, t, n, s, r) {
    let o = t * this.STRIDE;
    if (r.hidden || n.hidden || s.hidden) {
      for (let a = o + this.STRIDE; o < a; o++)
        this.array[o] = 0;
      return;
    }
    return this.processVisibleItem(Ge(e), o, n, s, r);
  }
};
ne.drawLabel = void 0;
let k = ne;
const se = class se {
  constructor(e, t, n) {
    return this;
  }
  reallocate(e) {
  }
  process(e, t, n, s, r) {
  }
  render(e) {
  }
};
se.drawLabel = void 0;
let Ce = se;
function Ht(i, e) {
  var t;
  return t = class {
    constructor(s, r, o) {
      this.programs = i.map((a) => new a(s, r, o));
    }
    reallocate(s) {
      this.programs.forEach((r) => r.reallocate(s));
    }
    process(s, r, o, a, d) {
      this.programs.forEach((h) => h.process(s, r, o, a, d));
    }
    render(s) {
      this.programs.forEach((r) => r.render(s));
    }
  }, t.drawLabel = e, t;
}
var Wt = `attribute vec4 a_id;
attribute vec4 a_color;
attribute vec2 a_normal;
attribute float a_normalCoef;
attribute vec2 a_positionStart;
attribute vec2 a_positionEnd;
attribute float a_positionCoef;

uniform mat3 u_matrix;
uniform float u_sizeRatio;
uniform float u_zoomRatio;
uniform float u_correctionRatio;

varying vec4 v_color;
varying vec2 v_normal;
varying float v_thickness;

const float minThickness = 1.7;
const float bias = 255.0 / 254.0;

void main() {
  vec2 normal = a_normal * a_normalCoef;
  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;

  float normalLength = length(normal);
  vec2 unitNormal = normal / normalLength;

  
  
  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);

  
  
  
  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;

  
  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);

  
  
  
  
  v_thickness = webGLThickness / u_zoomRatio;

  v_normal = unitNormal;

  #ifdef PICKING_MODE
  
  v_color = a_id;
  #else
  
  v_color = a_color;
  #endif

  v_color.a *= bias;
}`, Vt = `precision mediump float;

varying vec4 v_color;
varying vec2 v_normal;
varying float v_thickness;

const float feather = 0.001;
const vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);

void main(void) {
  
  #ifdef PICKING_MODE
  gl_FragColor = v_color;
  #else
  float dist = length(v_normal) * v_thickness;

  float t = smoothstep(
    v_thickness - feather,
    v_thickness,
    dist
  );

  gl_FragColor = mix(v_color, transparent, t);
  #endif
}`;
const { UNSIGNED_BYTE: we, FLOAT: D } = WebGLRenderingContext, Yt = ["u_matrix", "u_zoomRatio", "u_sizeRatio", "u_correctionRatio"];
class Xe extends k {
  getDefinition() {
    return {
      VERTICES: 6,
      VERTEX_SHADER_SOURCE: Wt,
      FRAGMENT_SHADER_SOURCE: Vt,
      METHOD: WebGLRenderingContext.TRIANGLES,
      UNIFORMS: Yt,
      ATTRIBUTES: [
        { name: "a_positionStart", size: 2, type: D },
        { name: "a_positionEnd", size: 2, type: D },
        { name: "a_normal", size: 2, type: D },
        { name: "a_color", size: 4, type: we, normalized: !0 },
        { name: "a_id", size: 4, type: we, normalized: !0 }
      ],
      CONSTANT_ATTRIBUTES: [
        // If 0, then position will be a_positionStart
        // If 2, then position will be a_positionEnd
        { name: "a_positionCoef", size: 1, type: D },
        { name: "a_normalCoef", size: 1, type: D }
      ],
      CONSTANT_DATA: [
        [0, 1],
        [0, -1],
        [1, 1],
        [1, 1],
        [0, -1],
        [1, -1]
      ]
    };
  }
  processVisibleItem(e, t, n, s, r) {
    const o = r.size || 1, a = n.x, d = n.y, h = s.x, l = s.y, u = M(r.color), f = h - a, g = l - d;
    let c = f * f + g * g, v = 0, m = 0;
    c && (c = 1 / Math.sqrt(c), v = -g * c * o, m = f * c * o);
    const p = this.array;
    p[t++] = a, p[t++] = d, p[t++] = h, p[t++] = l, p[t++] = v, p[t++] = m, p[t++] = u, p[t++] = e;
  }
  setUniforms(e, { gl: t, uniformLocations: n }) {
    const { u_matrix: s, u_zoomRatio: r, u_correctionRatio: o, u_sizeRatio: a } = n;
    t.uniformMatrix3fv(s, !1, e.matrix), t.uniform1f(r, e.zoomRatio), t.uniform1f(a, e.sizeRatio), t.uniform1f(o, e.correctionRatio);
  }
}
var $t = `attribute vec2 a_position;
attribute vec2 a_normal;
attribute float a_radius;
attribute vec3 a_barycentric;

#ifdef PICKING_MODE
attribute vec4 a_id;
#else
attribute vec4 a_color;
#endif

uniform mat3 u_matrix;
uniform float u_sizeRatio;
uniform float u_correctionRatio;

varying vec4 v_color;

const float minThickness = 1.7;
const float bias = 255.0 / 254.0;
const float arrowHeadWidthLengthRatio = 0.66;
const float arrowHeadLengthThicknessRatio = 2.5;

void main() {
  float normalLength = length(a_normal);
  vec2 unitNormal = a_normal / normalLength;

  
  
  
  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);
  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;
  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;
  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;
  float webGLArrowHeadHalfWidth = webGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;

  float da = a_barycentric.x;
  float db = a_barycentric.y;
  float dc = a_barycentric.z;

  vec2 delta = vec2(
      da * (webGLNodeRadius * unitNormal.y)
    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadHalfWidth * unitNormal.x)
    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadHalfWidth * unitNormal.x),

      da * (-webGLNodeRadius * unitNormal.x)
    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadHalfWidth * unitNormal.y)
    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadHalfWidth * unitNormal.y)
  );

  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;

  gl_Position = vec4(position, 0, 1);

  #ifdef PICKING_MODE
  
  v_color = a_id;
  #else
  
  v_color = a_color;
  #endif

  v_color.a *= bias;
}`, Xt = `precision mediump float;

varying vec4 v_color;

void main(void) {
  gl_FragColor = v_color;
}`;
const { UNSIGNED_BYTE: _e, FLOAT: O } = WebGLRenderingContext, qt = ["u_matrix", "u_sizeRatio", "u_correctionRatio"];
class Zt extends k {
  getDefinition() {
    return {
      VERTICES: 3,
      VERTEX_SHADER_SOURCE: $t,
      FRAGMENT_SHADER_SOURCE: Xt,
      METHOD: WebGLRenderingContext.TRIANGLES,
      UNIFORMS: qt,
      ATTRIBUTES: [
        { name: "a_position", size: 2, type: O },
        { name: "a_normal", size: 2, type: O },
        { name: "a_radius", size: 1, type: O },
        { name: "a_color", size: 4, type: _e, normalized: !0 },
        { name: "a_id", size: 4, type: _e, normalized: !0 }
      ],
      CONSTANT_ATTRIBUTES: [{ name: "a_barycentric", size: 3, type: O }],
      CONSTANT_DATA: [
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]
      ]
    };
  }
  processVisibleItem(e, t, n, s, r) {
    const o = r.size || 1, a = s.size || 1, d = n.x, h = n.y, l = s.x, u = s.y, f = M(r.color), g = l - d, c = u - h;
    let v = g * g + c * c, m = 0, p = 0;
    v && (v = 1 / Math.sqrt(v), m = -c * v * o, p = g * v * o);
    const E = this.array;
    E[t++] = l, E[t++] = u, E[t++] = -m, E[t++] = -p, E[t++] = a, E[t++] = f, E[t++] = e;
  }
  setUniforms(e, { gl: t, uniformLocations: n }) {
    const { u_matrix: s, u_sizeRatio: r, u_correctionRatio: o } = n;
    t.uniformMatrix3fv(s, !1, e.matrix), t.uniform1f(r, e.sizeRatio), t.uniform1f(o, e.correctionRatio);
  }
}
var jt = `attribute vec4 a_id;
attribute vec4 a_color;
attribute vec2 a_normal;
attribute float a_normalCoef;
attribute vec2 a_positionStart;
attribute vec2 a_positionEnd;
attribute float a_positionCoef;
attribute float a_radius;
attribute float a_radiusCoef;

uniform mat3 u_matrix;
uniform float u_zoomRatio;
uniform float u_sizeRatio;
uniform float u_correctionRatio;

varying vec4 v_color;
varying vec2 v_normal;
varying float v_thickness;

const float minThickness = 1.7;
const float bias = 255.0 / 254.0;
const float arrowHeadLengthThicknessRatio = 2.5;

void main() {
  float radius = a_radius * a_radiusCoef;
  vec2 normal = a_normal * a_normalCoef;
  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;

  float normalLength = length(normal);
  vec2 unitNormal = normal / normalLength;

  
  
  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);
  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;

  
  float direction = sign(radius);
  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;
  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;

  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);

  
  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);

  v_thickness = webGLThickness / u_zoomRatio;

  v_normal = unitNormal;

  #ifdef PICKING_MODE
  
  v_color = a_id;
  #else
  
  v_color = a_color;
  #endif

  v_color.a *= bias;
}`;
const { UNSIGNED_BYTE: Re, FLOAT: R } = WebGLRenderingContext;
class Kt extends Xe {
  getDefinition() {
    return {
      ...super.getDefinition(),
      VERTEX_SHADER_SOURCE: jt,
      ATTRIBUTES: [
        { name: "a_positionStart", size: 2, type: R },
        { name: "a_positionEnd", size: 2, type: R },
        { name: "a_normal", size: 2, type: R },
        { name: "a_color", size: 4, type: Re, normalized: !0 },
        { name: "a_id", size: 4, type: Re, normalized: !0 },
        { name: "a_radius", size: 1, type: R }
      ],
      CONSTANT_ATTRIBUTES: [
        // If 0, then position will be a_positionStart
        // If 1, then position will be a_positionEnd
        { name: "a_positionCoef", size: 1, type: R },
        { name: "a_normalCoef", size: 1, type: R },
        { name: "a_radiusCoef", size: 1, type: R }
      ],
      CONSTANT_DATA: [
        [0, 1, 0],
        [0, -1, 0],
        [1, 1, 1],
        [1, 1, 1],
        [0, -1, 0],
        [1, -1, -1]
      ]
    };
  }
  processVisibleItem(e, t, n, s, r) {
    const o = r.size || 1, a = n.x, d = n.y, h = s.x, l = s.y, u = M(r.color), f = h - a, g = l - d, c = s.size || 1;
    let v = f * f + g * g, m = 0, p = 0;
    v && (v = 1 / Math.sqrt(v), m = -g * v * o, p = f * v * o);
    const E = this.array;
    E[t++] = a, E[t++] = d, E[t++] = h, E[t++] = l, E[t++] = m, E[t++] = p, E[t++] = u, E[t++] = e, E[t++] = c;
  }
}
const Jt = Ht([Kt, Zt]);
function Qt(i, e, t, n, s) {
  const r = s.edgeLabelSize, o = s.edgeLabelFont, a = s.edgeLabelWeight, d = s.edgeLabelColor.attribute ? e[s.edgeLabelColor.attribute] || s.edgeLabelColor.color || "#000" : s.edgeLabelColor.color;
  let h = e.label;
  if (!h)
    return;
  i.fillStyle = d, i.font = `${a} ${r}px ${o}`;
  const l = t.size, u = n.size;
  let f = t.x, g = t.y, c = n.x, v = n.y, m = (f + c) / 2, p = (g + v) / 2, E = c - f, y = v - g, T = Math.sqrt(E * E + y * y);
  if (T < l + u)
    return;
  f += E * l / T, g += y * l / T, c -= E * u / T, v -= y * u / T, m = (f + c) / 2, p = (g + v) / 2, E = c - f, y = v - g, T = Math.sqrt(E * E + y * y);
  let C = i.measureText(h).width;
  if (C > T) {
    const re = "";
    for (h = h + re, C = i.measureText(h).width; C > T && h.length > 1; )
      h = h.slice(0, -2) + re, C = i.measureText(h).width;
    if (h.length < 4)
      return;
  }
  let F;
  E > 0 ? y > 0 ? F = Math.acos(E / T) : F = Math.asin(y / T) : y > 0 ? F = Math.acos(E / T) + Math.PI : F = Math.asin(E / T) + Math.PI / 2, i.save(), i.translate(m, p), i.rotate(F), i.fillText(h, -C / 2, e.size / 2 + r), i.restore();
}
function qe(i, e, t) {
  if (!e.label)
    return;
  const n = t.labelSize, s = t.labelFont, r = t.labelWeight, o = t.labelColor.attribute ? e[t.labelColor.attribute] || t.labelColor.color || "#000" : t.labelColor.color;
  i.fillStyle = o, i.font = `${r} ${n}px ${s}`, i.fillText(e.label, e.x + e.size + 3, e.y + n / 3);
}
function ei(i, e, t) {
  const n = t.labelSize, s = t.labelFont, r = t.labelWeight;
  i.font = `${r} ${n}px ${s}`, i.fillStyle = "#FFF", i.shadowOffsetX = 0, i.shadowOffsetY = 0, i.shadowBlur = 8, i.shadowColor = "#000";
  const o = 2;
  if (typeof e.label == "string") {
    const a = i.measureText(e.label).width, d = Math.round(a + 5), h = Math.round(n + 2 * o), l = Math.max(e.size, n / 2) + o, u = Math.asin(h / 2 / l), f = Math.sqrt(Math.abs(Math.pow(l, 2) - Math.pow(h / 2, 2)));
    i.beginPath(), i.moveTo(e.x + f, e.y + h / 2), i.lineTo(e.x + l + d, e.y + h / 2), i.lineTo(e.x + l + d, e.y - h / 2), i.lineTo(e.x + f, e.y - h / 2), i.arc(e.x, e.y, l, u, -u), i.closePath(), i.fill();
  } else
    i.beginPath(), i.arc(e.x, e.y, e.size + o, 0, Math.PI * 2), i.closePath(), i.fill();
  i.shadowOffsetX = 0, i.shadowOffsetY = 0, i.shadowBlur = 0, qe(i, e, t);
}
const ti = {
  // Performance
  hideEdgesOnMove: !1,
  hideLabelsOnMove: !1,
  renderLabels: !0,
  renderEdgeLabels: !1,
  enableEdgeEvents: !1,
  // Component rendering
  defaultNodeColor: "#999",
  defaultNodeType: "circle",
  defaultEdgeColor: "#ccc",
  defaultEdgeType: "line",
  labelFont: "Arial",
  labelSize: 14,
  labelWeight: "normal",
  labelColor: { color: "#000" },
  edgeLabelFont: "Arial",
  edgeLabelSize: 14,
  edgeLabelWeight: "normal",
  edgeLabelColor: { attribute: "color" },
  stagePadding: 30,
  zoomToSizeRatioFunction: Math.sqrt,
  itemSizesReference: "screen",
  defaultDrawEdgeLabel: Qt,
  defaultDrawNodeLabel: qe,
  defaultDrawNodeHover: ei,
  // Labels
  labelDensity: 1,
  labelGridCellSize: 100,
  labelRenderedSizeThreshold: 6,
  // Reducers
  nodeReducer: null,
  edgeReducer: null,
  // Features
  zIndex: !1,
  minCameraRatio: null,
  maxCameraRatio: null,
  // Lifecycle
  allowInvalidContainer: !1,
  // Program classes
  nodeProgramClasses: {},
  nodeHoverProgramClasses: {},
  edgeProgramClasses: {}
}, ii = {
  circle: kt
}, ni = {
  arrow: Jt,
  line: Xe
};
function K(i) {
  if (typeof i.labelDensity != "number" || i.labelDensity < 0)
    throw new Error("Settings: invalid `labelDensity`. Expecting a positive number.");
  const { minCameraRatio: e, maxCameraRatio: t } = i;
  if (typeof e == "number" && typeof t == "number" && t < e)
    throw new Error(
      "Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`."
    );
}
function si(i) {
  const e = $({}, ti, i);
  return e.nodeProgramClasses = $({}, ii, e.nodeProgramClasses), e.edgeProgramClasses = $({}, ni, e.edgeProgramClasses), e;
}
const ri = 200, Le = 3, oi = 200;
class ai extends Ve {
  constructor(e, t) {
    super(e, t), this.enabled = !0, this.isMoving = !1, this.hasMoved = !1, this.touchMode = 0, this.startTouchesPositions = [], this.handleStart = this.handleStart.bind(this), this.handleLeave = this.handleLeave.bind(this), this.handleMove = this.handleMove.bind(this), e.addEventListener("touchstart", this.handleStart, !1), e.addEventListener("touchend", this.handleLeave, !1), e.addEventListener("touchcancel", this.handleLeave, !1), e.addEventListener("touchmove", this.handleMove, !1);
  }
  kill() {
    const e = this.container;
    e.removeEventListener("touchstart", this.handleStart), e.removeEventListener("touchend", this.handleLeave), e.removeEventListener("touchcancel", this.handleLeave), e.removeEventListener("touchmove", this.handleMove);
  }
  getDimensions() {
    return {
      width: this.container.offsetWidth,
      height: this.container.offsetHeight
    };
  }
  dispatchRelatedMouseEvent(e, t, n, s) {
    const r = n || t.touches[0], o = new MouseEvent(e, {
      clientX: r.clientX,
      clientY: r.clientY,
      altKey: t.altKey,
      ctrlKey: t.ctrlKey
    });
    o.isFakeSigmaMouseEvent = !0, (s || this.container).dispatchEvent(o);
  }
  handleStart(e) {
    if (!this.enabled)
      return;
    e.preventDefault(), e.touches.length === 1 && this.dispatchRelatedMouseEvent("mousedown", e);
    const t = Q(e.touches);
    if (this.touchMode = t.length, this.startCameraState = this.renderer.getCamera().getState(), this.startTouchesPositions = t.map((n) => w(n, this.container)), this.lastTouches = t, this.lastTouchesPositions = this.startTouchesPositions, this.touchMode === 2) {
      const [{ x: n, y: s }, { x: r, y: o }] = this.startTouchesPositions;
      this.startTouchesAngle = Math.atan2(o - s, r - n), this.startTouchesDistance = Math.sqrt(Math.pow(r - n, 2) + Math.pow(o - s, 2));
    }
    this.emit("touchdown", Z(e, this.container));
  }
  handleLeave(e) {
    if (this.enabled) {
      switch (e.preventDefault(), e.touches.length === 0 && this.lastTouches && this.lastTouches.length && (this.dispatchRelatedMouseEvent("mouseup", e, this.lastTouches[0], document), this.hasMoved || this.dispatchRelatedMouseEvent("click", e, this.lastTouches[0])), this.movingTimeout && (this.isMoving = !1, clearTimeout(this.movingTimeout)), this.touchMode) {
        case 2:
          if (e.touches.length === 1) {
            this.handleStart(e), e.preventDefault();
            break;
          }
        case 1:
          if (this.isMoving) {
            const t = this.renderer.getCamera(), n = t.getState(), s = t.getPreviousState() || { x: 0, y: 0 };
            t.animate(
              {
                x: n.x + Le * (n.x - s.x),
                y: n.y + Le * (n.y - s.y)
              },
              {
                duration: oi,
                easing: "quadraticOut"
              }
            );
          }
          this.hasMoved = !1, this.isMoving = !1, this.touchMode = 0;
          break;
      }
      this.emit("touchup", Z(e, this.container));
    }
  }
  handleMove(e) {
    if (!this.enabled)
      return;
    e.preventDefault(), e.touches.length === 1 && this.dispatchRelatedMouseEvent("mousemove", e);
    const t = Q(e.touches), n = t.map((o) => w(o, this.container));
    if (this.lastTouches = t, this.lastTouchesPositions = n, this.hasMoved || (this.hasMoved = n.some((o, a) => {
      const d = this.startTouchesPositions[a];
      return o.x !== d.x || o.y !== d.y;
    })), !this.hasMoved)
      return;
    this.isMoving = !0, this.movingTimeout && clearTimeout(this.movingTimeout), this.movingTimeout = window.setTimeout(() => {
      this.isMoving = !1;
    }, ri);
    const s = this.renderer.getCamera(), r = this.startCameraState;
    switch (this.touchMode) {
      case 1: {
        const { x: o, y: a } = this.renderer.viewportToFramedGraph(
          (this.startTouchesPositions || [])[0]
        ), { x: d, y: h } = this.renderer.viewportToFramedGraph(n[0]);
        s.setState({
          x: r.x + o - d,
          y: r.y + a - h
        });
        break;
      }
      case 2: {
        const o = {}, { x: a, y: d } = n[0], { x: h, y: l } = n[1], u = Math.atan2(l - d, h - a) - this.startTouchesAngle, f = Math.hypot(l - d, h - a) / this.startTouchesDistance, g = s.getBoundedRatio(r.ratio / f);
        o.ratio = g, o.angle = r.angle + u;
        const c = this.getDimensions(), v = this.renderer.viewportToFramedGraph(
          (this.startTouchesPositions || [])[0],
          { cameraState: r }
        ), m = Math.min(c.width, c.height), p = m / c.width, E = m / c.height, y = g / m;
        let T = a - m / 2 / p, C = d - m / 2 / E;
        [T, C] = [
          T * Math.cos(-o.angle) - C * Math.sin(-o.angle),
          C * Math.cos(-o.angle) + T * Math.sin(-o.angle)
        ], o.x = v.x - T * y, o.y = v.y + C * y, s.setState(o);
        break;
      }
    }
    this.emit("touchmove", Z(e, this.container));
  }
}
function Ae(i, e) {
  const t = e.size;
  if (t === 0)
    return;
  const n = i.length;
  i.length += t;
  let s = 0;
  e.forEach((r) => {
    i[n + s] = r, s++;
  });
}
function Se(i, e, t, n, s, r) {
  const o = Math.floor(t / r * s), a = Math.floor(i.drawingBufferHeight / r - n / r * s), d = new Uint8Array(4);
  i.bindFramebuffer(i.FRAMEBUFFER, e), i.readPixels(o, a, 1, 1, i.RGBA, i.UNSIGNED_BYTE, d);
  const [h, l, u, f] = d;
  return [h, l, u, f];
}
const Fe = 150, Ne = 50;
function hi(i, e, t) {
  if (!t.hasOwnProperty("x") || !t.hasOwnProperty("y"))
    throw new Error(
      `Sigma: could not find a valid position (x, y) for node "${e}". All your nodes must have a number "x" and "y". Maybe your forgot to apply a layout or your "nodeReducer" is not returning the correct data?`
    );
  return t.color || (t.color = i.defaultNodeColor), !t.label && t.label !== "" && (t.label = null), t.label !== void 0 && t.label !== null ? t.label = "" + t.label : t.label = null, t.size || (t.size = 2), t.hasOwnProperty("hidden") || (t.hidden = !1), t.hasOwnProperty("highlighted") || (t.highlighted = !1), t.hasOwnProperty("forceLabel") || (t.forceLabel = !1), (!t.type || t.type === "") && (t.type = i.defaultNodeType), t.zIndex || (t.zIndex = 0), t;
}
function di(i, e, t) {
  return t.color || (t.color = i.defaultEdgeColor), t.label || (t.label = ""), t.size || (t.size = 0.5), t.hasOwnProperty("hidden") || (t.hidden = !1), t.hasOwnProperty("forceLabel") || (t.forceLabel = !1), (!t.type || t.type === "") && (t.type = i.defaultEdgeType), t.zIndex || (t.zIndex = 0), t;
}
class li extends ie {
  constructor(e, t, n = {}) {
    if (super(), this.elements = {}, this.canvasContexts = {}, this.webGLContexts = {}, this.pickingLayers = /* @__PURE__ */ new Set(), this.textures = {}, this.frameBuffers = {}, this.activeListeners = {}, this.labelGrid = new Ee(), this.nodeDataCache = {}, this.edgeDataCache = {}, this.nodeProgramIndex = {}, this.edgeProgramIndex = {}, this.nodesWithForcedLabels = /* @__PURE__ */ new Set(), this.edgesWithForcedLabels = /* @__PURE__ */ new Set(), this.nodeExtent = { x: [0, 1], y: [0, 1] }, this.nodeZExtent = [1 / 0, -1 / 0], this.edgeZExtent = [1 / 0, -1 / 0], this.matrix = x(), this.invMatrix = x(), this.correctionRatio = 1, this.customBBox = null, this.normalizationFunction = de({
      x: [0, 1],
      y: [0, 1]
    }), this.graphToViewportRatio = 1, this.itemIDsIndex = {}, this.nodeIndices = {}, this.edgeIndices = {}, this.width = 0, this.height = 0, this.pixelRatio = he(), this.pickingDownSizingRatio = 2 * this.pixelRatio, this.displayedNodeLabels = /* @__PURE__ */ new Set(), this.displayedEdgeLabels = /* @__PURE__ */ new Set(), this.highlightedNodes = /* @__PURE__ */ new Set(), this.hoveredNode = null, this.hoveredEdge = null, this.renderFrame = null, this.renderHighlightedNodesFrame = null, this.needToProcess = !1, this.checkEdgesEventsFrame = null, this.nodePrograms = {}, this.nodeHoverPrograms = {}, this.edgePrograms = {}, this.settings = si(n), K(this.settings), ot(e), !(t instanceof HTMLElement))
      throw new Error("Sigma: container should be an html element.");
    this.graph = e, this.container = t, this.createWebGLContext("edges", { picking: n.enableEdgeEvents }), this.createCanvasContext("edgeLabels"), this.createWebGLContext("nodes", { picking: !0 }), this.createCanvasContext("labels"), this.createCanvasContext("hovers"), this.createWebGLContext("hoverNodes"), this.createCanvasContext("mouse"), this.resize();
    for (const s in this.settings.nodeProgramClasses) {
      const r = this.settings.nodeProgramClasses[s];
      this.nodePrograms[s] = new r(this.webGLContexts.nodes, this.frameBuffers.nodes, this);
      let o = r;
      s in this.settings.nodeHoverProgramClasses && (o = this.settings.nodeHoverProgramClasses[s]), this.nodeHoverPrograms[s] = new o(this.webGLContexts.hoverNodes, null, this);
    }
    for (const s in this.settings.edgeProgramClasses) {
      const r = this.settings.edgeProgramClasses[s];
      this.edgePrograms[s] = new r(this.webGLContexts.edges, this.frameBuffers.edges, this);
    }
    this.camera = new G(), this.bindCameraHandlers(), this.mouseCaptor = new Nt(this.elements.mouse, this), this.touchCaptor = new ai(this.elements.mouse, this), this.bindEventHandlers(), this.bindGraphHandlers(), this.handleSettingsUpdate(), this.refresh();
  }
  /**---------------------------------------------------------------------------
   * Internal methods.
   **---------------------------------------------------------------------------
   */
  /**
   * Internal function used to create a canvas element.
   * @param  {string} id - Context's id.
   * @return {Sigma}
   */
  createCanvas(e) {
    const t = Je(
      "canvas",
      {
        position: "absolute"
      },
      {
        class: `sigma-${e}`
      }
    );
    return this.elements[e] = t, this.container.appendChild(t), t;
  }
  /**
   * Internal function used to create a canvas context and add the relevant
   * DOM elements.
   *
   * @param  {string} id - Context's id.
   * @return {Sigma}
   */
  createCanvasContext(e) {
    const t = this.createCanvas(e), n = {
      preserveDrawingBuffer: !1,
      antialias: !1
    };
    return this.canvasContexts[e] = t.getContext("2d", n), this;
  }
  /**
   * Internal function used to create a WebGL context and add the relevant DOM
   * elements.
   *
   * @param  {string}  id      - Context's id.
   * @param  {object?} options - #getContext params to override (optional)
   * @return {Sigma}
   */
  createWebGLContext(e, t) {
    const n = this.createCanvas(e);
    t != null && t.hidden && n.remove();
    const s = {
      preserveDrawingBuffer: !1,
      antialias: !1,
      ...t || {}
    };
    let r;
    r = n.getContext("webgl2", s), r || (r = n.getContext("webgl", s)), r || (r = n.getContext("experimental-webgl", s));
    const o = r;
    if (this.webGLContexts[e] = o, o.blendFunc(o.ONE, o.ONE_MINUS_SRC_ALPHA), t != null && t.picking) {
      this.pickingLayers.add(e);
      const a = o.createFramebuffer();
      if (!a)
        throw new Error(`Sigma: cannot create a new frame buffer for layer ${e}`);
      this.frameBuffers[e] = a;
    }
    return this;
  }
  /**
   * Method (re)binding WebGL texture (for picking).
   *
   * @return {Sigma}
   */
  resetWebGLTexture(e) {
    const t = this.webGLContexts[e], n = this.frameBuffers[e], s = this.textures[e];
    s && t.deleteTexture(s);
    const r = t.createTexture();
    return t.bindFramebuffer(t.FRAMEBUFFER, n), t.bindTexture(t.TEXTURE_2D, r), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, this.width, this.height, 0, t.RGBA, t.UNSIGNED_BYTE, null), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0), this.textures[e] = r, this;
  }
  /**
   * Method binding camera handlers.
   *
   * @return {Sigma}
   */
  bindCameraHandlers() {
    return this.activeListeners.camera = () => {
      this.scheduleRender();
    }, this.camera.on("updated", this.activeListeners.camera), this;
  }
  /**
   * Method unbinding camera handlers.
   *
   * @return {Sigma}
   */
  unbindCameraHandlers() {
    return this.camera.removeListener("updated", this.activeListeners.camera), this;
  }
  /**
   * Method that returns the closest node to a given position.
   */
  getNodeAtPosition(e) {
    const { x: t, y: n } = e, s = Se(
      this.webGLContexts.nodes,
      this.frameBuffers.nodes,
      t,
      n,
      this.pixelRatio,
      this.pickingDownSizingRatio
    ), r = ce(...s), o = this.itemIDsIndex[r];
    return o && o.type === "node" ? o.id : null;
  }
  /**
   * Method binding event handlers.
   *
   * @return {Sigma}
   */
  bindEventHandlers() {
    this.activeListeners.handleResize = () => {
      this.scheduleRefresh();
    }, window.addEventListener("resize", this.activeListeners.handleResize), this.activeListeners.handleMove = (t) => {
      const n = {
        event: t,
        preventSigmaDefault() {
          t.preventSigmaDefault();
        }
      }, s = this.getNodeAtPosition(t);
      if (s && this.hoveredNode !== s && !this.nodeDataCache[s].hidden) {
        this.hoveredNode && this.emit("leaveNode", { ...n, node: this.hoveredNode }), this.hoveredNode = s, this.emit("enterNode", { ...n, node: s }), this.scheduleHighlightedNodesRender();
        return;
      }
      if (this.hoveredNode && this.getNodeAtPosition(t) !== this.hoveredNode) {
        const r = this.hoveredNode;
        this.hoveredNode = null, this.emit("leaveNode", { ...n, node: r }), this.scheduleHighlightedNodesRender();
        return;
      }
      this.settings.enableEdgeEvents && this.checkEdgeHoverEvents(n);
    };
    const e = (t) => (n) => {
      const s = {
        event: n,
        preventSigmaDefault() {
          n.preventSigmaDefault();
        }
      }, o = n.original.isFakeSigmaMouseEvent ? this.getNodeAtPosition(n) : this.hoveredNode;
      if (o)
        return this.emit(`${t}Node`, {
          ...s,
          node: o
        });
      if (this.settings.enableEdgeEvents) {
        const a = this.getEdgeAtPoint(n.x, n.y);
        if (a)
          return this.emit(`${t}Edge`, { ...s, edge: a });
      }
      return this.emit(`${t}Stage`, s);
    };
    return this.activeListeners.handleClick = e("click"), this.activeListeners.handleRightClick = e("rightClick"), this.activeListeners.handleDoubleClick = e("doubleClick"), this.activeListeners.handleWheel = e("wheel"), this.activeListeners.handleDown = e("down"), this.mouseCaptor.on("mousemove", this.activeListeners.handleMove), this.mouseCaptor.on("click", this.activeListeners.handleClick), this.mouseCaptor.on("rightClick", this.activeListeners.handleRightClick), this.mouseCaptor.on("doubleClick", this.activeListeners.handleDoubleClick), this.mouseCaptor.on("wheel", this.activeListeners.handleWheel), this.mouseCaptor.on("mousedown", this.activeListeners.handleDown), this;
  }
  /**
   * Method binding graph handlers
   *
   * @return {Sigma}
   */
  bindGraphHandlers() {
    const e = this.graph, t = /* @__PURE__ */ new Set(["x", "y", "zIndex", "type"]);
    return this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = (n) => {
      var o;
      const s = (o = n.hints) == null ? void 0 : o.attributes;
      this.graph.forEachNode((a) => this.updateNode(a));
      const r = !s || s.some((a) => t.has(a));
      this.refresh({ partialGraph: { nodes: e.nodes() }, skipIndexation: !r, schedule: !0 });
    }, this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = (n) => {
      var o;
      const s = (o = n.hints) == null ? void 0 : o.attributes;
      this.graph.forEachEdge((a) => this.updateEdge(a));
      const r = s && ["zIndex", "type"].some((a) => s == null ? void 0 : s.includes(a));
      this.refresh({ partialGraph: { edges: e.edges() }, skipIndexation: !r, schedule: !0 });
    }, this.activeListeners.addNodeGraphUpdate = (n) => {
      const s = n.key;
      this.addNode(s), this.refresh({ partialGraph: { nodes: [s] }, skipIndexation: !1, schedule: !0 });
    }, this.activeListeners.updateNodeGraphUpdate = (n) => {
      const s = n.key;
      this.refresh({ partialGraph: { nodes: [s] }, skipIndexation: !1, schedule: !0 });
    }, this.activeListeners.dropNodeGraphUpdate = (n) => {
      const s = n.key;
      this.removeNode(s), this.refresh({ schedule: !0 });
    }, this.activeListeners.addEdgeGraphUpdate = (n) => {
      const s = n.key;
      this.addEdge(s), this.refresh({ partialGraph: { edges: [s] }, schedule: !0 });
    }, this.activeListeners.updateEdgeGraphUpdate = (n) => {
      const s = n.key;
      this.refresh({ partialGraph: { edges: [s] }, skipIndexation: !1, schedule: !0 });
    }, this.activeListeners.dropEdgeGraphUpdate = (n) => {
      const s = n.key;
      this.removeEdge(s), this.refresh({ schedule: !0 });
    }, this.activeListeners.clearEdgesGraphUpdate = () => {
      this.clearEdgeState(), this.clearEdgeIndices(), this.refresh({ schedule: !0 });
    }, this.activeListeners.clearGraphUpdate = () => {
      this.clearEdgeState(), this.clearNodeState(), this.clearEdgeIndices(), this.clearNodeIndices(), this.refresh({ schedule: !0 });
    }, e.on("nodeAdded", this.activeListeners.addNodeGraphUpdate), e.on("nodeDropped", this.activeListeners.dropNodeGraphUpdate), e.on("nodeAttributesUpdated", this.activeListeners.updateNodeGraphUpdate), e.on("eachNodeAttributesUpdated", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate), e.on("edgeAdded", this.activeListeners.addEdgeGraphUpdate), e.on("edgeDropped", this.activeListeners.dropEdgeGraphUpdate), e.on("edgeAttributesUpdated", this.activeListeners.updateEdgeGraphUpdate), e.on("eachEdgeAttributesUpdated", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate), e.on("edgesCleared", this.activeListeners.clearEdgesGraphUpdate), e.on("cleared", this.activeListeners.clearGraphUpdate), this;
  }
  /**
   * Method used to unbind handlers from the graph.
   *
   * @return {undefined}
   */
  unbindGraphHandlers() {
    const e = this.graph;
    e.removeListener("nodeAdded", this.activeListeners.addNodeGraphUpdate), e.removeListener("nodeDropped", this.activeListeners.dropNodeGraphUpdate), e.removeListener("nodeAttributesUpdated", this.activeListeners.updateNodeGraphUpdate), e.removeListener("eachNodeAttributesUpdated", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate), e.removeListener("edgeAdded", this.activeListeners.addEdgeGraphUpdate), e.removeListener("edgeDropped", this.activeListeners.dropEdgeGraphUpdate), e.removeListener("edgeAttributesUpdated", this.activeListeners.updateEdgeGraphUpdate), e.removeListener("eachEdgeAttributesUpdated", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate), e.removeListener("edgesCleared", this.activeListeners.clearEdgesGraphUpdate), e.removeListener("cleared", this.activeListeners.clearGraphUpdate);
  }
  /**
   * Method dealing with "leaveEdge" and "enterEdge" events.
   *
   * @return {Sigma}
   */
  checkEdgeHoverEvents(e) {
    const t = this.hoveredNode ? null : this.getEdgeAtPoint(e.event.x, e.event.y);
    return t !== this.hoveredEdge && (this.hoveredEdge && this.emit("leaveEdge", { ...e, edge: this.hoveredEdge }), t && this.emit("enterEdge", { ...e, edge: t }), this.hoveredEdge = t), this;
  }
  /**
   * Method looking for an edge colliding with a given point at (x, y). Returns
   * the key of the edge if any, or null else.
   */
  getEdgeAtPoint(e, t) {
    const n = Se(
      this.webGLContexts.edges,
      this.frameBuffers.edges,
      e,
      t,
      this.pixelRatio,
      this.pickingDownSizingRatio
    ), s = ce(...n), r = this.itemIDsIndex[s];
    return r && r.type === "edge" ? r.id : null;
  }
  /**
   * Method used to process the whole graph's data.
   *  - extent
   *  - normalizationFunction
   *  - compute node's coordinate
   *  - labelgrid
   *  - program data allocation
   * @return {Sigma}
   */
  process() {
    const e = this.graph, t = this.settings, n = this.getDimensions();
    this.nodeExtent = Qe(this.graph), this.normalizationFunction = de(this.customBBox || this.nodeExtent);
    const s = new G(), r = N(
      s.getState(),
      n,
      this.getGraphDimensions(),
      this.getSetting("stagePadding") || 0
    );
    this.labelGrid.resizeAndClear(n, t.labelGridCellSize);
    const o = {}, a = {}, d = {}, h = {};
    let l = 1, u = e.nodes();
    for (let c = 0, v = u.length; c < v; c++) {
      const m = u[c], p = this.nodeDataCache[m], E = e.getNodeAttributes(m);
      p.x = E.x, p.y = E.y, this.normalizationFunction.applyTo(p), typeof p.label == "string" && !p.hidden && this.labelGrid.add(m, p.size, this.framedGraphToViewport(p, { matrix: r })), o[p.type] = (o[p.type] || 0) + 1;
    }
    this.labelGrid.organize();
    for (const c in this.nodePrograms) {
      if (!this.nodePrograms.hasOwnProperty(c))
        throw new Error(`Sigma: could not find a suitable program for node type "${c}"!`);
      this.nodePrograms[c].reallocate(o[c] || 0), o[c] = 0;
    }
    this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1] && (u = le(
      this.nodeZExtent,
      (c) => this.nodeDataCache[c].zIndex,
      u
    ));
    for (let c = 0, v = u.length; c < v; c++) {
      const m = u[c];
      a[m] = l, h[a[m]] = { type: "node", id: m }, l++;
      const p = this.nodeDataCache[m];
      this.addNodeToProgram(m, a[m], o[p.type]++);
    }
    const f = {};
    let g = e.edges();
    for (let c = 0, v = g.length; c < v; c++) {
      const m = g[c], p = this.edgeDataCache[m];
      f[p.type] = (f[p.type] || 0) + 1;
    }
    this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1] && (g = le(
      this.edgeZExtent,
      (c) => this.edgeDataCache[c].zIndex,
      g
    ));
    for (const c in this.edgePrograms) {
      if (!this.edgePrograms.hasOwnProperty(c))
        throw new Error(`Sigma: could not find a suitable program for edge type "${c}"!`);
      this.edgePrograms[c].reallocate(f[c] || 0), f[c] = 0;
    }
    for (let c = 0, v = g.length; c < v; c++) {
      const m = g[c];
      d[m] = l, h[d[m]] = { type: "edge", id: m }, l++;
      const p = this.edgeDataCache[m];
      this.addEdgeToProgram(m, d[m], f[p.type]++);
    }
    return this.itemIDsIndex = h, this.nodeIndices = a, this.edgeIndices = d, this;
  }
  /**
   * Method that backports potential settings updates where it's needed.
   * @private
   */
  handleSettingsUpdate() {
    return this.camera.minRatio = this.settings.minCameraRatio, this.camera.maxRatio = this.settings.maxCameraRatio, this.camera.setState(this.camera.validateState(this.camera.getState())), this;
  }
  /**
   * Method used to render labels.
   *
   * @return {Sigma}
   */
  renderLabels() {
    if (!this.settings.renderLabels)
      return this;
    const e = this.camera.getState(), t = this.labelGrid.getLabelsToDisplay(e.ratio, this.settings.labelDensity);
    Ae(t, this.nodesWithForcedLabels), this.displayedNodeLabels = /* @__PURE__ */ new Set();
    const n = this.canvasContexts.labels;
    for (let s = 0, r = t.length; s < r; s++) {
      const o = t[s], a = this.nodeDataCache[o];
      if (this.displayedNodeLabels.has(o) || a.hidden)
        continue;
      const { x: d, y: h } = this.framedGraphToViewport(a), l = this.scaleSize(a.size);
      if (!a.forceLabel && l < this.settings.labelRenderedSizeThreshold || d < -Fe || d > this.width + Fe || h < -Ne || h > this.height + Ne)
        continue;
      this.displayedNodeLabels.add(o);
      const { nodeProgramClasses: u, defaultDrawNodeLabel: f } = this.settings;
      (u[a.type].drawLabel || f)(
        n,
        {
          key: o,
          ...a,
          size: l,
          x: d,
          y: h
        },
        this.settings
      );
    }
    return this;
  }
  /**
   * Method used to render edge labels, based on which node labels were
   * rendered.
   *
   * @return {Sigma}
   */
  renderEdgeLabels() {
    if (!this.settings.renderEdgeLabels)
      return this;
    const e = this.canvasContexts.edgeLabels;
    e.clearRect(0, 0, this.width, this.height);
    const t = Dt({
      graph: this.graph,
      hoveredNode: this.hoveredNode,
      displayedNodeLabels: this.displayedNodeLabels,
      highlightedNodes: this.highlightedNodes
    });
    Ae(t, this.edgesWithForcedLabels);
    const n = /* @__PURE__ */ new Set();
    for (let s = 0, r = t.length; s < r; s++) {
      const o = t[s], a = this.graph.extremities(o), d = this.nodeDataCache[a[0]], h = this.nodeDataCache[a[1]], l = this.edgeDataCache[o];
      if (n.has(o) || l.hidden || d.hidden || h.hidden)
        continue;
      const { edgeProgramClasses: u, defaultDrawEdgeLabel: f } = this.settings;
      (u[l.type].drawLabel || f)(
        e,
        {
          key: o,
          ...l,
          size: this.scaleSize(l.size)
        },
        {
          key: a[0],
          ...d,
          ...this.framedGraphToViewport(d),
          size: this.scaleSize(d.size)
        },
        {
          key: a[1],
          ...h,
          ...this.framedGraphToViewport(h),
          size: this.scaleSize(h.size)
        },
        this.settings
      ), n.add(o);
    }
    return this.displayedEdgeLabels = n, this;
  }
  /**
   * Method used to render the highlighted nodes.
   *
   * @return {Sigma}
   */
  renderHighlightedNodes() {
    const e = this.canvasContexts.hovers;
    e.clearRect(0, 0, this.width, this.height);
    const t = (r) => {
      const o = this.nodeDataCache[r], { x: a, y: d } = this.framedGraphToViewport(o), h = this.scaleSize(o.size), { nodeProgramClasses: l, defaultDrawNodeHover: u } = this.settings;
      (l[o.type].drawHover || u)(
        e,
        {
          key: r,
          ...o,
          size: h,
          x: a,
          y: d
        },
        this.settings
      );
    }, n = [];
    this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden && n.push(this.hoveredNode), this.highlightedNodes.forEach((r) => {
      r !== this.hoveredNode && n.push(r);
    }), n.forEach((r) => t(r));
    const s = {};
    n.forEach((r) => {
      const o = this.nodeDataCache[r].type;
      s[o] = (s[o] || 0) + 1;
    });
    for (const r in this.nodeHoverPrograms)
      this.nodeHoverPrograms[r].reallocate(s[r] || 0), s[r] = 0;
    n.forEach((r) => {
      const o = this.nodeDataCache[r];
      this.nodeHoverPrograms[o.type].process(0, s[o.type]++, o);
    }), this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);
    for (const r in this.nodeHoverPrograms)
      this.nodeHoverPrograms[r].render({
        matrix: this.matrix,
        width: this.width,
        height: this.height,
        pixelRatio: this.pixelRatio,
        zoomRatio: this.camera.ratio,
        sizeRatio: 1 / this.scaleSize(),
        correctionRatio: this.correctionRatio,
        downSizingRatio: this.pickingDownSizingRatio
      });
  }
  /**
   * Method used to schedule a hover render.
   *
   */
  scheduleHighlightedNodesRender() {
    this.renderHighlightedNodesFrame || this.renderFrame || (this.renderHighlightedNodesFrame = B(() => {
      this.renderHighlightedNodesFrame = null, this.renderHighlightedNodes(), this.renderEdgeLabels();
    }));
  }
  /**
   * Method used to render.
   *
   * @return {Sigma}
   */
  render() {
    this.emit("beforeRender");
    const e = () => (this.emit("afterRender"), this);
    if (this.renderFrame && (I(this.renderFrame), this.renderFrame = null), this.resize(), this.needToProcess && this.process(), this.needToProcess = !1, this.clear(), this.pickingLayers.forEach((h) => this.resetWebGLTexture(h)), !this.graph.order)
      return e();
    const t = this.mouseCaptor, n = this.camera.isAnimated() || t.isMoving || t.draggedEvents || t.currentWheelDirection, s = this.camera.getState(), r = this.getDimensions(), o = this.getGraphDimensions(), a = this.getSetting("stagePadding") || 0;
    this.matrix = N(s, r, o, a), this.invMatrix = N(s, r, o, a, !0), this.correctionRatio = rt(this.matrix, s, r), this.graphToViewportRatio = this.getGraphToViewportRatio();
    const d = {
      matrix: this.matrix,
      width: this.width,
      height: this.height,
      pixelRatio: this.pixelRatio,
      zoomRatio: this.camera.ratio,
      sizeRatio: 1 / this.scaleSize(),
      correctionRatio: this.correctionRatio,
      downSizingRatio: this.pickingDownSizingRatio
    };
    for (const h in this.nodePrograms)
      this.nodePrograms[h].render(d);
    if (!this.settings.hideEdgesOnMove || !n)
      for (const h in this.edgePrograms)
        this.edgePrograms[h].render(d);
    return this.settings.hideLabelsOnMove && n || (this.renderLabels(), this.renderEdgeLabels(), this.renderHighlightedNodes()), e();
  }
  /**
   * Add a node in the internal data structures.
   * @private
   * @param key The node's graphology ID
   */
  addNode(e) {
    let t = Object.assign({}, this.graph.getNodeAttributes(e));
    this.settings.nodeReducer && (t = this.settings.nodeReducer(e, t));
    const n = hi(this.settings, e, t);
    this.nodeDataCache[e] = n, this.nodesWithForcedLabels.delete(e), n.forceLabel && !n.hidden && this.nodesWithForcedLabels.add(e), this.highlightedNodes.delete(e), n.highlighted && !n.hidden && this.highlightedNodes.add(e), this.settings.zIndex && (n.zIndex < this.nodeZExtent[0] && (this.nodeZExtent[0] = n.zIndex), n.zIndex > this.nodeZExtent[1] && (this.nodeZExtent[1] = n.zIndex));
  }
  /**
   * Update a node the internal data structures.
   * @private
   * @param key The node's graphology ID
   */
  updateNode(e) {
    this.addNode(e);
    const t = this.nodeDataCache[e];
    this.normalizationFunction.applyTo(t);
  }
  /**
   * Remove a node from the internal data structures.
   * @private
   * @param key The node's graphology ID
   */
  removeNode(e) {
    delete this.nodeDataCache[e], delete this.nodeProgramIndex[e], this.highlightedNodes.delete(e), this.hoveredNode === e && (this.hoveredNode = null), this.nodesWithForcedLabels.delete(e);
  }
  /**
   * Add an edge into the internal data structures.
   * @private
   * @param key The edge's graphology ID
   */
  addEdge(e) {
    let t = Object.assign({}, this.graph.getEdgeAttributes(e));
    this.settings.edgeReducer && (t = this.settings.edgeReducer(e, t));
    const n = di(this.settings, e, t);
    this.edgeDataCache[e] = n, this.edgesWithForcedLabels.delete(e), n.forceLabel && !n.hidden && this.edgesWithForcedLabels.add(e), this.settings.zIndex && (n.zIndex < this.edgeZExtent[0] && (this.edgeZExtent[0] = n.zIndex), n.zIndex > this.edgeZExtent[1] && (this.edgeZExtent[1] = n.zIndex));
  }
  /**
   * Update an edge in the internal data structures.
   * @private
   * @param key The edge's graphology ID
   */
  updateEdge(e) {
    this.addEdge(e);
  }
  /**
   * Remove an edge from the internal data structures.
   * @private
   * @param key The edge's graphology ID
   */
  removeEdge(e) {
    delete this.edgeDataCache[e], delete this.edgeProgramIndex[e], this.hoveredEdge === e && (this.hoveredEdge = null), this.edgesWithForcedLabels.delete(e);
  }
  /**
   * Clear all indices related to nodes.
   * @private
   */
  clearNodeIndices() {
    this.labelGrid = new Ee(), this.nodeExtent = { x: [0, 1], y: [0, 1] }, this.nodeDataCache = {}, this.edgeProgramIndex = {}, this.nodesWithForcedLabels = /* @__PURE__ */ new Set(), this.nodeZExtent = [1 / 0, -1 / 0];
  }
  /**
   * Clear all indices related to edges.
   * @private
   */
  clearEdgeIndices() {
    this.edgeDataCache = {}, this.edgeProgramIndex = {}, this.edgesWithForcedLabels = /* @__PURE__ */ new Set(), this.edgeZExtent = [1 / 0, -1 / 0];
  }
  /**
   * Clear all indices.
   * @private
   */
  clearIndices() {
    this.clearEdgeIndices(), this.clearNodeIndices();
  }
  /**
   * Clear all graph state related to nodes.
   * @private
   */
  clearNodeState() {
    this.displayedNodeLabels = /* @__PURE__ */ new Set(), this.highlightedNodes = /* @__PURE__ */ new Set(), this.hoveredNode = null;
  }
  /**
   * Clear all graph state related to edges.
   * @private
   */
  clearEdgeState() {
    this.displayedEdgeLabels = /* @__PURE__ */ new Set(), this.highlightedNodes = /* @__PURE__ */ new Set(), this.hoveredEdge = null;
  }
  /**
   * Clear all graph state.
   * @private
   */
  clearState() {
    this.clearEdgeState(), this.clearNodeState();
  }
  /**
   * Add the node data to its program.
   * @private
   * @param node The node's graphology ID
   * @param fingerprint A fingerprint used to identity the node with picking
   * @param position The index where to place the node in the program
   */
  addNodeToProgram(e, t, n) {
    const s = this.nodeDataCache[e], r = this.nodePrograms[s.type];
    if (!r)
      throw new Error(`Sigma: could not find a suitable program for node type "${s.type}"!`);
    r.process(t, n, s), this.nodeProgramIndex[e] = n;
  }
  /**
   * Add the edge data to its program.
   * @private
   * @param edge The edge's graphology ID
   * @param fingerprint A fingerprint used to identity the edge with picking
   * @param position The index where to place the edge in the program
   */
  addEdgeToProgram(e, t, n) {
    const s = this.edgeDataCache[e], r = this.edgePrograms[s.type];
    if (!r)
      throw new Error(`Sigma: could not find a suitable program for edge type "${s.type}"!`);
    const o = this.graph.extremities(e), a = this.nodeDataCache[o[0]], d = this.nodeDataCache[o[1]];
    r.process(t, n, a, d, s), this.edgeProgramIndex[e] = n;
  }
  /**---------------------------------------------------------------------------
   * Public API.
   **---------------------------------------------------------------------------
   */
  /**
   * Method returning the renderer's camera.
   *
   * @return {Camera}
   */
  getCamera() {
    return this.camera;
  }
  /**
   * Method setting the renderer's camera.
   *
   * @param  {Camera} camera - New camera.
   * @return {Sigma}
   */
  setCamera(e) {
    this.unbindCameraHandlers(), this.camera = e, this.bindCameraHandlers();
  }
  /**
   * Method returning the container DOM element.
   *
   * @return {HTMLElement}
   */
  getContainer() {
    return this.container;
  }
  /**
   * Method returning the renderer's graph.
   *
   * @return {Graph}
   */
  getGraph() {
    return this.graph;
  }
  /**
   * Method used to set the renderer's graph.
   *
   * @return {Graph}
   */
  setGraph(e) {
    e !== this.graph && (this.unbindGraphHandlers(), this.checkEdgesEventsFrame !== null && (I(this.checkEdgesEventsFrame), this.checkEdgesEventsFrame = null), this.graph = e, this.bindGraphHandlers(), this.refresh());
  }
  /**
   * Method returning the mouse captor.
   *
   * @return {MouseCaptor}
   */
  getMouseCaptor() {
    return this.mouseCaptor;
  }
  /**
   * Method returning the touch captor.
   *
   * @return {TouchCaptor}
   */
  getTouchCaptor() {
    return this.touchCaptor;
  }
  /**
   * Method returning the current renderer's dimensions.
   *
   * @return {Dimensions}
   */
  getDimensions() {
    return { width: this.width, height: this.height };
  }
  /**
   * Method returning the current graph's dimensions.
   *
   * @return {Dimensions}
   */
  getGraphDimensions() {
    const e = this.customBBox || this.nodeExtent;
    return {
      width: e.x[1] - e.x[0] || 1,
      height: e.y[1] - e.y[0] || 1
    };
  }
  /**
   * Method used to get all the sigma node attributes.
   * It's usefull for example to get the position of a node
   * and to get values that are set by the nodeReducer
   *
   * @param  {string} key - The node's key.
   * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found
   */
  getNodeDisplayData(e) {
    const t = this.nodeDataCache[e];
    return t ? Object.assign({}, t) : void 0;
  }
  /**
   * Method used to get all the sigma edge attributes.
   * It's useful for example to get values that are set by the edgeReducer.
   *
   * @param  {string} key - The edge's key.
   * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found
   */
  getEdgeDisplayData(e) {
    const t = this.edgeDataCache[e];
    return t ? Object.assign({}, t) : void 0;
  }
  /**
   * Method used to get the set of currently displayed node labels.
   *
   * @return {Set<string>} A set of node keys whose label is displayed.
   */
  getNodeDisplayedLabels() {
    return new Set(this.displayedNodeLabels);
  }
  /**
   * Method used to get the set of currently displayed edge labels.
   *
   * @return {Set<string>} A set of edge keys whose label is displayed.
   */
  getEdgeDisplayedLabels() {
    return new Set(this.displayedEdgeLabels);
  }
  /**
   * Method returning a copy of the settings collection.
   *
   * @return {Settings} A copy of the settings collection.
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * Method returning the current value for a given setting key.
   *
   * @param  {string} key - The setting key to get.
   * @return {any} The value attached to this setting key or undefined if not found
   */
  getSetting(e) {
    return this.settings[e];
  }
  /**
   * Method setting the value of a given setting key. Note that this will schedule
   * a new render next frame.
   *
   * @param  {string} key - The setting key to set.
   * @param  {any}    value - The value to set.
   * @return {Sigma}
   */
  setSetting(e, t) {
    return this.settings[e] = t, K(this.settings), this.handleSettingsUpdate(), this.refresh(), this;
  }
  /**
   * Method updating the value of a given setting key using the provided function.
   * Note that this will schedule a new render next frame.
   *
   * @param  {string}   key     - The setting key to set.
   * @param  {function} updater - The update function.
   * @return {Sigma}
   */
  updateSetting(e, t) {
    return this.settings[e] = t(this.settings[e]), K(this.settings), this.handleSettingsUpdate(), this.scheduleRefresh(), this;
  }
  /**
   * Method used to resize the renderer.
   *
   * @return {Sigma}
   */
  resize() {
    const e = this.width, t = this.height;
    if (this.width = this.container.offsetWidth, this.height = this.container.offsetHeight, this.pixelRatio = he(), this.width === 0)
      if (this.settings.allowInvalidContainer)
        this.width = 1;
      else
        throw new Error(
          "Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error."
        );
    if (this.height === 0)
      if (this.settings.allowInvalidContainer)
        this.height = 1;
      else
        throw new Error(
          "Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error."
        );
    if (e === this.width && t === this.height)
      return this;
    this.emit("resize");
    for (const n in this.elements) {
      const s = this.elements[n];
      s.style.width = this.width + "px", s.style.height = this.height + "px";
    }
    for (const n in this.canvasContexts)
      this.elements[n].setAttribute("width", this.width * this.pixelRatio + "px"), this.elements[n].setAttribute("height", this.height * this.pixelRatio + "px"), this.pixelRatio !== 1 && this.canvasContexts[n].scale(this.pixelRatio, this.pixelRatio);
    for (const n in this.webGLContexts) {
      this.elements[n].setAttribute("width", this.width * this.pixelRatio + "px"), this.elements[n].setAttribute("height", this.height * this.pixelRatio + "px");
      const s = this.webGLContexts[n];
      if (s.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio), this.pickingLayers.has(n)) {
        const r = this.textures[n];
        r && s.deleteTexture(r);
      }
    }
    return this;
  }
  /**
   * Method used to clear all the canvases.
   *
   * @return {Sigma}
   */
  clear() {
    return this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null), this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT), this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null), this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT), this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT), this.canvasContexts.labels.clearRect(0, 0, this.width, this.height), this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height), this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height), this;
  }
  /**
   * Method used to refresh, i.e. force the renderer to reprocess graph
   * data and render, but keep the state.
   * - if a partialGraph is provided, we only reprocess those nodes & edges.
   * - if schedule is TRUE, we schedule a render instead of sync render
   * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)
   *
   * @return {Sigma}
   */
  refresh(e) {
    var r, o;
    const t = (e == null ? void 0 : e.skipIndexation) !== void 0 ? e == null ? void 0 : e.skipIndexation : !1, n = (e == null ? void 0 : e.schedule) !== void 0 ? e.schedule : !1, s = !e || !e.partialGraph;
    if (s)
      this.clearEdgeIndices(), this.clearNodeIndices(), this.graph.forEachNode((a) => this.addNode(a)), this.graph.forEachEdge((a) => this.addEdge(a));
    else {
      const a = ((r = e.partialGraph) == null ? void 0 : r.nodes) || [];
      for (let h = 0, l = (a == null ? void 0 : a.length) || 0; h < l; h++) {
        const u = a[h];
        if (this.updateNode(u), t) {
          const f = this.nodeProgramIndex[u];
          if (f === void 0)
            throw new Error(`Sigma: node "${u}" can't be repaint`);
          this.addNodeToProgram(u, this.nodeIndices[u], f);
        }
      }
      const d = ((o = e == null ? void 0 : e.partialGraph) == null ? void 0 : o.edges) || [];
      for (let h = 0, l = d.length; h < l; h++) {
        const u = d[h];
        if (this.updateEdge(u), t) {
          const f = this.edgeProgramIndex[u];
          if (f === void 0)
            throw new Error(`Sigma: edge "${u}" can't be repaint`);
          this.addEdgeToProgram(u, this.edgeIndices[u], f);
        }
      }
    }
    return (s || !t) && (this.needToProcess = !0), n ? this.scheduleRender() : this.render(), this;
  }
  /**
   * Method used to schedule a render at the next available frame.
   * This method can be safely called on a same frame because it basically
   * debounces refresh to the next frame.
   *
   * @return {Sigma}
   */
  scheduleRender() {
    return this.renderFrame || (this.renderFrame = B(() => {
      this.render();
    })), this;
  }
  /**
   * Method used to schedule a refresh (i.e. fully reprocess graph data and render)
   * at the next available frame.
   * This method can be safely called on a same frame because it basically
   * debounces refresh to the next frame.
   *
   * @return {Sigma}
   */
  scheduleRefresh(e) {
    return this.refresh({ ...e, schedule: !0 });
  }
  /**
   * Method used to (un)zoom, while preserving the position of a viewport point.
   * Used for instance to zoom "on the mouse cursor".
   *
   * @param viewportTarget
   * @param newRatio
   * @return {CameraState}
   */
  getViewportZoomedState(e, t) {
    const { ratio: n, angle: s, x: r, y: o } = this.camera.getState(), a = t / n, d = {
      x: this.width / 2,
      y: this.height / 2
    }, h = this.viewportToFramedGraph(e), l = this.viewportToFramedGraph(d);
    return {
      angle: s,
      x: (h.x - l.x) * (1 - a) + r,
      y: (h.y - l.y) * (1 - a) + o,
      ratio: t
    };
  }
  /**
   * Method returning the abstract rectangle containing the graph according
   * to the camera's state.
   *
   * @return {object} - The view's rectangle.
   */
  viewRectangle() {
    const e = 0 * this.width / 8, t = 0 * this.height / 8, n = this.viewportToFramedGraph({ x: 0 - e, y: 0 - t }), s = this.viewportToFramedGraph({ x: this.width + e, y: 0 - t }), r = this.viewportToFramedGraph({ x: 0, y: this.height + t });
    return {
      x1: n.x,
      y1: n.y,
      x2: s.x,
      y2: s.y,
      height: s.y - r.y
    };
  }
  /**
   * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows
   * overriding anything that is used to get the translation matrix, or even the matrix itself.
   *
   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
   * of computations.
   */
  framedGraphToViewport(e, t = {}) {
    const n = !!t.cameraState || !!t.viewportDimensions || !!t.graphDimensions, s = t.matrix ? t.matrix : n ? N(
      t.cameraState || this.camera.getState(),
      t.viewportDimensions || this.getDimensions(),
      t.graphDimensions || this.getGraphDimensions(),
      t.padding || this.getSetting("stagePadding") || 0
    ) : this.matrix, r = J(s, e);
    return {
      x: (1 + r.x) * this.width / 2,
      y: (1 - r.y) * this.height / 2
    };
  }
  /**
   * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows
   * overriding anything that is used to get the translation matrix, or even the matrix itself.
   *
   * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
   * of computations.
   */
  viewportToFramedGraph(e, t = {}) {
    const n = !!t.cameraState || !!t.viewportDimensions || !t.graphDimensions, s = t.matrix ? t.matrix : n ? N(
      t.cameraState || this.camera.getState(),
      t.viewportDimensions || this.getDimensions(),
      t.graphDimensions || this.getGraphDimensions(),
      t.padding || this.getSetting("stagePadding") || 0,
      !0
    ) : this.invMatrix, r = J(s, {
      x: e.x / this.width * 2 - 1,
      y: 1 - e.y / this.height * 2
    });
    return isNaN(r.x) && (r.x = 0), isNaN(r.y) && (r.y = 0), r;
  }
  /**
   * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the
   * stage) to the graph system (the reference system of data as they are in the given graph instance).
   *
   * This method accepts an optional camera which can be useful if you need to translate coordinates
   * based on a different view than the one being currently being displayed on screen.
   *
   * @param {Coordinates}                  viewportPoint
   * @param {CoordinateConversionOverride} override
   */
  viewportToGraph(e, t = {}) {
    return this.normalizationFunction.inverse(this.viewportToFramedGraph(e, t));
  }
  /**
   * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in
   * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).
   *
   * This method accepts an optional camera which can be useful if you need to translate coordinates
   * based on a different view than the one being currently being displayed on screen.
   *
   * @param {Coordinates}                  graphPoint
   * @param {CoordinateConversionOverride} override
   */
  graphToViewport(e, t = {}) {
    return this.framedGraphToViewport(this.normalizationFunction(e), t);
  }
  /**
   * Method returning the distance multiplier between the graph system and the
   * viewport system.
   */
  getGraphToViewportRatio() {
    const e = { x: 0, y: 0 }, t = { x: 1, y: 1 }, n = Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)), s = this.graphToViewport(e), r = this.graphToViewport(t);
    return Math.sqrt(Math.pow(s.x - r.x, 2) + Math.pow(s.y - r.y, 2)) / n;
  }
  /**
   * Method returning the graph's bounding box.
   *
   * @return {{ x: Extent, y: Extent }}
   */
  getBBox() {
    return this.nodeExtent;
  }
  /**
   * Method returning the graph's custom bounding box, if any.
   *
   * @return {{ x: Extent, y: Extent } | null}
   */
  getCustomBBox() {
    return this.customBBox;
  }
  /**
   * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.
   *
   * @return {Sigma}
   */
  setCustomBBox(e) {
    return this.customBBox = e, this.scheduleRender(), this;
  }
  /**
   * Method used to shut the container & release event listeners.
   *
   * @return {undefined}
   */
  kill() {
    var t;
    this.emit("kill"), this.removeAllListeners(), this.unbindCameraHandlers(), window.removeEventListener("resize", this.activeListeners.handleResize), this.mouseCaptor.kill(), this.touchCaptor.kill(), this.unbindGraphHandlers(), this.clearIndices(), this.clearState(), this.nodeDataCache = {}, this.edgeDataCache = {}, this.highlightedNodes.clear(), this.renderFrame && (I(this.renderFrame), this.renderFrame = null), this.renderHighlightedNodesFrame && (I(this.renderHighlightedNodesFrame), this.renderHighlightedNodesFrame = null);
    for (const n in this.webGLContexts)
      (t = this.webGLContexts[n].getExtension("WEBGL_lose_context")) == null || t.loseContext();
    const e = this.container;
    for (; e.firstChild; )
      e.removeChild(e.firstChild);
    this.canvasContexts = {}, this.webGLContexts = {}, this.elements = {}, this.nodePrograms = {}, this.nodeHoverPrograms = {}, this.edgePrograms = {};
  }
  /**
   * Method used to scale the given size according to the camera's ratio, i.e.
   * zooming state.
   *
   * @param  {number?} size -        The size to scale (node size, edge thickness etc.).
   * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).
   * @return {number}              - The scaled size.
   */
  scaleSize(e = 1, t = this.camera.ratio) {
    return e / this.settings.zoomToSizeRatioFunction(t) * (this.getSetting("itemSizesReference") === "positions" ? t * this.graphToViewportRatio : 1);
  }
  /**
   * Method that returns the collection of all used canvases.
   * At the moment, the instantiated canvases are the following, and in the
   * following order in the DOM:
   * - `edges`
   * - `nodes`
   * - `edgeLabels`
   * - `labels`
   * - `hovers`
   * - `hoverNodes`
   * - `mouse`
   *
   * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.
   */
  getCanvases() {
    return { ...this.elements };
  }
}
export {
  G as Camera,
  Nt as MouseCaptor,
  li as Sigma,
  li as default
};
//# sourceMappingURL=index.es.js.map
